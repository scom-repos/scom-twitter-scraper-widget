/*!-----------------------------------------------------------
* Copyright (c) IJS Technologies. All rights reserved.
* Released under dual AGPLv3/commercial license
* https://ijs.network
*-----------------------------------------------------------*/

//https://github.com/microsoft/vscode-loader
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _amdLoaderGlobal = this;
var _currentDefineModule;
var _defined = {};
var _commonjsGlobal = typeof global === 'object' ? global : {};
var AMDLoader;
(function (AMDLoader) {
    AMDLoader.global = _amdLoaderGlobal;
    var Environment = /** @class */ (function () {
        function Environment() {
            this._detected = false;
            this._isWindows = false;
            this._isNode = false;
            this._isElectronRenderer = false;
            this._isWebWorker = false;
            this._isElectronNodeIntegrationWebWorker = false;
        }
        Object.defineProperty(Environment.prototype, "isWindows", {
            get: function () {
                this._detect();
                return this._isWindows;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment.prototype, "isNode", {
            get: function () {
                this._detect();
                return this._isNode;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment.prototype, "isElectronRenderer", {
            get: function () {
                this._detect();
                return this._isElectronRenderer;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment.prototype, "isWebWorker", {
            get: function () {
                this._detect();
                return this._isWebWorker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Environment.prototype, "isElectronNodeIntegrationWebWorker", {
            get: function () {
                this._detect();
                return this._isElectronNodeIntegrationWebWorker;
            },
            enumerable: false,
            configurable: true
        });
        Environment.prototype._detect = function () {
            if (this._detected) {
                return;
            }
            this._detected = true;
            this._isWindows = Environment._isWindows();
            this._isNode = (typeof module !== 'undefined' && !!module.exports);
            this._isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');
            this._isWebWorker = (typeof AMDLoader.global.importScripts === 'function');
            this._isElectronNodeIntegrationWebWorker = this._isWebWorker && (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'worker');
        };
        Environment._isWindows = function () {
            if (typeof navigator !== 'undefined') {
                if (navigator.userAgent && navigator.userAgent.indexOf('Windows') >= 0) {
                    return true;
                }
            }
            if (typeof process !== 'undefined') {
                return (process.platform === 'win32');
            }
            return false;
        };
        return Environment;
    }());
    AMDLoader.Environment = Environment;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    var LoaderEvent = /** @class */ (function () {
        function LoaderEvent(type, detail, timestamp) {
            this.type = type;
            this.detail = detail;
            this.timestamp = timestamp;
        }
        return LoaderEvent;
    }());
    AMDLoader.LoaderEvent = LoaderEvent;
    var LoaderEventRecorder = /** @class */ (function () {
        function LoaderEventRecorder(loaderAvailableTimestamp) {
            this._events = [new LoaderEvent(1 /* LoaderAvailable */, '', loaderAvailableTimestamp)];
        }
        LoaderEventRecorder.prototype.record = function (type, detail) {
            this._events.push(new LoaderEvent(type, detail, AMDLoader.Utilities.getHighPerformanceTimestamp()));
        };
        LoaderEventRecorder.prototype.getEvents = function () {
            return this._events;
        };
        return LoaderEventRecorder;
    }());
    AMDLoader.LoaderEventRecorder = LoaderEventRecorder;
    var NullLoaderEventRecorder = /** @class */ (function () {
        function NullLoaderEventRecorder() {
        }
        NullLoaderEventRecorder.prototype.record = function (type, detail) {
            // Nothing to do
        };
        NullLoaderEventRecorder.prototype.getEvents = function () {
            return [];
        };
        NullLoaderEventRecorder.INSTANCE = new NullLoaderEventRecorder();
        return NullLoaderEventRecorder;
    }());
    AMDLoader.NullLoaderEventRecorder = NullLoaderEventRecorder;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    var Utilities = /** @class */ (function () {
        function Utilities() {
        }
        /**
         * This method does not take care of / vs \
         */
        Utilities.fileUriToFilePath = function (isWindows, uri) {
            uri = decodeURI(uri).replace(/%23/g, '#');
            if (isWindows) {
                if (/^file:\/\/\//.test(uri)) {
                    // This is a URI without a hostname => return only the path segment
                    return uri.substr(8);
                }
                if (/^file:\/\//.test(uri)) {
                    return uri.substr(5);
                }
            }
            else {
                if (/^file:\/\//.test(uri)) {
                    return uri.substr(7);
                }
            }
            // Not sure...
            return uri;
        };
        Utilities.startsWith = function (haystack, needle) {
            return haystack.length >= needle.length && haystack.substr(0, needle.length) === needle;
        };
        Utilities.endsWith = function (haystack, needle) {
            return haystack.length >= needle.length && haystack.substr(haystack.length - needle.length) === needle;
        };
        // only check for "?" before "#" to ensure that there is a real Query-String
        Utilities.containsQueryString = function (url) {
            return /^[^\#]*\?/gi.test(url);
        };
        /**
         * Does `url` start with http:// or https:// or file:// or / ?
         */
        Utilities.isAbsolutePath = function (url) {
            return /^((http:\/\/)|(https:\/\/)|(file:\/\/)|(\/))/.test(url);
        };
        Utilities.forEachProperty = function (obj, callback) {
            if (obj) {
                var key = void 0;
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        callback(key, obj[key]);
                    }
                }
            }
        };
        Utilities.isEmpty = function (obj) {
            var isEmpty = true;
            Utilities.forEachProperty(obj, function () {
                isEmpty = false;
            });
            return isEmpty;
        };
        Utilities.recursiveClone = function (obj) {
            if (!obj || typeof obj !== 'object' || obj instanceof RegExp) {
                return obj;
            }
            if (!Array.isArray(obj) && Object.getPrototypeOf(obj) !== Object.prototype) {
                // only clone "simple" objects
                return obj;
            }
            var result = Array.isArray(obj) ? [] : {};
            Utilities.forEachProperty(obj, function (key, value) {
                if (value && typeof value === 'object') {
                    result[key] = Utilities.recursiveClone(value);
                }
                else {
                    result[key] = value;
                }
            });
            return result;
        };
        Utilities.generateAnonymousModule = function () {
            return '===anonymous' + (Utilities.NEXT_ANONYMOUS_ID++) + '===';
        };
        Utilities.isAnonymousModule = function (id) {
            return Utilities.startsWith(id, '===anonymous');
        };
        Utilities.getHighPerformanceTimestamp = function () {
            if (!this.PERFORMANCE_NOW_PROBED) {
                this.PERFORMANCE_NOW_PROBED = true;
                this.HAS_PERFORMANCE_NOW = (AMDLoader.global.performance && typeof AMDLoader.global.performance.now === 'function');
            }
            return (this.HAS_PERFORMANCE_NOW ? AMDLoader.global.performance.now() : Date.now());
        };
        Utilities.NEXT_ANONYMOUS_ID = 1;
        Utilities.PERFORMANCE_NOW_PROBED = false;
        Utilities.HAS_PERFORMANCE_NOW = false;
        return Utilities;
    }());
    AMDLoader.Utilities = Utilities;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    function ensureError(err) {
        if (err instanceof Error) {
            return err;
        }
        var result = new Error(err.message || String(err) || 'Unknown Error');
        if (err.stack) {
            result.stack = err.stack;
        }
        return result;
    }
    AMDLoader.ensureError = ensureError;
    ;
    var ConfigurationOptionsUtil = /** @class */ (function () {
        function ConfigurationOptionsUtil() {
        }
        /**
         * Ensure configuration options make sense
         */
        ConfigurationOptionsUtil.validateConfigurationOptions = function (options) {
            function defaultOnError(err) {
                if (err.phase === 'loading') {
                    console.error('Loading "' + err.moduleId + '" failed');
                    console.error(err);
                    console.error('Here are the modules that depend on it:');
                    console.error(err.neededBy);
                    return;
                }
                if (err.phase === 'factory') {
                    console.error('The factory method of "' + err.moduleId + '" has thrown an exception');
                    console.error(err);
                    return;
                }
            }
            options = options || {};
            if (typeof options.baseUrl !== 'string') {
                options.baseUrl = '';
            }
            if (typeof options.isBuild !== 'boolean') {
                options.isBuild = false;
            }
            if (typeof options.paths !== 'object') {
                options.paths = {};
            }
            if (typeof options.config !== 'object') {
                options.config = {};
            }
            if (typeof options.catchError === 'undefined') {
                options.catchError = false;
            }
            if (typeof options.recordStats === 'undefined') {
                options.recordStats = false;
            }
            if (typeof options.urlArgs !== 'string') {
                options.urlArgs = '';
            }
            if (typeof options.onError !== 'function') {
                options.onError = defaultOnError;
            }
            if (!Array.isArray(options.ignoreDuplicateModules)) {
                options.ignoreDuplicateModules = [];
            }
            if (options.baseUrl.length > 0) {
                if (!AMDLoader.Utilities.endsWith(options.baseUrl, '/')) {
                    options.baseUrl += '/';
                }
            }
            if (typeof options.cspNonce !== 'string') {
                options.cspNonce = '';
            }
            if (typeof options.preferScriptTags === 'undefined') {
                options.preferScriptTags = false;
            }
            if (!Array.isArray(options.nodeModules)) {
                options.nodeModules = [];
            }
            if (options.nodeCachedData && typeof options.nodeCachedData === 'object') {
                if (typeof options.nodeCachedData.seed !== 'string') {
                    options.nodeCachedData.seed = 'seed';
                }
                if (typeof options.nodeCachedData.writeDelay !== 'number' || options.nodeCachedData.writeDelay < 0) {
                    options.nodeCachedData.writeDelay = 1000 * 7;
                }
                if (!options.nodeCachedData.path || typeof options.nodeCachedData.path !== 'string') {
                    var err = ensureError(new Error('INVALID cached data configuration, \'path\' MUST be set'));
                    err.phase = 'configuration';
                    options.onError(err);
                    options.nodeCachedData = undefined;
                }
            }
            return options;
        };
        ConfigurationOptionsUtil.mergeConfigurationOptions = function (overwrite, base) {
            if (overwrite === void 0) { overwrite = null; }
            if (base === void 0) { base = null; }
            var result = AMDLoader.Utilities.recursiveClone(base || {});
            // Merge known properties and overwrite the unknown ones
            AMDLoader.Utilities.forEachProperty(overwrite, function (key, value) {
                if (key === 'ignoreDuplicateModules' && typeof result.ignoreDuplicateModules !== 'undefined') {
                    result.ignoreDuplicateModules = result.ignoreDuplicateModules.concat(value);
                }
                else if (key === 'paths' && typeof result.paths !== 'undefined') {
                    AMDLoader.Utilities.forEachProperty(value, function (key2, value2) { return result.paths[key2] = value2; });
                }
                else if (key === 'config' && typeof result.config !== 'undefined') {
                    AMDLoader.Utilities.forEachProperty(value, function (key2, value2) { return result.config[key2] = value2; });
                }
                else {
                    result[key] = AMDLoader.Utilities.recursiveClone(value);
                }
            });
            return ConfigurationOptionsUtil.validateConfigurationOptions(result);
        };
        return ConfigurationOptionsUtil;
    }());
    AMDLoader.ConfigurationOptionsUtil = ConfigurationOptionsUtil;
    var Configuration = /** @class */ (function () {
        function Configuration(env, options) {
            this._env = env;
            this.options = ConfigurationOptionsUtil.mergeConfigurationOptions(options);
            this._createIgnoreDuplicateModulesMap();
            this._createNodeModulesMap();
            this._createSortedPathsRules();
            if (this.options.baseUrl === '') {
                if (this.options.nodeRequire && this.options.nodeRequire.main && this.options.nodeRequire.main.filename && this._env.isNode) {
                    var nodeMain = this.options.nodeRequire.main.filename;
                    var dirnameIndex = Math.max(nodeMain.lastIndexOf('/'), nodeMain.lastIndexOf('\\'));
                    this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);
                }
                if (this.options.nodeMain && this._env.isNode) {
                    var nodeMain = this.options.nodeMain;
                    var dirnameIndex = Math.max(nodeMain.lastIndexOf('/'), nodeMain.lastIndexOf('\\'));
                    this.options.baseUrl = nodeMain.substring(0, dirnameIndex + 1);
                }
            }
        }
        Configuration.prototype._createIgnoreDuplicateModulesMap = function () {
            // Build a map out of the ignoreDuplicateModules array
            this.ignoreDuplicateModulesMap = {};
            for (var i = 0; i < this.options.ignoreDuplicateModules.length; i++) {
                this.ignoreDuplicateModulesMap[this.options.ignoreDuplicateModules[i]] = true;
            }
        };
        Configuration.prototype._createNodeModulesMap = function () {
            // Build a map out of nodeModules array
            this.nodeModulesMap = Object.create(null);
            for (var _i = 0, _a = this.options.nodeModules; _i < _a.length; _i++) {
                var nodeModule = _a[_i];
                this.nodeModulesMap[nodeModule] = true;
            }
        };
        Configuration.prototype._createSortedPathsRules = function () {
            var _this = this;
            // Create an array our of the paths rules, sorted descending by length to
            // result in a more specific -> less specific order
            this.sortedPathsRules = [];
            AMDLoader.Utilities.forEachProperty(this.options.paths, function (from, to) {
                if (!Array.isArray(to)) {
                    _this.sortedPathsRules.push({
                        from: from,
                        to: [to]
                    });
                }
                else {
                    _this.sortedPathsRules.push({
                        from: from,
                        to: to
                    });
                }
            });
            this.sortedPathsRules.sort(function (a, b) {
                return b.from.length - a.from.length;
            });
        };
        /**
         * Clone current configuration and overwrite options selectively.
         * @param options The selective options to overwrite with.
         * @result A new configuration
         */
        Configuration.prototype.cloneAndMerge = function (options) {
            return new Configuration(this._env, ConfigurationOptionsUtil.mergeConfigurationOptions(options, this.options));
        };
        /**
         * Get current options bag. Useful for passing it forward to plugins.
         */
        Configuration.prototype.getOptionsLiteral = function () {
            return this.options;
        };
        Configuration.prototype._applyPaths = function (moduleId) {
            var pathRule;
            for (var i = 0, len = this.sortedPathsRules.length; i < len; i++) {
                pathRule = this.sortedPathsRules[i];
                if (AMDLoader.Utilities.startsWith(moduleId, pathRule.from)) {
                    var result = [];
                    for (var j = 0, lenJ = pathRule.to.length; j < lenJ; j++) {
                        result.push(pathRule.to[j] + moduleId.substr(pathRule.from.length));
                    }
                    return result;
                }
            }
            return [moduleId];
        };
        Configuration.prototype._addUrlArgsToUrl = function (url) {
            if (AMDLoader.Utilities.containsQueryString(url)) {
                return url + '&' + this.options.urlArgs;
            }
            else {
                return url + '?' + this.options.urlArgs;
            }
        };
        Configuration.prototype._addUrlArgsIfNecessaryToUrl = function (url) {
            if (this.options.urlArgs) {
                return this._addUrlArgsToUrl(url);
            }
            return url;
        };
        Configuration.prototype._addUrlArgsIfNecessaryToUrls = function (urls) {
            if (this.options.urlArgs) {
                for (var i = 0, len = urls.length; i < len; i++) {
                    urls[i] = this._addUrlArgsToUrl(urls[i]);
                }
            }
            return urls;
        };
        /**
         * Transform a module id to a location. Appends .js to module ids
         */
        Configuration.prototype.moduleIdToPaths = function (moduleId) {
            if (this._env.isNode) {
                var isNodeModule = ((this.nodeModulesMap[moduleId] === true)
                    || (this.options.amdModulesPattern instanceof RegExp && !this.options.amdModulesPattern.test(moduleId)));
                if (isNodeModule) {
                    // This is a node module...
                    if (this.isBuild()) {
                        // ...and we are at build time, drop it
                        return ['empty:'];
                    }
                    else {
                        // ...and at runtime we create a `shortcut`-path
                        return ['node|' + moduleId];
                    }
                }
            }
            var result = moduleId;
            var results;
            if (!AMDLoader.Utilities.endsWith(result, '.js') && !AMDLoader.Utilities.isAbsolutePath(result)) {
                results = this._applyPaths(result);
                for (var i = 0, len = results.length; i < len; i++) {
                    if (this.isBuild() && results[i] === 'empty:') {
                        continue;
                    }
                    if (!AMDLoader.Utilities.isAbsolutePath(results[i])) {
                        results[i] = this.options.baseUrl + results[i];
                    }
                    if (!AMDLoader.Utilities.endsWith(results[i], '.js') && !AMDLoader.Utilities.containsQueryString(results[i])) {
                        results[i] = results[i] + '.js';
                    }
                }
            }
            else {
                if (!AMDLoader.Utilities.endsWith(result, '.js') && !AMDLoader.Utilities.containsQueryString(result)) {
                    result = result + '.js';
                }
                results = [result];
            }
            return this._addUrlArgsIfNecessaryToUrls(results);
        };
        /**
         * Transform a module id or url to a location.
         */
        Configuration.prototype.requireToUrl = function (url) {
            var result = url;
            if (!AMDLoader.Utilities.isAbsolutePath(result)) {
                result = this._applyPaths(result)[0];
                if (!AMDLoader.Utilities.isAbsolutePath(result)) {
                    result = this.options.baseUrl + result;
                }
            }
            return this._addUrlArgsIfNecessaryToUrl(result);
        };
        /**
         * Flag to indicate if current execution is as part of a build.
         */
        Configuration.prototype.isBuild = function () {
            return this.options.isBuild;
        };
        /**
         * Test if module `moduleId` is expected to be defined multiple times
         */
        Configuration.prototype.isDuplicateMessageIgnoredFor = function (moduleId) {
            return this.ignoreDuplicateModulesMap.hasOwnProperty(moduleId);
        };
        /**
         * Get the configuration settings for the provided module id
         */
        Configuration.prototype.getConfigForModule = function (moduleId) {
            if (this.options.config) {
                return this.options.config[moduleId];
            }
        };
        /**
         * Should errors be caught when executing module factories?
         */
        Configuration.prototype.shouldCatchError = function () {
            return this.options.catchError;
        };
        /**
         * Should statistics be recorded?
         */
        Configuration.prototype.shouldRecordStats = function () {
            return this.options.recordStats;
        };
        /**
         * Forward an error to the error handler.
         */
        Configuration.prototype.onError = function (err) {
            this.options.onError(err);
        };
        return Configuration;
    }());
    AMDLoader.Configuration = Configuration;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    /**
     * Load `scriptSrc` only once (avoid multiple <script> tags)
     */
    var OnlyOnceScriptLoader = /** @class */ (function () {
        function OnlyOnceScriptLoader(env) {
            this._env = env;
            this._scriptLoader = null;
            this._callbackMap = {};
        }
        OnlyOnceScriptLoader.prototype.load = function (moduleManager, scriptSrc, callback, errorback) {
            var _this = this;
            if (!this._scriptLoader) {
                if (this._env.isWebWorker) {
                    this._scriptLoader = new WorkerScriptLoader();
                }
                else if (this._env.isElectronRenderer) {
                    var preferScriptTags = moduleManager.getConfig().getOptionsLiteral().preferScriptTags;
                    if (preferScriptTags) {
                        this._scriptLoader = new BrowserScriptLoader();
                    }
                    else {
                        this._scriptLoader = new NodeScriptLoader(this._env);
                    }
                }
                else if (this._env.isNode) {
                    this._scriptLoader = new NodeScriptLoader(this._env);
                }
                else {
                    this._scriptLoader = new BrowserScriptLoader();
                }
            }
            var scriptCallbacks = {
                callback: callback,
                errorback: errorback
            };
            if (this._callbackMap.hasOwnProperty(scriptSrc)) {
                this._callbackMap[scriptSrc].push(scriptCallbacks);
                return;
            }
            this._callbackMap[scriptSrc] = [scriptCallbacks];
            this._scriptLoader.load(moduleManager, scriptSrc, function () { return _this.triggerCallback(scriptSrc); }, function (err) { return _this.triggerErrorback(scriptSrc, err); });
        };
        OnlyOnceScriptLoader.prototype.triggerCallback = function (scriptSrc) {
            var scriptCallbacks = this._callbackMap[scriptSrc];
            delete this._callbackMap[scriptSrc];
            for (var i = 0; i < scriptCallbacks.length; i++) {
                scriptCallbacks[i].callback();
            }
        };
        OnlyOnceScriptLoader.prototype.triggerErrorback = function (scriptSrc, err) {
            var scriptCallbacks = this._callbackMap[scriptSrc];
            delete this._callbackMap[scriptSrc];
            for (var i = 0; i < scriptCallbacks.length; i++) {
                scriptCallbacks[i].errorback(err);
            }
        };
        return OnlyOnceScriptLoader;
    }());
    var BrowserScriptLoader = /** @class */ (function () {
        function BrowserScriptLoader() {
        }
        /**
         * Attach load / error listeners to a script element and remove them when either one has fired.
         * Implemented for browsers supporting HTML5 standard 'load' and 'error' events.
         */
        BrowserScriptLoader.prototype.attachListeners = function (script, callback, errorback) {
            var unbind = function () {
                script.removeEventListener('load', loadEventListener);
                script.removeEventListener('error', errorEventListener);
            };
            var loadEventListener = function (e) {
                unbind();
                callback();
            };
            var errorEventListener = function (e) {
                unbind();
                errorback(e);
            };
            script.addEventListener('load', loadEventListener);
            script.addEventListener('error', errorEventListener);
        };
        BrowserScriptLoader.prototype.load = function (moduleManager, scriptSrc, callback, errorback) {
            if (/^node\|/.test(scriptSrc)) {
                var opts = moduleManager.getConfig().getOptionsLiteral();
                var nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), (opts.nodeRequire || AMDLoader.global.nodeRequire));
                var pieces = scriptSrc.split('|');
                var moduleExports_1 = null;
                try {
                    moduleExports_1 = nodeRequire(pieces[1]);
                }
                catch (err) {
                    errorback(err);
                    return;
                }
                moduleManager.enqueueDefineAnonymousModule([], function () { return moduleExports_1; });
                callback();
            }
            else {
                var script = document.createElement('script');
                script.setAttribute('async', 'async');
                script.setAttribute('type', 'text/javascript');
                this.attachListeners(script, callback, errorback);
                var trustedTypesPolicy = moduleManager.getConfig().getOptionsLiteral().trustedTypesPolicy;
                if (trustedTypesPolicy) {
                    scriptSrc = trustedTypesPolicy.createScriptURL(scriptSrc);
                }
                script.setAttribute('src', scriptSrc);
                // Propagate CSP nonce to dynamically created script tag.
                var cspNonce = moduleManager.getConfig().getOptionsLiteral().cspNonce;
                if (cspNonce) {
                    script.setAttribute('nonce', cspNonce);
                }
                document.getElementsByTagName('head')[0].appendChild(script);
            }
        };
        return BrowserScriptLoader;
    }());
    function canUseEval(moduleManager) {
        var trustedTypesPolicy = moduleManager.getConfig().getOptionsLiteral().trustedTypesPolicy;
        try {
            var func = (trustedTypesPolicy
                ? self.eval(trustedTypesPolicy.createScript('', 'true'))
                : new Function('true'));
            func.call(self);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    var WorkerScriptLoader = /** @class */ (function () {
        function WorkerScriptLoader() {
            this._cachedCanUseEval = null;
        }
        WorkerScriptLoader.prototype._canUseEval = function (moduleManager) {
            if (this._cachedCanUseEval === null) {
                this._cachedCanUseEval = canUseEval(moduleManager);
            }
            return this._cachedCanUseEval;
        };
        WorkerScriptLoader.prototype.load = function (moduleManager, scriptSrc, callback, errorback) {
            if (/^node\|/.test(scriptSrc)) {
                var opts = moduleManager.getConfig().getOptionsLiteral();
                var nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), (opts.nodeRequire || AMDLoader.global.nodeRequire));
                var pieces = scriptSrc.split('|');
                var moduleExports_2 = null;
                try {
                    moduleExports_2 = nodeRequire(pieces[1]);
                }
                catch (err) {
                    errorback(err);
                    return;
                }
                moduleManager.enqueueDefineAnonymousModule([], function () { return moduleExports_2; });
                callback();
            }
            else {
                var trustedTypesPolicy_1 = moduleManager.getConfig().getOptionsLiteral().trustedTypesPolicy;
                var isCrossOrigin = (/^((http:)|(https:)|(file:))/.test(scriptSrc) && scriptSrc.substring(0, self.origin.length) !== self.origin);
                if (!isCrossOrigin && this._canUseEval(moduleManager)) {
                    // use `fetch` if possible because `importScripts`
                    // is synchronous and can lead to deadlocks on Safari
                    fetch(scriptSrc).then(function (response) {
                        if (response.status !== 200) {
                            throw new Error(response.statusText);
                        }
                        return response.text();
                    }).then(function (text) {
                        text = text + "\n//# sourceURL=" + scriptSrc;
                        var func = (trustedTypesPolicy_1
                            ? self.eval(trustedTypesPolicy_1.createScript('', text))
                            : new Function(text));
                        func.call(self);
                        callback();
                    }).then(undefined, errorback);
                    return;
                }
                try {
                    if (trustedTypesPolicy_1) {
                        scriptSrc = trustedTypesPolicy_1.createScriptURL(scriptSrc);
                    }
                    importScripts(scriptSrc);
                    callback();
                }
                catch (e) {
                    errorback(e);
                }
            }
        };
        return WorkerScriptLoader;
    }());
    var NodeScriptLoader = /** @class */ (function () {
        function NodeScriptLoader(env) {
            this._env = env;
            this._didInitialize = false;
            this._didPatchNodeRequire = false;
        }
        NodeScriptLoader.prototype._init = function (nodeRequire) {
            if (this._didInitialize) {
                return;
            }
            this._didInitialize = true;
            // capture node modules
            this._fs = nodeRequire('fs');
            this._vm = nodeRequire('vm');
            this._path = nodeRequire('path');
            this._crypto = nodeRequire('crypto');
        };
        // patch require-function of nodejs such that we can manually create a script
        // from cached data. this is done by overriding the `Module._compile` function
        NodeScriptLoader.prototype._initNodeRequire = function (nodeRequire, moduleManager) {
            // It is important to check for `nodeCachedData` first and then set `_didPatchNodeRequire`.
            // That's because `nodeCachedData` is set _after_ calling this for the first time...
            var nodeCachedData = moduleManager.getConfig().getOptionsLiteral().nodeCachedData;
            if (!nodeCachedData) {
                return;
            }
            if (this._didPatchNodeRequire) {
                return;
            }
            this._didPatchNodeRequire = true;
            var that = this;
            var Module = nodeRequire('module');
            function makeRequireFunction(mod) {
                var Module = mod.constructor;
                var require = function require(path) {
                    try {
                        return mod.require(path);
                    }
                    finally {
                        // nothing
                    }
                };
                require.resolve = function resolve(request, options) {
                    return Module._resolveFilename(request, mod, false, options);
                };
                require.resolve.paths = function paths(request) {
                    return Module._resolveLookupPaths(request, mod);
                };
                require.main = process.mainModule;
                require.extensions = Module._extensions;
                require.cache = Module._cache;
                return require;
            }
            Module.prototype._compile = function (content, filename) {
                // remove shebang and create wrapper function
                var scriptSource = Module.wrap(content.replace(/^#!.*/, ''));
                // create script
                var recorder = moduleManager.getRecorder();
                var cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);
                var options = { filename: filename };
                var hashData;
                try {
                    var data = that._fs.readFileSync(cachedDataPath);
                    hashData = data.slice(0, 16);
                    options.cachedData = data.slice(16);
                    recorder.record(60 /* CachedDataFound */, cachedDataPath);
                }
                catch (_e) {
                    recorder.record(61 /* CachedDataMissed */, cachedDataPath);
                }
                var script = new that._vm.Script(scriptSource, options);
                var compileWrapper = script.runInThisContext(options);
                // run script
                var dirname = that._path.dirname(filename);
                var require = makeRequireFunction(this);
                var args = [this.exports, require, this, filename, dirname, process, _commonjsGlobal, Buffer];
                var result = compileWrapper.apply(this.exports, args);
                // cached data aftermath
                that._handleCachedData(script, scriptSource, cachedDataPath, !options.cachedData, moduleManager);
                that._verifyCachedData(script, scriptSource, cachedDataPath, hashData, moduleManager);
                return result;
            };
        };
        NodeScriptLoader.prototype.load = function (moduleManager, scriptSrc, callback, errorback) {
            var _this = this;
            var opts = moduleManager.getConfig().getOptionsLiteral();
            var nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), (opts.nodeRequire || AMDLoader.global.nodeRequire));
            var nodeInstrumenter = (opts.nodeInstrumenter || function (c) { return c; });
            this._init(nodeRequire);
            this._initNodeRequire(nodeRequire, moduleManager);
            var recorder = moduleManager.getRecorder();
            if (/^node\|/.test(scriptSrc)) {
                var pieces = scriptSrc.split('|');
                var moduleExports_3 = null;
                try {
                    moduleExports_3 = nodeRequire(pieces[1]);
                }
                catch (err) {
                    errorback(err);
                    return;
                }
                moduleManager.enqueueDefineAnonymousModule([], function () { return moduleExports_3; });
                callback();
            }
            else {
                scriptSrc = AMDLoader.Utilities.fileUriToFilePath(this._env.isWindows, scriptSrc);
                var normalizedScriptSrc_1 = this._path.normalize(scriptSrc);
                var vmScriptPathOrUri_1 = this._getElectronRendererScriptPathOrUri(normalizedScriptSrc_1);
                var wantsCachedData_1 = Boolean(opts.nodeCachedData);
                var cachedDataPath_1 = wantsCachedData_1 ? this._getCachedDataPath(opts.nodeCachedData, scriptSrc) : undefined;
                this._readSourceAndCachedData(normalizedScriptSrc_1, cachedDataPath_1, recorder, function (err, data, cachedData, hashData) {
                    if (err) {
                        errorback(err);
                        return;
                    }
                    var scriptSource;
                    if (data.charCodeAt(0) === NodeScriptLoader._BOM) {
                        scriptSource = NodeScriptLoader._PREFIX + data.substring(1) + NodeScriptLoader._SUFFIX;
                    }
                    else {
                        scriptSource = NodeScriptLoader._PREFIX + data + NodeScriptLoader._SUFFIX;
                    }
                    scriptSource = nodeInstrumenter(scriptSource, normalizedScriptSrc_1);
                    var scriptOpts = { filename: vmScriptPathOrUri_1, cachedData: cachedData };
                    var script = _this._createAndEvalScript(moduleManager, scriptSource, scriptOpts, callback, errorback);
                    _this._handleCachedData(script, scriptSource, cachedDataPath_1, wantsCachedData_1 && !cachedData, moduleManager);
                    _this._verifyCachedData(script, scriptSource, cachedDataPath_1, hashData, moduleManager);
                });
            }
        };
        NodeScriptLoader.prototype._createAndEvalScript = function (moduleManager, contents, options, callback, errorback) {
            var recorder = moduleManager.getRecorder();
            recorder.record(31 /* NodeBeginEvaluatingScript */, options.filename);
            var script = new this._vm.Script(contents, options);
            var ret = script.runInThisContext(options);
            var globalDefineFunc = moduleManager.getGlobalAMDDefineFunc();
            var receivedDefineCall = false;
            var localDefineFunc = function () {
                receivedDefineCall = true;
                return globalDefineFunc.apply(null, arguments);
            };
            localDefineFunc.amd = globalDefineFunc.amd;
            ret.call(AMDLoader.global, moduleManager.getGlobalAMDRequireFunc(), localDefineFunc, options.filename, this._path.dirname(options.filename));
            recorder.record(32 /* NodeEndEvaluatingScript */, options.filename);
            if (receivedDefineCall) {
                callback();
            }
            else {
                errorback(new Error("Didn't receive define call in " + options.filename + "!"));
            }
            return script;
        };
        NodeScriptLoader.prototype._getElectronRendererScriptPathOrUri = function (path) {
            if (!this._env.isElectronRenderer) {
                return path;
            }
            var driveLetterMatch = path.match(/^([a-z])\:(.*)/i);
            if (driveLetterMatch) {
                // windows
                return "file:///" + (driveLetterMatch[1].toUpperCase() + ':' + driveLetterMatch[2]).replace(/\\/g, '/');
            }
            else {
                // nix
                return "file://" + path;
            }
        };
        NodeScriptLoader.prototype._getCachedDataPath = function (config, filename) {
            var hash = this._crypto.createHash('md5').update(filename, 'utf8').update(config.seed, 'utf8').update(process.arch, '').digest('hex');
            var basename = this._path.basename(filename).replace(/\.js$/, '');
            return this._path.join(config.path, basename + "-" + hash + ".code");
        };
        NodeScriptLoader.prototype._handleCachedData = function (script, scriptSource, cachedDataPath, createCachedData, moduleManager) {
            var _this = this;
            if (script.cachedDataRejected) {
                // cached data got rejected -> delete and re-create
                this._fs.unlink(cachedDataPath, function (err) {
                    moduleManager.getRecorder().record(62 /* CachedDataRejected */, cachedDataPath);
                    _this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);
                    if (err) {
                        moduleManager.getConfig().onError(err);
                    }
                });
            }
            else if (createCachedData) {
                // no cached data, but wanted
                this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);
            }
        };
        // Cached data format: | SOURCE_HASH | V8_CACHED_DATA |
        // -SOURCE_HASH is the md5 hash of the JS source (always 16 bytes)
        // -V8_CACHED_DATA is what v8 produces
        NodeScriptLoader.prototype._createAndWriteCachedData = function (script, scriptSource, cachedDataPath, moduleManager) {
            var _this = this;
            var timeout = Math.ceil(moduleManager.getConfig().getOptionsLiteral().nodeCachedData.writeDelay * (1 + Math.random()));
            var lastSize = -1;
            var iteration = 0;
            var hashData = undefined;
            var createLoop = function () {
                setTimeout(function () {
                    if (!hashData) {
                        hashData = _this._crypto.createHash('md5').update(scriptSource, 'utf8').digest();
                    }
                    var cachedData = script.createCachedData();
                    if (cachedData.length === 0 || cachedData.length === lastSize || iteration >= 5) {
                        // done
                        return;
                    }
                    if (cachedData.length < lastSize) {
                        // less data than before: skip, try again next round
                        createLoop();
                        return;
                    }
                    lastSize = cachedData.length;
                    _this._fs.writeFile(cachedDataPath, Buffer.concat([hashData, cachedData]), function (err) {
                        if (err) {
                            moduleManager.getConfig().onError(err);
                        }
                        moduleManager.getRecorder().record(63 /* CachedDataCreated */, cachedDataPath);
                        createLoop();
                    });
                }, timeout * (Math.pow(4, iteration++)));
            };
            // with some delay (`timeout`) create cached data
            // and repeat that (with backoff delay) until the
            // data seems to be not changing anymore
            createLoop();
        };
        NodeScriptLoader.prototype._readSourceAndCachedData = function (sourcePath, cachedDataPath, recorder, callback) {
            if (!cachedDataPath) {
                // no cached data case
                this._fs.readFile(sourcePath, { encoding: 'utf8' }, callback);
            }
            else {
                // cached data case: read both files in parallel
                var source_1 = undefined;
                var cachedData_1 = undefined;
                var hashData_1 = undefined;
                var steps_1 = 2;
                var step_1 = function (err) {
                    if (err) {
                        callback(err);
                    }
                    else if (--steps_1 === 0) {
                        callback(undefined, source_1, cachedData_1, hashData_1);
                    }
                };
                this._fs.readFile(sourcePath, { encoding: 'utf8' }, function (err, data) {
                    source_1 = data;
                    step_1(err);
                });
                this._fs.readFile(cachedDataPath, function (err, data) {
                    if (!err && data && data.length > 0) {
                        hashData_1 = data.slice(0, 16);
                        cachedData_1 = data.slice(16);
                        recorder.record(60 /* CachedDataFound */, cachedDataPath);
                    }
                    else {
                        recorder.record(61 /* CachedDataMissed */, cachedDataPath);
                    }
                    step_1(); // ignored: cached data is optional
                });
            }
        };
        NodeScriptLoader.prototype._verifyCachedData = function (script, scriptSource, cachedDataPath, hashData, moduleManager) {
            var _this = this;
            if (!hashData) {
                // nothing to do
                return;
            }
            if (script.cachedDataRejected) {
                // invalid anyways
                return;
            }
            setTimeout(function () {
                // check source hash - the contract is that file paths change when file content
                // change (e.g use the commit or version id as cache path). this check is
                // for violations of this contract.
                var hashDataNow = _this._crypto.createHash('md5').update(scriptSource, 'utf8').digest();
                if (!hashData.equals(hashDataNow)) {
                    moduleManager.getConfig().onError(new Error("FAILED TO VERIFY CACHED DATA, deleting stale '" + cachedDataPath + "' now, but a RESTART IS REQUIRED"));
                    _this._fs.unlink(cachedDataPath, function (err) {
                        if (err) {
                            moduleManager.getConfig().onError(err);
                        }
                    });
                }
            }, Math.ceil(5000 * (1 + Math.random())));
        };
        NodeScriptLoader._BOM = 0xFEFF;
        NodeScriptLoader._PREFIX = '(function (require, define, __filename, __dirname) { ';
        NodeScriptLoader._SUFFIX = '\n});';
        return NodeScriptLoader;
    }());
    function ensureRecordedNodeRequire(recorder, _nodeRequire) {
        if (_nodeRequire.__$__isRecorded) {
            // it is already recorded
            return _nodeRequire;
        }
        var nodeRequire = function nodeRequire(what) {
            recorder.record(33 /* NodeBeginNativeRequire */, what);
            try {
                return _nodeRequire(what);
            }
            finally {
                recorder.record(34 /* NodeEndNativeRequire */, what);
            }
        };
        nodeRequire.__$__isRecorded = true;
        return nodeRequire;
    }
    AMDLoader.ensureRecordedNodeRequire = ensureRecordedNodeRequire;
    function createScriptLoader(env) {
        return new OnlyOnceScriptLoader(env);
    }
    AMDLoader.createScriptLoader = createScriptLoader;
})(AMDLoader || (AMDLoader = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var AMDLoader;
(function (AMDLoader) {
    // ------------------------------------------------------------------------
    // ModuleIdResolver
    var ModuleIdResolver = /** @class */ (function () {
        function ModuleIdResolver(fromModuleId) {
            var lastSlash = fromModuleId.lastIndexOf('/');
            if (lastSlash !== -1) {
                this.fromModulePath = fromModuleId.substr(0, lastSlash + 1);
            }
            else {
                this.fromModulePath = '';
            }
        }
        /**
         * Normalize 'a/../name' to 'name', etc.
         */
        ModuleIdResolver._normalizeModuleId = function (moduleId) {
            var r = moduleId, pattern;
            // replace /./ => /
            pattern = /\/\.\//;
            while (pattern.test(r)) {
                r = r.replace(pattern, '/');
            }
            // replace ^./ => nothing
            r = r.replace(/^\.\//g, '');
            // replace /aa/../ => / (BUT IGNORE /../../)
            pattern = /\/(([^\/])|([^\/][^\/\.])|([^\/\.][^\/])|([^\/][^\/][^\/]+))\/\.\.\//;
            while (pattern.test(r)) {
                r = r.replace(pattern, '/');
            }
            // replace ^aa/../ => nothing (BUT IGNORE ../../)
            r = r.replace(/^(([^\/])|([^\/][^\/\.])|([^\/\.][^\/])|([^\/][^\/][^\/]+))\/\.\.\//, '');
            return r;
        };
        /**
         * Resolve relative module ids
         */
        ModuleIdResolver.prototype.resolveModule = function (moduleId) {
            var result = moduleId;
            if (!AMDLoader.Utilities.isAbsolutePath(result)) {
                if (AMDLoader.Utilities.startsWith(result, './') || AMDLoader.Utilities.startsWith(result, '../')) {
                    result = ModuleIdResolver._normalizeModuleId(this.fromModulePath + result);
                }
            }
            return result;
        };
        ModuleIdResolver.ROOT = new ModuleIdResolver('');
        return ModuleIdResolver;
    }());
    AMDLoader.ModuleIdResolver = ModuleIdResolver;
    // ------------------------------------------------------------------------
    // Module
    var Module = /** @class */ (function () {
        function Module(id, strId, dependencies, callback, errorback, moduleIdResolver) {
            this.id = id;
            this.strId = strId;
            this.dependencies = dependencies;
            this._callback = callback;
            this._errorback = errorback;
            this.moduleIdResolver = moduleIdResolver;
            this.exports = {};
            this.error = null;
            this.exportsPassedIn = false;
            this.unresolvedDependenciesCount = this.dependencies.length;
            this._isComplete = false;
        }
        Module._safeInvokeFunction = function (callback, args) {
            try {
                return {
                    returnedValue: callback.apply(AMDLoader.global, args),
                    producedError: null
                };
            }
            catch (e) {
                return {
                    returnedValue: null,
                    producedError: e
                };
            }
        };
        Module._invokeFactory = function (config, strModuleId, callback, dependenciesValues) {
            if (config.isBuild() && !AMDLoader.Utilities.isAnonymousModule(strModuleId)) {
                return {
                    returnedValue: null,
                    producedError: null
                };
            }
            if (config.shouldCatchError()) {
                return this._safeInvokeFunction(callback, dependenciesValues);
            }
            return {
                returnedValue: callback.apply(AMDLoader.global, dependenciesValues),
                producedError: null
            };
        };
        Module.prototype.complete = function (recorder, config, dependenciesValues) {
            this._isComplete = true;
            var producedError = null;
            if (this._callback) {
                if (typeof this._callback === 'function') {
                    recorder.record(21 /* BeginInvokeFactory */, this.strId);
                    var r = Module._invokeFactory(config, this.strId, this._callback, dependenciesValues);
                    producedError = r.producedError;
                    recorder.record(22 /* EndInvokeFactory */, this.strId);
                    if (!producedError && typeof r.returnedValue !== 'undefined' && (!this.exportsPassedIn || AMDLoader.Utilities.isEmpty(this.exports))) {
                        this.exports = r.returnedValue;
                    }
                }
                else {
                    this.exports = this._callback;
                }
            }
            if (producedError) {
                var err = AMDLoader.ensureError(producedError);
                err.phase = 'factory';
                err.moduleId = this.strId;
                this.error = err;
                config.onError(err);
            }
            this.dependencies = null;
            this._callback = null;
            this._errorback = null;
            this.moduleIdResolver = null;
        };
        /**
         * One of the direct dependencies or a transitive dependency has failed to load.
         */
        Module.prototype.onDependencyError = function (err) {
            this._isComplete = true;
            this.error = err;
            if (this._errorback) {
                this._errorback(err);
                return true;
            }
            return false;
        };
        /**
         * Is the current module complete?
         */
        Module.prototype.isComplete = function () {
            return this._isComplete;
        };
        return Module;
    }());
    AMDLoader.Module = Module;
    var ModuleIdProvider = /** @class */ (function () {
        function ModuleIdProvider() {
            this._nextId = 0;
            this._strModuleIdToIntModuleId = new Map();
            this._intModuleIdToStrModuleId = [];
            // Ensure values 0, 1, 2 are assigned accordingly with ModuleId
            this.getModuleId('exports');
            this.getModuleId('module');
            this.getModuleId('require');
        }
        ModuleIdProvider.prototype.getMaxModuleId = function () {
            return this._nextId;
        };
        ModuleIdProvider.prototype.getModuleId = function (strModuleId) {
            var id = this._strModuleIdToIntModuleId.get(strModuleId);
            if (typeof id === 'undefined') {
                id = this._nextId++;
                this._strModuleIdToIntModuleId.set(strModuleId, id);
                this._intModuleIdToStrModuleId[id] = strModuleId;
            }
            return id;
        };
        ModuleIdProvider.prototype.getStrModuleId = function (moduleId) {
            return this._intModuleIdToStrModuleId[moduleId];
        };
        return ModuleIdProvider;
    }());
    var RegularDependency = /** @class */ (function () {
        function RegularDependency(id) {
            this.id = id;
        }
        RegularDependency.EXPORTS = new RegularDependency(0 /* EXPORTS */);
        RegularDependency.MODULE = new RegularDependency(1 /* MODULE */);
        RegularDependency.REQUIRE = new RegularDependency(2 /* REQUIRE */);
        return RegularDependency;
    }());
    AMDLoader.RegularDependency = RegularDependency;
    var PluginDependency = /** @class */ (function () {
        function PluginDependency(id, pluginId, pluginParam) {
            this.id = id;
            this.pluginId = pluginId;
            this.pluginParam = pluginParam;
        }
        return PluginDependency;
    }());
    AMDLoader.PluginDependency = PluginDependency;
    var ModuleManager = /** @class */ (function () {
        function ModuleManager(env, scriptLoader, defineFunc, requireFunc, loaderAvailableTimestamp) {
            if (loaderAvailableTimestamp === void 0) { loaderAvailableTimestamp = 0; }
            this._env = env;
            this._scriptLoader = scriptLoader;
            this._loaderAvailableTimestamp = loaderAvailableTimestamp;
            this._defineFunc = defineFunc;
            this._requireFunc = requireFunc;
            this._moduleIdProvider = new ModuleIdProvider();
            this._config = new AMDLoader.Configuration(this._env);
            this._hasDependencyCycle = false;
            this._modules2 = [];
            this._knownModules2 = [];
            this._inverseDependencies2 = [];
            this._inversePluginDependencies2 = new Map();
            this._currentAnonymousDefineCall = null;
            this._recorder = null;
            this._buildInfoPath = [];
            this._buildInfoDefineStack = [];
            this._buildInfoDependencies = [];
        }
        ModuleManager.prototype.reset = function () {
            return new ModuleManager(this._env, this._scriptLoader, this._defineFunc, this._requireFunc, this._loaderAvailableTimestamp);
        };
        ModuleManager.prototype.getGlobalAMDDefineFunc = function () {
            return this._defineFunc;
        };
        ModuleManager.prototype.getGlobalAMDRequireFunc = function () {
            return this._requireFunc;
        };
        ModuleManager._findRelevantLocationInStack = function (needle, stack) {
            var normalize = function (str) { return str.replace(/\\/g, '/'); };
            var normalizedPath = normalize(needle);
            var stackPieces = stack.split(/\n/);
            for (var i = 0; i < stackPieces.length; i++) {
                var m = stackPieces[i].match(/(.*):(\d+):(\d+)\)?$/);
                if (m) {
                    var stackPath = m[1];
                    var stackLine = m[2];
                    var stackColumn = m[3];
                    var trimPathOffset = Math.max(stackPath.lastIndexOf(' ') + 1, stackPath.lastIndexOf('(') + 1);
                    stackPath = stackPath.substr(trimPathOffset);
                    stackPath = normalize(stackPath);
                    if (stackPath === normalizedPath) {
                        var r = {
                            line: parseInt(stackLine, 10),
                            col: parseInt(stackColumn, 10)
                        };
                        if (r.line === 1) {
                            r.col -= '(function (require, define, __filename, __dirname) { '.length;
                        }
                        return r;
                    }
                }
            }
            throw new Error('Could not correlate define call site for needle ' + needle);
        };
        ModuleManager.prototype.getBuildInfo = function () {
            if (!this._config.isBuild()) {
                return null;
            }
            var result = [], resultLen = 0;
            for (var i = 0, len = this._modules2.length; i < len; i++) {
                var m = this._modules2[i];
                if (!m) {
                    continue;
                }
                var location_1 = this._buildInfoPath[m.id] || null;
                var defineStack = this._buildInfoDefineStack[m.id] || null;
                var dependencies = this._buildInfoDependencies[m.id];
                result[resultLen++] = {
                    id: m.strId,
                    path: location_1,
                    defineLocation: (location_1 && defineStack ? ModuleManager._findRelevantLocationInStack(location_1, defineStack) : null),
                    dependencies: dependencies,
                    shim: null,
                    exports: m.exports
                };
            }
            return result;
        };
        ModuleManager.prototype.getRecorder = function () {
            if (!this._recorder) {
                if (this._config.shouldRecordStats()) {
                    this._recorder = new AMDLoader.LoaderEventRecorder(this._loaderAvailableTimestamp);
                }
                else {
                    this._recorder = AMDLoader.NullLoaderEventRecorder.INSTANCE;
                }
            }
            return this._recorder;
        };
        ModuleManager.prototype.getLoaderEvents = function () {
            return this.getRecorder().getEvents();
        };
        /**
         * Defines an anonymous module (without an id). Its name will be resolved as we receive a callback from the scriptLoader.
         * @param dependencies @see defineModule
         * @param callback @see defineModule
         */
        ModuleManager.prototype.enqueueDefineAnonymousModule = function (dependencies, callback) {
            if (this._currentAnonymousDefineCall !== null) {
                throw new Error('Can only have one anonymous define call per script file');
            }
            var stack = null;
            if (this._config.isBuild()) {
                stack = new Error('StackLocation').stack || null;
            }
            this._currentAnonymousDefineCall = {
                stack: stack,
                dependencies: dependencies,
                callback: callback
            };
        };
        /**
         * Creates a module and stores it in _modules. The manager will immediately begin resolving its dependencies.
         * @param strModuleId An unique and absolute id of the module. This must not collide with another module's id
         * @param dependencies An array with the dependencies of the module. Special keys are: "require", "exports" and "module"
         * @param callback if callback is a function, it will be called with the resolved dependencies. if callback is an object, it will be considered as the exports of the module.
         */
        ModuleManager.prototype.defineModule = function (strModuleId, dependencies, callback, errorback, stack, moduleIdResolver) {
            var _this = this;
            if (moduleIdResolver === void 0) { moduleIdResolver = new ModuleIdResolver(strModuleId); }
            var moduleId = this._moduleIdProvider.getModuleId(strModuleId);
            // if (this._modules2[moduleId]) {
            //     if (!this._config.isDuplicateMessageIgnoredFor(strModuleId)) {
            //         console.warn('Duplicate definition of module \'' + strModuleId + '\'');
            //     }
            //     // Super important! Completely ignore duplicate module definition
            //     return;
            // }
            var m = new Module(moduleId, strModuleId, this._normalizeDependencies(dependencies, moduleIdResolver), callback, errorback, moduleIdResolver);
            this._modules2[moduleId] = m;
            if (this._config.isBuild()) {
                this._buildInfoDefineStack[moduleId] = stack;
                this._buildInfoDependencies[moduleId] = (m.dependencies || []).map(function (dep) { return _this._moduleIdProvider.getStrModuleId(dep.id); });
            }
            // Resolving of dependencies is immediate (not in a timeout). If there's a need to support a packer that concatenates in an
            // unordered manner, in order to finish processing the file, execute the following method in a timeout
            _currentDefineModule = m.exports;
            this._resolve(m);
        };
        ModuleManager.prototype._normalizeDependency = function (dependency, moduleIdResolver) {
            if (dependency === 'exports') {
                return RegularDependency.EXPORTS;
            }
            if (dependency === 'module') {
                return RegularDependency.MODULE;
            }
            if (dependency === 'require') {
                return RegularDependency.REQUIRE;
            }
            // Normalize dependency and then request it from the manager
            var bangIndex = dependency.indexOf('!');
            if (bangIndex >= 0) {
                var strPluginId = moduleIdResolver.resolveModule(dependency.substr(0, bangIndex));
                var pluginParam = moduleIdResolver.resolveModule(dependency.substr(bangIndex + 1));
                var dependencyId = this._moduleIdProvider.getModuleId(strPluginId + '!' + pluginParam);
                var pluginId = this._moduleIdProvider.getModuleId(strPluginId);
                return new PluginDependency(dependencyId, pluginId, pluginParam);
            }
            return new RegularDependency(this._moduleIdProvider.getModuleId(moduleIdResolver.resolveModule(dependency)));
        };
        ModuleManager.prototype._normalizeDependencies = function (dependencies, moduleIdResolver) {
            var result = [], resultLen = 0;
            for (var i = 0, len = dependencies.length; i < len; i++) {
                result[resultLen++] = this._normalizeDependency(dependencies[i], moduleIdResolver);
            }
            return result;
        };
        ModuleManager.prototype._relativeRequire = function (moduleIdResolver, dependencies, callback, errorback) {
            if (typeof dependencies === 'string') {
                return this.synchronousRequire(dependencies, moduleIdResolver);
            }
            this.defineModule(AMDLoader.Utilities.generateAnonymousModule(), dependencies, callback, errorback, null, moduleIdResolver);
        };
        /**
         * Require synchronously a module by its absolute id. If the module is not loaded, an exception will be thrown.
         * @param id The unique and absolute id of the required module
         * @return The exports of module 'id'
         */
        ModuleManager.prototype.synchronousRequire = function (_strModuleId, moduleIdResolver) {
            if (moduleIdResolver === void 0) { moduleIdResolver = new ModuleIdResolver(_strModuleId); }
            var dependency = this._normalizeDependency(_strModuleId, moduleIdResolver);
            var m = this._modules2[dependency.id];
            if (!m) {
                throw new Error('Check dependency list! Synchronous require cannot resolve module \'' + _strModuleId + '\'. This is the first mention of this module!');
            }
            if (!m.isComplete()) {
                throw new Error('Check dependency list! Synchronous require cannot resolve module \'' + _strModuleId + '\'. This module has not been resolved completely yet.');
            }
            if (m.error) {
                throw m.error;
            }
            return m.exports;
        };
        ModuleManager.prototype.configure = function (params, shouldOverwrite) {
            var oldShouldRecordStats = this._config.shouldRecordStats();
            if (shouldOverwrite) {
                this._config = new AMDLoader.Configuration(this._env, params);
            }
            else {
                this._config = this._config.cloneAndMerge(params);
            }
            if (this._config.shouldRecordStats() && !oldShouldRecordStats) {
                this._recorder = null;
            }
        };
        ModuleManager.prototype.getConfig = function () {
            return this._config;
        };
        /**
         * Callback from the scriptLoader when a module has been loaded.
         * This means its code is available and has been executed.
         */
        ModuleManager.prototype._onLoad = function (moduleId) {
            if (this._currentAnonymousDefineCall !== null) {
                var defineCall = this._currentAnonymousDefineCall;
                this._currentAnonymousDefineCall = null;
                // Hit an anonymous define call
                this.defineModule(this._moduleIdProvider.getStrModuleId(moduleId), defineCall.dependencies, defineCall.callback, null, defineCall.stack);
            }
        };
        ModuleManager.prototype._createLoadError = function (moduleId, _err) {
            var _this = this;
            var strModuleId = this._moduleIdProvider.getStrModuleId(moduleId);
            var neededBy = (this._inverseDependencies2[moduleId] || []).map(function (intModuleId) { return _this._moduleIdProvider.getStrModuleId(intModuleId); });
            var err = AMDLoader.ensureError(_err);
            err.phase = 'loading';
            err.moduleId = strModuleId;
            err.neededBy = neededBy;
            return err;
        };
        /**
         * Callback from the scriptLoader when a module hasn't been loaded.
         * This means that the script was not found (e.g. 404) or there was an error in the script.
         */
        ModuleManager.prototype._onLoadError = function (moduleId, err) {
            var error = this._createLoadError(moduleId, err);
            if (!this._modules2[moduleId]) {
                this._modules2[moduleId] = new Module(moduleId, this._moduleIdProvider.getStrModuleId(moduleId), [], function () { }, null, null);
            }
            // Find any 'local' error handlers, walk the entire chain of inverse dependencies if necessary.
            var seenModuleId = [];
            for (var i = 0, len = this._moduleIdProvider.getMaxModuleId(); i < len; i++) {
                seenModuleId[i] = false;
            }
            var someoneNotified = false;
            var queue = [];
            queue.push(moduleId);
            seenModuleId[moduleId] = true;
            while (queue.length > 0) {
                var queueElement = queue.shift();
                var m = this._modules2[queueElement];
                if (m) {
                    someoneNotified = m.onDependencyError(error) || someoneNotified;
                }
                var inverseDeps = this._inverseDependencies2[queueElement];
                if (inverseDeps) {
                    for (var i = 0, len = inverseDeps.length; i < len; i++) {
                        var inverseDep = inverseDeps[i];
                        if (!seenModuleId[inverseDep]) {
                            queue.push(inverseDep);
                            seenModuleId[inverseDep] = true;
                        }
                    }
                }
            }
            if (!someoneNotified) {
                this._config.onError(error);
            }
        };
        /**
         * Walks (recursively) the dependencies of 'from' in search of 'to'.
         * Returns true if there is such a path or false otherwise.
         * @param from Module id to start at
         * @param to Module id to look for
         */
        ModuleManager.prototype._hasDependencyPath = function (fromId, toId) {
            var from = this._modules2[fromId];
            if (!from) {
                return false;
            }
            var inQueue = [];
            for (var i = 0, len = this._moduleIdProvider.getMaxModuleId(); i < len; i++) {
                inQueue[i] = false;
            }
            var queue = [];
            // Insert 'from' in queue
            queue.push(from);
            inQueue[fromId] = true;
            while (queue.length > 0) {
                // Pop first inserted element of queue
                var element = queue.shift();
                var dependencies = element.dependencies;
                if (dependencies) {
                    // Walk the element's dependencies
                    for (var i = 0, len = dependencies.length; i < len; i++) {
                        var dependency = dependencies[i];
                        if (dependency.id === toId) {
                            // There is a path to 'to'
                            return true;
                        }
                        var dependencyModule = this._modules2[dependency.id];
                        if (dependencyModule && !inQueue[dependency.id]) {
                            // Insert 'dependency' in queue
                            inQueue[dependency.id] = true;
                            queue.push(dependencyModule);
                        }
                    }
                }
            }
            // There is no path to 'to'
            return false;
        };
        /**
         * Walks (recursively) the dependencies of 'from' in search of 'to'.
         * Returns cycle as array.
         * @param from Module id to start at
         * @param to Module id to look for
         */
        ModuleManager.prototype._findCyclePath = function (fromId, toId, depth) {
            if (fromId === toId || depth === 50) {
                return [fromId];
            }
            var from = this._modules2[fromId];
            if (!from) {
                return null;
            }
            // Walk the element's dependencies
            var dependencies = from.dependencies;
            if (dependencies) {
                for (var i = 0, len = dependencies.length; i < len; i++) {
                    var path = this._findCyclePath(dependencies[i].id, toId, depth + 1);
                    if (path !== null) {
                        path.push(fromId);
                        return path;
                    }
                }
            }
            return null;
        };
        /**
         * Create the local 'require' that is passed into modules
         */
        ModuleManager.prototype._createRequire = function (moduleIdResolver) {
            var _this = this;
            var result = (function (dependencies, callback, errorback) {
                return _this._relativeRequire(moduleIdResolver, dependencies, callback, errorback);
            });
            result.toUrl = function (id) {
                return _this._config.requireToUrl(moduleIdResolver.resolveModule(id));
            };
            result.getStats = function () {
                return _this.getLoaderEvents();
            };
            result.hasDependencyCycle = function () {
                return _this._hasDependencyCycle;
            };
            result.config = function (params, shouldOverwrite) {
                if (shouldOverwrite === void 0) { shouldOverwrite = false; }
                _this.configure(params, shouldOverwrite);
            };
            result.__$__nodeRequire = AMDLoader.global.nodeRequire;
            return result;
        };
        ModuleManager.prototype._loadModule = function (moduleId) {
            var _this = this;
            if (this._modules2[moduleId] || this._knownModules2[moduleId]) {
                // known module
                return;
            }
            this._knownModules2[moduleId] = true;
            var strModuleId = this._moduleIdProvider.getStrModuleId(moduleId);
            var paths = this._config.moduleIdToPaths(strModuleId);
            var scopedPackageRegex = /^@[^\/]+\/[^\/]+$/; // matches @scope/package-name
            if (this._env.isNode && (strModuleId.indexOf('/') === -1 || scopedPackageRegex.test(strModuleId))) {
                paths.push('node|' + strModuleId);
            }
            var lastPathIndex = -1;
            var loadNextPath = function (err) {
                lastPathIndex++;
                if (lastPathIndex >= paths.length) {
                    // No more paths to try
                    _this._onLoadError(moduleId, err);
                }
                else {
                    var currentPath_1 = paths[lastPathIndex];
                    var recorder_1 = _this.getRecorder();
                    if (_this._config.isBuild() && currentPath_1 === 'empty:') {
                        _this._buildInfoPath[moduleId] = currentPath_1;
                        _this.defineModule(_this._moduleIdProvider.getStrModuleId(moduleId), [], null, null, null);
                        _this._onLoad(moduleId);
                        return;
                    }
                    recorder_1.record(10 /* BeginLoadingScript */, currentPath_1);
                    _this._scriptLoader.load(_this, currentPath_1, function () {
                        if (_this._config.isBuild()) {
                            _this._buildInfoPath[moduleId] = currentPath_1;
                        }
                        recorder_1.record(11 /* EndLoadingScriptOK */, currentPath_1);
                        _this._onLoad(moduleId);
                    }, function (err) {
                        recorder_1.record(12 /* EndLoadingScriptError */, currentPath_1);
                        loadNextPath(err);
                    });
                }
            };
            loadNextPath(null);
        };
        /**
         * Resolve a plugin dependency with the plugin loaded & complete
         * @param module The module that has this dependency
         * @param pluginDependency The semi-normalized dependency that appears in the module. e.g. 'vs/css!./mycssfile'. Only the plugin part (before !) is normalized
         * @param plugin The plugin (what the plugin exports)
         */
        ModuleManager.prototype._loadPluginDependency = function (plugin, pluginDependency) {
            var _this = this;
            if (this._modules2[pluginDependency.id] || this._knownModules2[pluginDependency.id]) {
                // known module
                return;
            }
            this._knownModules2[pluginDependency.id] = true;
            // Delegate the loading of the resource to the plugin
            var load = (function (value) {
                _this.defineModule(_this._moduleIdProvider.getStrModuleId(pluginDependency.id), [], value, null, null);
            });
            load.error = function (err) {
                _this._config.onError(_this._createLoadError(pluginDependency.id, err));
            };
            plugin.load(pluginDependency.pluginParam, this._createRequire(ModuleIdResolver.ROOT), load, this._config.getOptionsLiteral());
        };
        /**
         * Examine the dependencies of module 'module' and resolve them as needed.
         */
        ModuleManager.prototype._resolve = function (module) {
            var _this = this;
            var dependencies = module.dependencies;
            if (dependencies) {
                for (var i = 0, len = dependencies.length; i < len; i++) {
                    var dependency = dependencies[i];
                    if (dependency === RegularDependency.EXPORTS) {
                        module.exportsPassedIn = true;
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    if (dependency === RegularDependency.MODULE) {
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    if (dependency === RegularDependency.REQUIRE) {
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    var dependencyModule = this._modules2[dependency.id];
                    if (dependencyModule && dependencyModule.isComplete()) {
                        if (dependencyModule.error) {
                            module.onDependencyError(dependencyModule.error);
                            return;
                        }
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    if (this._hasDependencyPath(dependency.id, module.id)) {
                        this._hasDependencyCycle = true;
                        console.warn('There is a dependency cycle between \'' + this._moduleIdProvider.getStrModuleId(dependency.id) + '\' and \'' + this._moduleIdProvider.getStrModuleId(module.id) + '\'. The cyclic path follows:');
                        var cyclePath = this._findCyclePath(dependency.id, module.id, 0) || [];
                        cyclePath.reverse();
                        cyclePath.push(dependency.id);
                        console.warn(cyclePath.map(function (id) { return _this._moduleIdProvider.getStrModuleId(id); }).join(' => \n'));
                        // Break the cycle
                        module.unresolvedDependenciesCount--;
                        continue;
                    }
                    // record inverse dependency
                    this._inverseDependencies2[dependency.id] = this._inverseDependencies2[dependency.id] || [];
                    this._inverseDependencies2[dependency.id].push(module.id);
                    if (dependency instanceof PluginDependency) {
                        var plugin = this._modules2[dependency.pluginId];
                        if (plugin && plugin.isComplete()) {
                            this._loadPluginDependency(plugin.exports, dependency);
                            continue;
                        }
                        // Record dependency for when the plugin gets loaded
                        var inversePluginDeps = this._inversePluginDependencies2.get(dependency.pluginId);
                        if (!inversePluginDeps) {
                            inversePluginDeps = [];
                            this._inversePluginDependencies2.set(dependency.pluginId, inversePluginDeps);
                        }
                        inversePluginDeps.push(dependency);
                        this._loadModule(dependency.pluginId);
                        continue;
                    }
                    this._loadModule(dependency.id);
                }
            }
            if (module.unresolvedDependenciesCount === 0) {
                this._onModuleComplete(module);
            }
        };
        ModuleManager.prototype._onModuleComplete = function (module) {
            var _this = this;
            var recorder = this.getRecorder();
            if (module.isComplete()) {
                // already done
                return;
            }
            var dependencies = module.dependencies;
            var dependenciesValues = [];
            if (dependencies) {
                for (var i = 0, len = dependencies.length; i < len; i++) {
                    var dependency = dependencies[i];
                    if (dependency === RegularDependency.EXPORTS) {
                        dependenciesValues[i] = module.exports;
                        continue;
                    }
                    if (dependency === RegularDependency.MODULE) {
                        dependenciesValues[i] = {
                            id: module.strId,
                            config: function () {
                                return _this._config.getConfigForModule(module.strId);
                            }
                        };
                        continue;
                    }
                    if (dependency === RegularDependency.REQUIRE) {
                        dependenciesValues[i] = this._createRequire(module.moduleIdResolver);
                        continue;
                    }
                    var dependencyModule = this._modules2[dependency.id];
                    if (dependencyModule) {
                        dependenciesValues[i] = dependencyModule.exports;
                        continue;
                    }
                    dependenciesValues[i] = null;
                }
            }
            module.complete(recorder, this._config, dependenciesValues);
            // Fetch and clear inverse dependencies
            var inverseDeps = this._inverseDependencies2[module.id];
            this._inverseDependencies2[module.id] = null;
            if (inverseDeps) {
                // Resolve one inverse dependency at a time, always
                // on the lookout for a completed module.
                for (var i = 0, len = inverseDeps.length; i < len; i++) {
                    var inverseDependencyId = inverseDeps[i];
                    var inverseDependency = this._modules2[inverseDependencyId];
                    inverseDependency.unresolvedDependenciesCount--;
                    if (inverseDependency.unresolvedDependenciesCount === 0) {
                        this._onModuleComplete(inverseDependency);
                    }
                }
            }
            var inversePluginDeps = this._inversePluginDependencies2.get(module.id);
            if (inversePluginDeps) {
                // This module is used as a plugin at least once
                // Fetch and clear these inverse plugin dependencies
                this._inversePluginDependencies2.delete(module.id);
                // Resolve plugin dependencies one at a time
                for (var i = 0, len = inversePluginDeps.length; i < len; i++) {
                    this._loadPluginDependency(module.exports, inversePluginDeps[i]);
                }
            }
        };
        return ModuleManager;
    }());
    AMDLoader.ModuleManager = ModuleManager;
})(AMDLoader || (AMDLoader = {}));
var define;
var AMDLoader;
(function (AMDLoader) {
    var env = new AMDLoader.Environment();
    var moduleManager = null;
    var DefineFunc = function (id, dependencies, callback) {
        if (typeof id !== 'string') {
            callback = dependencies;
            dependencies = id;
            id = null;
        }
        if (typeof dependencies !== 'object' || !Array.isArray(dependencies)) {
            callback = dependencies;
            dependencies = null;
        }
        if (!dependencies) {
            dependencies = ['require', 'exports', 'module'];
        }
        if (id) {
            moduleManager.defineModule(id, dependencies, callback, null, null);
        }
        else {
            moduleManager.enqueueDefineAnonymousModule(dependencies, callback);
        }
    };
    DefineFunc.amd = true;
    var _requireFunc_config = function (params, shouldOverwrite) {
        if (shouldOverwrite === void 0) { shouldOverwrite = false; }
        moduleManager.configure(params, shouldOverwrite);
    };
    var RequireFunc = function () {
        if (arguments.length === 1) {
            if ((arguments[0] instanceof Object) && !Array.isArray(arguments[0])) {
                _requireFunc_config(arguments[0]);
                return;
            }
            if (typeof arguments[0] === 'string') {
                return moduleManager.synchronousRequire(arguments[0]);
            }
        }
        if (arguments.length === 2 || arguments.length === 3) {
            if (Array.isArray(arguments[0])) {
                moduleManager.defineModule(AMDLoader.Utilities.generateAnonymousModule(), arguments[0], arguments[1], arguments[2], null);
                return;
            }
        }
        throw new Error('Unrecognized require call');
    };
    RequireFunc.config = _requireFunc_config;
    RequireFunc.getConfig = function () {
        return moduleManager.getConfig().getOptionsLiteral();
    };
    RequireFunc.reset = function () {
        moduleManager = moduleManager.reset();
    };
    RequireFunc.getBuildInfo = function () {
        return moduleManager.getBuildInfo();
    };
    RequireFunc.getStats = function () {
        return moduleManager.getLoaderEvents();
    };
    RequireFunc.define = DefineFunc;
    RequireFunc.defined = function(module){
        let moduleId = moduleManager._moduleIdProvider.getModuleId(module);
        if (moduleManager._modules2[moduleId])
            return true;
        return false;
    };
    function init() {
        if (typeof AMDLoader.global.require !== 'undefined' || typeof require !== 'undefined') {
            var _nodeRequire = (AMDLoader.global.require || require);
            if (typeof _nodeRequire === 'function' && typeof _nodeRequire.resolve === 'function') {
                // re-expose node's require function
                var nodeRequire = AMDLoader.ensureRecordedNodeRequire(moduleManager.getRecorder(), _nodeRequire);
                AMDLoader.global.nodeRequire = nodeRequire;
                RequireFunc.nodeRequire = nodeRequire;
                RequireFunc.__$__nodeRequire = nodeRequire;
            }
        }
        if (env.isNode && !env.isElectronRenderer && !env.isElectronNodeIntegrationWebWorker) {
            module.exports = RequireFunc;
            require = RequireFunc;
        }
        else {
            if (!env.isElectronRenderer) {
                AMDLoader.global.define = DefineFunc;
            }
            AMDLoader.global.require = RequireFunc;
        }
    }
    AMDLoader.init = init;
    if (typeof AMDLoader.global.define !== 'function' || !AMDLoader.global.define.amd) {
        moduleManager = new AMDLoader.ModuleManager(env, AMDLoader.createScriptLoader(env), DefineFunc, RequireFunc, AMDLoader.Utilities.getHighPerformanceTimestamp());
        // The global variable require can configure the loader
        if (typeof AMDLoader.global.require !== 'undefined' && typeof AMDLoader.global.require !== 'function') {
            RequireFunc.config(AMDLoader.global.require);
        }
        // This define is for the local closure defined in node in the case that the loader is concatenated
        define = function () {
            return DefineFunc.apply(null, arguments);
        };
        define.amd = DefineFunc.amd;
        if (typeof doNotInitLoader === 'undefined') {
            init();
        }
    }
})(AMDLoader || (AMDLoader = {}));

define("base64-js", ()=>{});
define("ieee754", ()=>{});
define("buffer", (require,exports)=>{
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

const base64 = require('base64-js')
const ieee754 = require('ieee754')
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}

});
/*!-----------------------------------------------------------
* Copyright (c) IJS Technologies. All rights reserved.
* Released under dual AGPLv3/commercial license
* https://ijs.network
*-----------------------------------------------------------*/

; (function (globalObject) {
  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multiformats/blob/master/LICENSE-MIT
  *--------------------------------------------------------------------------------------------*/
  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/hashes/digest.js#L66

  class Digest {
    constructor(code, size, digest, bytes) {
      this.code = code;
      this.size = size;
      this.digest = digest;
      this.bytes = bytes;
    }
  }

  const readonly = { writable: false, configurable: false, enumerable: true }
  const hidden = { writable: false, enumerable: false, configurable: false }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L78
  class Decoder {

    constructor(name, prefix, baseDecode) {
      this.name = name
      this.prefix = prefix
      this.baseDecode = baseDecode
    }

    decode(text) {
      if (typeof text === 'string') {
        switch (text[0]) {
          case this.prefix: {
            return this.baseDecode(text.slice(1))
          }
          default: {
            throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)
          }
        }
      } else {
        throw Error('Can only multibase decode strings')
      }
    }

    or(decoder) {
      return or(this, decoder)
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L29
  class Encoder {

    constructor(name, prefix, baseEncode) {
      this.name = name
      this.prefix = prefix
      this.baseEncode = baseEncode
    }

    encode(bytes) {
      if (bytes instanceof Uint8Array) {
        return `${this.prefix}${this.baseEncode(bytes)}`
      } else {
        throw Error('Unknown type, must be binary type')
      }
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L195
  class Codec {

    constructor(name, prefix, baseEncode, baseDecode) {
      this.name = name
      this.prefix = prefix
      this.baseEncode = baseEncode
      this.baseDecode = baseDecode
      this.encoder = new Encoder(name, prefix, baseEncode)
      this.decoder = new Decoder(name, prefix, baseDecode)
    }

    encode(input) {
      return this.encoder.encode(input)
    }

    decode(input) {
      return this.decoder.decode(input)
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L236
  const from_1 = ({ name, prefix, encode, decode }) =>
    new Codec(name, prefix, encode, decode)

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/base-x.js#L6
  function _basex(ALPHABET, name) {
    if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    function encode(source) {
      if (source instanceof Uint8Array); else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from_1(source);
      }
      if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }
      if (source.length === 0) { return '' }
      // Skip & count leading zeroes.
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      // Allocate enough space in big-endian base58 representation.
      var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
      var b58 = new Uint8Array(size);
      // Process the bytes.
      while (pbegin !== pend) {
        var carry = source[pbegin];
        // Apply "b58 = b58 * 256 + ch".
        var i = 0;
        for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
          carry += (256 * b58[it1]) >>> 0;
          b58[it1] = (carry % BASE) >>> 0;
          carry = (carry / BASE) >>> 0;
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i;
        pbegin++;
      }
      // Skip leading zeroes in base58 result.
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      // Translate the result into a string.
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
      return str
    }
    function decodeUnsafe(source) {
      if (typeof source !== 'string') { throw new TypeError('Expected String') }
      if (source.length === 0) { return new Uint8Array() }
      var psz = 0;
      // Skip leading spaces.
      if (source[psz] === ' ') { return }
      // Skip and count leading '1's.
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      // Allocate enough space in big-endian base256 representation.
      var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.
      var b256 = new Uint8Array(size);
      // Process the characters.
      while (source[psz]) {
        // Decode character
        var carry = BASE_MAP[source.charCodeAt(psz)];
        // Invalid character
        if (carry === 255) { return }
        var i = 0;
        for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
          carry += (BASE * b256[it3]) >>> 0;
          b256[it3] = (carry % 256) >>> 0;
          carry = (carry / 256) >>> 0;
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i;
        psz++;
      }
      // Skip trailing spaces.
      if (source[psz] === ' ') { return }
      // Skip leading zeroes in b256.
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j = zeroes;
      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }
      return vch
    }
    function decode(string) {
      var buffer = decodeUnsafe(string);
      if (buffer) { return buffer }
      throw new Error(`Non-${name} character`)
    }
    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L248
  const baseX = ({ prefix, name, alphabet }) => {
    const { encode, decode } = _basex(alphabet, name)
    return from_1({
      prefix,
      name,
      encode,
      decode: text => coerce(decode(text))
    })
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L321
  const _encode = (data, alphabet, bitsPerChar) => {
    const pad = alphabet[alphabet.length - 1] === '='
    const mask = (1 << bitsPerChar) - 1
    let out = ''

    let bits = 0 // Number of bits currently in the buffer
    let buffer = 0 // Bits waiting to be written out, MSB first
    for (let i = 0; i < data.length; ++i) {
      // Slurp data into the buffer:
      buffer = (buffer << 8) | data[i]
      bits += 8

      // Write out as much as we can:
      while (bits > bitsPerChar) {
        bits -= bitsPerChar
        out += alphabet[mask & (buffer >> bits)]
      }
    }

    // Partial character:
    if (bits) {
      out += alphabet[mask & (buffer << (bitsPerChar - bits))]
    }

    // Add padding characters until we hit a byte boundary:
    if (pad) {
      while ((out.length * bitsPerChar) & 7) {
        out += '='
      }
    }

    return out
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L268
  const _decode = (string, alphabet, bitsPerChar, name) => {
    const codes = {}
    for (let i = 0; i < alphabet.length; ++i) {
      codes[alphabet[i]] = i
    }

    // Count the padding bytes:
    let end = string.length
    while (string[end - 1] === '=') {
      --end
    }

    const out = new Uint8Array((end * bitsPerChar / 8) | 0)

    let bits = 0
    let buffer = 0
    let written = 0
    for (let i = 0; i < end; ++i) {
      const value = codes[string[i]]
      if (value === undefined) {
        throw new SyntaxError(`Non-${name} character`)
      }

      buffer = (buffer << bitsPerChar) | value
      bits += bitsPerChar

      if (bits >= 8) {
        bits -= 8
        out[written++] = 0xff & (buffer >> bits)
      }
    }

    if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
      throw new SyntaxError('Unexpected end of data')
    }

    return out
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base.js#L366
  const rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {
    return from_1({
      prefix,
      name,
      encode(input) {
        return _encode(input, alphabet, bitsPerChar)
      },
      decode(input) {
        return _decode(input, alphabet, bitsPerChar, name)
      }
    })
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base58.js#L3
  const base58btc = baseX({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  })

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bases/base32.js#L3
  const base32 = rfc4648({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  })

  const CODE_DAG_PB = 0x70
  const CODE_RAW = 0x55

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L58
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L68
  var encodingLength_2 = function (value) {
    return (
      value < N1 ? 1
        : value < N2 ? 2
          : value < N3 ? 3
            : value < N4 ? 4
              : value < N5 ? 5
                : value < N6 ? 6
                  : value < N7 ? 7
                    : value < N8 ? 8
                      : value < N9 ? 9
                        : 10
    )
  };

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L30
  var MSB$1 = 0x80
    , REST$1 = 0x7F
    , MSBALL = ~REST
    , INT = Math.pow(2, 31);

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L33
  function decode_2(buf, offset) {
    var res = 0
      , offset = offset || 0
      , shift = 0
      , counter = offset
      , b
      , l = buf.length;

    do {
      if (counter >= l) {
        decode_2.bytes = 0;
        throw new RangeError('Could not decode varint')
      }
      b = buf[counter++];
      res += shift < 28
        ? (b & REST$1) << shift
        : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1)

    decode_2.bytes = counter - offset;

    return res
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/varint.js#L7
  const decode_1 = (data) => {
    const code = decode_2(data)
    return [code, decode_2.bytes]
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/vendor/varint.js#L8
  function encode_2(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode.bytes = 0
      throw new RangeError('Could not encode varint')
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;

    while (num >= INT) {
      out[offset++] = (num & 0xFF) | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = (num & 0xFF) | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;

    encode_2.bytes = offset - oldOffset + 1;

    return out
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/varint.js#L17
  const encodeTo_1 = (int, target, offset = 0) => {
    encode_2(int, target, offset)
    return target
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/varint.js#L26
  const encodingLength_1 = (int) => {
    return encodingLength_2(int)
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L382
  const parseCIDtoBytes = (source, base) => {
    switch (source[0]) {
      case 'Q': {
        const decoder = base || base58btc
        return [base58btc.prefix, decoder.decode(`${base58btc.prefix}${source}`)]
      }
      case base58btc.prefix: {
        const decoder = base || base58btc
        return [base58btc.prefix, decoder.decode(source)]
      }
      case base32.prefix: {
        const decoder = base || base32
        return [base32.prefix, decoder.decode(source)]
      }
      default: {
        if (base == null) {
          throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
        }
        return [source[0], base.decode(source)]
      }
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L412
  const toStringV0 = (bytes, cache, base) => {
    const { prefix } = base
    if (prefix !== base58btc.prefix) {
      throw Error(`Cannot string encode V0 in ${base.name} encoding`)
    }

    const cid = cache.get(prefix)
    if (cid == null) {
      const cid = base.encode(bytes).slice(1)
      cache.set(prefix, cid)
      return cid
    } else {
      return cid
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L434
  const toStringV1 = (bytes, cache, base) => {
    const { prefix } = base
    const cid = cache.get(prefix)
    if (cid == null) {
      const cid = base.encode(bytes)
      cache.set(prefix, cid)
      return cid
    } else {
      return cid
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L455
  const encodeCID = (version, code, multihash) => {
    const codeOffset = encodingLength_1(version)
    const hashOffset = codeOffset + encodingLength_1(code)
    const bytes = new Uint8Array(hashOffset + multihash.byteLength)
    encodeTo_1(version, bytes, 0)
    encodeTo_1(code, bytes, codeOffset)
    bytes.set(multihash, hashOffset)
    return bytes
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/bytes.js#L39
  const coerce = o => {
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o
    if (o instanceof ArrayBuffer) return new Uint8Array(o)
    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)
    }
    throw new Error('Unknown type, must be binary type')
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/cid.js#L22
  class CID {

    constructor(version, code, multihash, bytes) {
      this.code = code
      this.version = version
      this.multihash = multihash
      this.bytes = bytes
      this.byteOffset = bytes.byteOffset
      this.byteLength = bytes.byteLength
      this.asCID = this
      this._baseCache = new Map()

      Object.defineProperties(this, {
        byteOffset: hidden,
        byteLength: hidden,

        code: readonly,
        version: readonly,
        multihash: readonly,
        bytes: readonly,

        _baseCache: hidden,
        asCID: hidden
      })
    }

    toString(base) {
      const { bytes, version, _baseCache } = this
      switch (version) {
        case 0:
          return toStringV0(bytes, _baseCache, base || base58btc.encoder)
        default:
          return toStringV1(bytes, _baseCache, base || base32.encoder)
      }
    }

    static create(version, code, digest) {
      if (typeof code !== 'number') {
        throw new Error('String codecs are no longer supported')
      }

      switch (version) {
        case 0: {
          if (code !== CODE_DAG_PB) {
            throw new Error(`Version 0 CID must use dag-pb (code: ${CODE_DAG_PB}) block encoding`)
          } else {
            return new CID(version, code, digest, digest.bytes)
          }
        }
        case 1: {
          const bytes = encodeCID(version, code, digest.bytes)
          return new CID(version, code, digest, bytes)
        }
        default: {
          throw new Error('Invalid version')
        }
      }
    }

    static parse(source, base) {
      const [prefix, bytes] = parseCIDtoBytes(source, base)

      const cid = CID.decode(bytes)
      cid._baseCache.set(prefix, source)

      return cid
    }

    static decode(bytes) {
      const [cid, remainder] = CID.decodeFirst(bytes)
      if (remainder.length) {
        throw new Error('Incorrect length')
      }
      return cid
    }

    static decodeFirst(bytes) {
      const specs = CID.inspectBytes(bytes)
      const prefixSize = specs.size - specs.multihashSize
      const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize))
      if (multihashBytes.byteLength !== specs.multihashSize) {
        throw new Error('Incorrect length')
      }
      const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize)
      const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes)
      const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest)
      return [cid, bytes.subarray(specs.size)]
    }

    static inspectBytes(initialBytes) {
      let offset = 0
      const next = () => {
        const [i, length] = decode_1(initialBytes.subarray(offset))
        offset += length
        return i
      }

      let version = next()
      let codec = CODE_DAG_PB
      if (version === 18) { // CIDv0
        version = 0
        offset = 0
      } else if (version === 1) {
        codec = next()
      }

      if (version !== 0 && version !== 1) {
        throw new RangeError(`Invalid CID version ${version}`)
      }

      const prefixSize = offset
      const multihashCode = next()
      const digestSize = next()
      const size = offset + digestSize
      const multihashSize = size - prefixSize

      return { version, codec, multihashCode, digestSize, multihashSize, size }
    }

    static createV0(digest) {
      return CID.create(0, CODE_DAG_PB, digest)
    }

    static createV1(code, digest) {
      return CID.create(1, code, digest)
    }
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/hashes/digest.js#L10
  const create = (code, digest) => {
    const size = digest.byteLength
    const sizeOffset = encodingLength_1(code)
    const digestOffset = sizeOffset + encodingLength_1(size)

    const bytes = new Uint8Array(digestOffset + size)
    encodeTo_1(code, bytes, 0)
    encodeTo_1(size, bytes, sizeOffset)
    bytes.set(digest, digestOffset)

    return new Digest(code, size, digest, bytes)
  }

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/hashes/hasher.js#L22
  class Hasher {

    constructor(name, code, encode) {
      this.name = name
      this.code = code
      this.encode = encode
    }

    digest(input) {
      if (input instanceof Uint8Array) {
        const result = this.encode(input)
        return result instanceof Uint8Array
          ? create(this.code, result)
          : result.then((digest) => create(this.code, digest))
      } else {
        throw Error('Unknown type, must be binary type')
      }
    }
  }

  const from = ({ name, code, encode }) => new Hasher(name, code, encode)

  //https://github.com/multiformats/js-multiformats/blob/bb14a29dd823a517ef0c6c741d265e022591d831/src/hashes/sha2.js#L7
  const s_sha256 = from({
    name: 'sha2-256',
    code: 18,
    //encode: (input) => coerce(crypto__default["default"].createHash('sha256').update(input).digest())
    encode: (input) => {
      return coerce(createHash('sha256').update(input).digest());
    }
  });

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2016, Daniel Wirtz  All rights reserved.
  *  https://github.com/protobufjs/protobuf.js/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/
  var protobuf = {};//exports;

  protobuf.build = "minimal";

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/lib/inquire/index.js#L10
  const util_inquire = function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) { }
    return null;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/minimal.js#L126
  const util_Buffer = (function () {
    try {
      var Buffer = util_inquire("buffer").Buffer;
      return Buffer.prototype.utf8Write ? Buffer : null;
    } catch (e) {
      return null;
    }
  })();

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L21
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = undefined;
    this.val = val;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L49
  function noop() { }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L91
  function Writer() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L14
  function util_LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L37
  var zero = util_LongBits.zero = new util_LongBits(0, 0);

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L55
  util_LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0,
      hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new util_LongBits(lo, hi);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L80
  util_LongBits.from = function from(value) {
    if (typeof value === "number")
      return util_LongBits.fromNumber(value);
    if (util_isString(value)) {
      if (util_Long)
        value = util_Long.fromString(value);
      else
        return util_LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new util_LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  util_LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0,
            hi = ~this.hi     >>> 0;
        if (!lo)
            hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L187
  util_LongBits.prototype.length = function length() {
    var part0 = this.lo,
      part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,
      part2 = this.hi >>> 24;
    return part2 === 0
      ? part1 === 0
        ? part0 < 16384
          ? part0 < 128 ? 1 : 2
          : part0 < 2097152 ? 3 : 4
        : part1 < 16384
          ? part1 < 128 ? 5 : 6
          : part1 < 2097152 ? 7 : 8
      : part2 < 128 ? 9 : 10;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L242
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L261
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = util_LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L166
  Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/minimal.js#L79
  const util_isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };

  var invalidEncoding = "invalid encoding";
  var s64 = new Array(123);

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/lib/base64/index.js#L96
  const base64_decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0,
      t;
    for (var i = 0; i < string.length;) {
      var c = string.charCodeAt(i++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === undefined)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L172
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/lib/base64/index.js#L15
  const base64_length = function length(string) {
    var p = string.length;
    if (!p)
      return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
      ++n;
    return Math.ceil(string.length * 3) / 4 - n;
  };

  var util_Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L359
  var writeBytes = util_Array.prototype.set
    ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    }
    : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L374
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util_isString(value)) {
      var buf = Writer.alloc(len = base64_length(value));
      base64_decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L124
  var w1_create = function w1_create() {
    return util_Buffer
      ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      }
      : function create_array() {
        return new Writer();
      };
  };

  Writer.create = w1_create();

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L176
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L193
  function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
  }

  VarintOp.prototype.fn = writeVarint32;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L207
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp(
      (value = value >>> 0)
        < 128 ? 1
        : value < 16384 ? 2
          : value < 2097152 ? 3
            : value < 268435456 ? 4
              : 5,
      value)).len;
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L227
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0
      ? this._push(writeVarint64, 10, util_LongBits.fromNumber(value))
      : this.uint32(value);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L149
  Writer.alloc = function alloc(size) {
    return new util_Array(size);
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer_buffer.js#L6
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L448
  Writer.prototype.finish = function finish() {
    var head = this.head.next,
      buf = this.constructor.alloc(this.len),
      pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L461
  Writer._configure = function (BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = w1_create();
    BufferWriter._configure();
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L22
  function Reader(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }
  Reader.prototype.uint32 = (function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;

        /* istanbul ignore if */
        if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
  })();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(),
        start  = this.pos,
        end    = this.pos + length;

    /* istanbul ignore if */
    if (end > this.len)
        throw indexOutOfRange(this, length);

    this.pos += length;
    if (Array.isArray(this.buf)) // plain array
        return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
        ? new this.buf.constructor(0)
        : this._slice.call(this.buf, start, end);
  };
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/longbits.js#L123
  function readLongVarint() {
    var bits = new util_LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) { // fast route (lo)
        for (; i < 4; ++i) {
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;
        if (this.buf[this.pos++] < 128)
            return bits;
        i = 0;
    } else {
        for (; i < 3; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) { // fast route (hi)
        for (; i < 5; ++i) {
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    } else {
        for (; i < 5; ++i) {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
                return bits;
        }
    }
    /* istanbul ignore next */
    throw Error("invalid varint encoding");
  }
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L43
  var create_array = typeof Uint8Array !== "undefined"
    ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    }
    : function create_array(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L56
  var r1_create = function r1_create() {
    return util_Buffer
      ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
          return util_Buffer.isBuffer(buffer)
            ? new BufferReader(buffer)
            : create_array(buffer);
        })(buffer);
      }
      : create_array;
  };
  Reader.create = r1_create();
  Reader.prototype._slice = util_Array.prototype.subarray || /* istanbul ignore next */ util_Array.prototype.slice;
  
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/util/minimal.js#L237
  function util_merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
      if (dst[keys[i]] === undefined || !ifNotSet)
        dst[keys[i]] = src[keys[i]];
    return dst;
  }
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L334
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */
        if (this.pos + length > this.len)
            throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */
            if (this.pos >= this.len)
                throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;

        /* istanbul ignore next */
        default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader.js#L382
  Reader._configure = function (BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = r1_create();
    BufferReader._configure();

    var fn = "toNumber";
    util_merge(Reader.prototype, {

      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },

      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      }
    });
  };
  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer_buffer.js#L16
  function BufferWriter() {
    Writer.call(this);
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L374
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util_isString(value)) {
      var buf = Writer.alloc(len = base64.length(value));
      base64.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/lib/utf8/index.js#L15
  function utf8_length(string) {
    var len = 0,
      c = 0;
    for (var i = 0; i < string.length; ++i) {
      c = string.charCodeAt(i);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
        ++i;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer.js#L391
  Writer.prototype.string = function write_string(value) {
    var len = utf8_length(value);
    return len
      ? this.uint32(len)._push(utf8.write, len, value)
      : this._push(writeByte, 1, 0);
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L207
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp(
      (value = value >>> 0)
        < 128 ? 1
        : value < 16384 ? 2
          : value < 2097152 ? 3
            : value < 268435456 ? 4
              : 5,
      value)).len;
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L59
  function State(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L403
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L414
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  };

  //https://github.com/protobufjs/protobuf.js/blob/48457c47372c39e07a8ecf1360f80de7f263ab2e/src/writer.js#L431
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head,
      tail = this.tail,
      len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next; // skip noop
      this.tail = tail;
      this.len += len;
    }
    return this;
  };

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) Feross Aboukhadijeh, and other contributors.
  *  Licensed under the MIT License.
  *  https://github.com/feross/buffer/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L98
  function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        )
      }
      return allocUnsafe(arg)
    }
    return from(arg, encodingOrOffset, length)
  }

  Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
  Object.setPrototypeOf(Buffer, Uint8Array)

  const K_MAX_LENGTH = 0x7fffffff

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L322
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
        'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
    }
    return length | 0
  }

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L78
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"')
    }
    const buf = new Uint8Array(length)
    Object.setPrototypeOf(buf, Buffer.prototype)
    return buf
  }

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L182
  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be of type number')
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
  }

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L214
  function allocUnsafe(size) {
    assertSize(size)
    return createBuffer(size < 0 ? 0 : checked(size) | 0)
  }

  //https://github.com/feross/buffer/blob/795bbb5bda1b39f1370ebd784bea6107b087e3a7/index.js#L222
  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size)
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/writer_buffer.js#L20
  BufferWriter._configure = function () {

    BufferWriter.alloc = Buffer.allocUnsafe

    BufferWriter.writeBytesBuffer = util_Buffer && util_Buffer.prototype instanceof Uint8Array && util_Buffer.prototype.set.name === "set"
      ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      }
      : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length;)
          buf[pos++] = val[i++];
      };
  };

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader_buffer.js#L6
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader_buffer.js#L17
  function BufferReader(buffer) {
    Reader.call(this, buffer);
  }

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/reader_buffer.js#L27
  BufferReader._configure = function () {
    if (util_Buffer)
      BufferReader.prototype._slice = util_Buffer.prototype.slice;
  };

  protobuf.rpc = {};
  protobuf.roots = {};
  protobuf.configure = configure;

  //https://github.com/protobufjs/protobuf.js/blob/2cdbba32da9951c1ff14e55e65e4a9a9f24c70fd/src/index-minimal.js#L29
  function configure() {
    // util_configure();
    Writer._configure(BufferWriter);
    Reader._configure(BufferReader);
  }

  configure();

  var $protobuf = protobuf;
  var $protobuf__default = _interopDefaultLegacy($protobuf);

  /*---------------------------------------------------------------------------------------------
*  Licensed under the MIT License.
*  https://github.com/IndigoUnited/js-err-code/blob/8dd437663a48e833ab70223f8a58a888985d1e3a/README.md
*--------------------------------------------------------------------------------------------*/

  //https://github.com/IndigoUnited/js-err-code/blob/8dd437663a48e833ab70223f8a58a888985d1e3a/index.js#L15
  function assign(obj, props) {
    for (const key in props) {
      Object.defineProperty(obj, key, {
        value: props[key],
        enumerable: true,
        configurable: true,
      });
    }

    return obj;
  }

  //https://github.com/IndigoUnited/js-err-code/blob/8dd437663a48e833ab70223f8a58a888985d1e3a/index.js#L34
  function createError(err, code, props) {
    if (!err || typeof err === 'string') {
      throw new TypeError('Please pass an Error to err-code');
    }

    if (!props) {
      props = {};
    }

    if (typeof code === 'object') {
      props = code;
      code = '';
    }

    if (code) {
      props.code = code;
    }

    try {
      return assign(err, props);
    } catch (_) {
      props.message = err.message;
      props.stack = err.stack;

      const ErrClass = function () { };

      ErrClass.prototype = Object.create(Object.getPrototypeOf(err));

      // @ts-ignore
      const output = assign(new ErrClass(), props);

      return output;
    }
  }

  var errcode = createError;

  function _interopDefaultLegacy(e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }
  var errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);

  /*---------------------------------------------------------------------------------------------
  *  Licensed under the MIT License.
  *  https://github.com/ipfs/js-ipfs-unixfs/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/unixfs.js#L8
  const $root = $protobuf__default["default"].roots['ipfs-unixfs'] || ($protobuf__default["default"].roots['ipfs-unixfs'] = {});

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/unixfs.js#L10
  const Data = $root.Data = (() => {
    function Data(p) {
      this.blocksizes = [];
      if (p)
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
    }
    Data.prototype.Type = 0;
    Data.prototype.filesize = 0;
    Data.prototype.hashType = 0;
    Data.prototype.fanout = 0;
    Data.prototype.mode = 0;
    Data.prototype.mtime = null;
    Data.encode = function encode(m, w) {
      if (!w) {
        w = Writer.create();
      }
      w.uint32(8).int32(m.Type);
      if (m.Data != null && Object.hasOwnProperty.call(m, 'Data')) {
        w.uint32(18).bytes(m.Data);
      }
      if (m.filesize != null && Object.hasOwnProperty.call(m, 'filesize')) {
        w.uint32(24).uint64(m.filesize); // here is the bug
      }
      if (m.blocksizes != null && m.blocksizes.length) {
        for (var i = 0; i < m.blocksizes.length; ++i)
          w.uint32(32).uint64(m.blocksizes[i]);
      }
      if (m.hashType != null && Object.hasOwnProperty.call(m, 'hashType')) {
        w.uint32(40).uint64(m.hashType);
      }
      if (m.fanout != null && Object.hasOwnProperty.call(m, 'fanout')) {
        w.uint32(48).uint64(m.fanout);
      }

      if (m.mode != null && Object.hasOwnProperty.call(m, 'mode')) {
        w.uint32(56).uint32(m.mode);
      }

      if (m.mtime != null && Object.hasOwnProperty.call(m, 'mtime')) {
        $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
      }

      return w;
    };
    Data.decode = function decode(r, l) {
      if (!(r instanceof Reader))
        r = Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.Type = r.int32();
            break;
          case 2:
            m.Data = r.bytes();
            break;
          case 3:
            m.filesize = r.uint64();
            break;
          case 4:
            if (!(m.blocksizes && m.blocksizes.length))
              m.blocksizes = [];
            if ((t & 7) === 2) {
              var c2 = r.uint32() + r.pos;
              while (r.pos < c2)
                m.blocksizes.push(r.uint64());
            } else
              m.blocksizes.push(r.uint64());
            break;
          case 5:
            m.hashType = r.uint64();
            break;
          case 6:
            m.fanout = r.uint64();
            break;
          case 7:
            m.mode = r.uint32();
            break;
          case 8:
            m.mtime = $root.UnixTime.decode(r, r.uint32());
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Data.fromObject = function fromObject(d) {
      if (d instanceof $root.Data)
        return d;
      var m = new $root.Data();
      switch (d.Type) {
        case 'Raw':
        case 0:
          m.Type = 0;
          break;
        case 'Directory':
        case 1:
          m.Type = 1;
          break;
        case 'File':
        case 2:
          m.Type = 2;
          break;
      }
      return m;
    };
    Data.toObject = function toObject(m, o) {
      if (!o)
          o = {};
      var d = {};
      if (o.arrays || o.defaults) {
          d.blocksizes = [];
      }
      if (o.defaults) {
          d.Type = o.enums === String ? "Raw" : 0;
          if (o.bytes === String)
              d.Data = "";
          else {
              d.Data = [];
              if (o.bytes !== Array)
                  d.Data = $util.newBuffer(d.Data);
          }
          if ($util.Long) {
              var n = new $util.Long(0, 0, true);
              d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
              d.filesize = o.longs === String ? "0" : 0;
          if ($util.Long) {
              var n = new $util.Long(0, 0, true);
              d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
              d.hashType = o.longs === String ? "0" : 0;
          if ($util.Long) {
              var n = new $util.Long(0, 0, true);
              d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
              d.fanout = o.longs === String ? "0" : 0;
          d.mode = 0;
          d.mtime = null;
      }
      if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
      }
      if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
      }
      if (m.filesize != null && m.hasOwnProperty("filesize")) {
          if (typeof m.filesize === "number")
              d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
          else
              d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
      }
      if (m.blocksizes && m.blocksizes.length) {
          d.blocksizes = [];
          for (var j = 0; j < m.blocksizes.length; ++j) {
              if (typeof m.blocksizes[j] === "number")
                  d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
              else
                  d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
          }
      }
      if (m.hashType != null && m.hasOwnProperty("hashType")) {
          if (typeof m.hashType === "number")
              d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
          else
              d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
      }
      if (m.fanout != null && m.hasOwnProperty("fanout")) {
          if (typeof m.fanout === "number")
              d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
          else
              d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
      }
      if (m.mode != null && m.hasOwnProperty("mode")) {
          d.mode = m.mode;
      }
      if (m.mtime != null && m.hasOwnProperty("mtime")) {
          d.mtime = $root.UnixTime.toObject(m.mtime, o);
      }
      return d;
    };
    Data.DataType = function () {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'Raw'] = 0;
      values[valuesById[1] = 'Directory'] = 1;
      values[valuesById[2] = 'File'] = 2;
      return values;
    }();
    return Data;
  })();

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L10
  const types = [
    'raw',
    'directory',
    'file',
    'metadata',
    'symlink',
    'hamt-sharded-directory'
  ];

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L19
  const dirTypes = [
    'directory',
    'hamt-sharded-directory'
  ];

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L30
  function parseMode(mode) {
    if (mode == null) {
      return undefined;
    }
    if (typeof mode === 'number') {
      return mode & 4095;
    }
    mode = mode.toString();
    if (mode.substring(0, 1) === '0') {
      return parseInt(mode, 8) & 4095;
    }
    return parseInt(mode, 10) & 4095;
  }

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L53
  function parseMtime(input) {
    if (input == null) {
      return undefined;
    }
    let mtime;
    if (input.secs != null) {
      mtime = {
        secs: input.secs,
        nsecs: input.nsecs
      };
    }
    if (input.Seconds != null) {
      mtime = {
        secs: input.Seconds,
        nsecs: input.FractionalNanoseconds
      };
    }
    if (Array.isArray(input)) {
      mtime = {
        secs: input[0],
        nsecs: input[1]
      };
    }
    if (input instanceof Date) {
      const ms = input.getTime();
      const secs = Math.floor(ms / 1000);
      mtime = {
        secs: secs,
        nsecs: (ms - secs * 1000) * 1000
      };
    }
    if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {
      return undefined;
    }
    if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
      throw errcode__default["default"](new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');
    }
    return mtime;
  }

  const PBData = Data;

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L24
  const DEFAULT_FILE_MODE = parseInt('0644', 8);
  const DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);

  //https://github.com/ipfs/js-ipfs-unixfs/blob/de1a7f0afc144462b374919a44d3af4fae3a49da/packages/ipfs-unixfs/src/index.js#L122
  class UnixFS {
    static unmarshal (marshaled) {
      const message = PBData.decode(marshaled)
      const decoded = PBData.toObject(message, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
      })
      const data = new UnixFS({
        type: types[decoded.Type],
        data: decoded.Data,
        blockSizes: decoded.blocksizes,
        mode: decoded.mode,
        mtime: decoded.mtime
          ? {
              secs: decoded.mtime.Seconds,
              nsecs: decoded.mtime.FractionalNanoseconds
            }
          : undefined
      })
      data._originalMode = decoded.mode || 0;
      return data
    };
    constructor(options = { type: 'file' }) {
      const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
      if (type && !types.includes(type)) {
        throw errcode__default["default"](new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
      }
      this.type = type || 'file';
      this.data = data;
      this.hashType = hashType;
      this.fanout = fanout;
      this.blockSizes = blockSizes || [];
      this._originalMode = 0;
      this.mode = parseMode(mode);
      if (mtime) {
        this.mtime = parseMtime(mtime);
        if (this.mtime && !this.mtime.nsecs) {
          this.mtime.nsecs = 0;
        }
      }
    }
    set mode(mode) {
      this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
      const parsedMode = parseMode(mode);
      if (parsedMode !== undefined) {
        this._mode = parsedMode;
      }
    }
    get mode() {
      return this._mode;
    }
    isDirectory() {
      return Boolean(this.type && dirTypes.includes(this.type));
    }
    addBlockSize(size) {
      this.blockSizes.push(size)
    }
    fileSize() {
      if (this.isDirectory()) {
        return 0;
      }
      let sum = 0;
      this.blockSizes.forEach(size => {
        sum += size;
      });
      if (this.data) {
        sum += this.data.length;
      }
      return sum;
    }
    marshal() {
      let type;
      switch (this.type) {
        case 'raw':
          type = PBData.DataType.Raw;
          break;
        case 'directory':
          type = PBData.DataType.Directory;
          break;
        case 'file':
          type = PBData.DataType.File;
          break;
        case 'metadata':
          type = PBData.DataType.Metadata;
          break;
        case 'symlink':
          type = PBData.DataType.Symlink;
          break;
        case 'hamt-sharded-directory':
          type = PBData.DataType.HAMTShard;
          break;
        default:
          throw errcode__default["default"](new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
      }
      let data = this.data;
      if (!this.data || !this.data.length) {
        data = undefined;
      }
      let mode;
      if (this.mode != null) {
        mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
        if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
          mode = undefined;
        }
        if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
          mode = undefined;
        }
      }
      let mtime;
      if (this.mtime != null) {
        const parsed = parseMtime(this.mtime);
        if (parsed) {
          mtime = {
            Seconds: parsed.secs,
            FractionalNanoseconds: parsed.nsecs
          };
          if (mtime.FractionalNanoseconds === 0) {
            delete mtime.FractionalNanoseconds;
          }
        }
      }
      const pbData = {
        Type: type,
        Data: data,
        filesize: this.isDirectory() ? undefined : this.fileSize(),
        blocksizes: this.blockSizes,
        hashType: this.hashType,
        fanout: this.fanout,
        mode,
        mtime
      };
      return PBData.encode(pbData).finish();
    }
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020-2021 Yusuke Kawasaki
  *  Licensed under the MIT License.
  *  https://github.com/kawanet/sha256-uint8array/blob/main/LICENSE
  *--------------------------------------------------------------------------------------------*/
  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L36
  const algorithms = {
    sha256: 1,
  };

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L40
  function createHash(algorithm) {
    if (algorithm && !algorithms[algorithm] && !algorithms[algorithm.toLowerCase()]) {
      throw new Error("Digest method not supported");
    }
    return new Hash();
  }

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L6
  const K = [
    0x428a2f98 | 0, 0x71374491 | 0, 0xb5c0fbcf | 0, 0xe9b5dba5 | 0,
    0x3956c25b | 0, 0x59f111f1 | 0, 0x923f82a4 | 0, 0xab1c5ed5 | 0,
    0xd807aa98 | 0, 0x12835b01 | 0, 0x243185be | 0, 0x550c7dc3 | 0,
    0x72be5d74 | 0, 0x80deb1fe | 0, 0x9bdc06a7 | 0, 0xc19bf174 | 0,
    0xe49b69c1 | 0, 0xefbe4786 | 0, 0x0fc19dc6 | 0, 0x240ca1cc | 0,
    0x2de92c6f | 0, 0x4a7484aa | 0, 0x5cb0a9dc | 0, 0x76f988da | 0,
    0x983e5152 | 0, 0xa831c66d | 0, 0xb00327c8 | 0, 0xbf597fc7 | 0,
    0xc6e00bf3 | 0, 0xd5a79147 | 0, 0x06ca6351 | 0, 0x14292967 | 0,
    0x27b70a85 | 0, 0x2e1b2138 | 0, 0x4d2c6dfc | 0, 0x53380d13 | 0,
    0x650a7354 | 0, 0x766a0abb | 0, 0x81c2c92e | 0, 0x92722c85 | 0,
    0xa2bfe8a1 | 0, 0xa81a664b | 0, 0xc24b8b70 | 0, 0xc76c51a3 | 0,
    0xd192e819 | 0, 0xd6990624 | 0, 0xf40e3585 | 0, 0x106aa070 | 0,
    0x19a4c116 | 0, 0x1e376c08 | 0, 0x2748774c | 0, 0x34b0bcb5 | 0,
    0x391c0cb3 | 0, 0x4ed8aa4a | 0, 0x5b9cca4f | 0, 0x682e6ff3 | 0,
    0x748f82ee | 0, 0x78a5636f | 0, 0x84c87814 | 0, 0x8cc70208 | 0,
    0x90befffa | 0, 0xa4506ceb | 0, 0xbef9a3f7 | 0, 0xc67178f2 | 0,
  ];

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L48
  class Hash {
    constructor() {
      // first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19
      this.A = 0x6a09e667 | 0;
      this.B = 0xbb67ae85 | 0;
      this.C = 0x3c6ef372 | 0;
      this.D = 0xa54ff53a | 0;
      this.E = 0x510e527f | 0;
      this.F = 0x9b05688c | 0;
      this.G = 0x1f83d9ab | 0;
      this.H = 0x5be0cd19 | 0;
      this._size = 0;
      this._sp = 0; // surrogate pair
      if (!sharedBuffer || sharedOffset >= 8000 /* allocTotal */) {
        sharedBuffer = new ArrayBuffer(8000 /* allocTotal */);
        sharedOffset = 0;
      }
      this._byte = new Uint8Array(sharedBuffer, sharedOffset, 80 /* allocBytes */);
      this._word = new Int32Array(sharedBuffer, sharedOffset, 20 /* allocWords */);
      sharedOffset += 80 /* allocBytes */;
    }
    update(data) {
      // data: string
      if ("string" === typeof data) {
        return this._utf8(data);
      }
      // data: undefined
      if (data == null) {
        throw new TypeError("Invalid type: " + typeof data);
      }
      const byteOffset = data.byteOffset;
      const length = data.byteLength;
      let blocks = (length / 64 /* inputBytes */) | 0;
      let offset = 0;
      // longer than 1 block
      if (blocks && !(byteOffset & 3) && !(this._size % 64 /* inputBytes */)) {
        const block = new Int32Array(data.buffer, byteOffset, blocks * 16 /* inputWords */);
        while (blocks--) {
          this._int32(block, offset >> 2);
          offset += 64 /* inputBytes */;
        }
        this._size += offset;
      }
      // data: TypedArray | DataView
      const BYTES_PER_ELEMENT = data.BYTES_PER_ELEMENT;
      if (BYTES_PER_ELEMENT !== 1 && data.buffer) {
        const rest = new Uint8Array(data.buffer, byteOffset + offset, length - offset);
        return this._uint8(rest);
      }
      // no more bytes
      if (offset === length)
        return this;
      // data: Uint8Array | Int8Array
      return this._uint8(data, offset);
    }
    _uint8(data, offset) {
      const { _byte, _word } = this;
      const length = data.length;
      offset = offset | 0;
      while (offset < length) {
        const start = this._size % 64 /* inputBytes */;
        let index = start;
        while (offset < length && index < 64 /* inputBytes */) {
          _byte[index++] = data[offset++];
        }
        if (index >= 64 /* inputBytes */) {
          this._int32(_word);
        }
        this._size += index - start;
      }
      return this;
    }
    _utf8(text) {
      const { _byte, _word } = this;
      const length = text.length;
      let surrogate = this._sp;
      for (let offset = 0; offset < length;) {
        const start = this._size % 64 /* inputBytes */;
        let index = start;
        while (offset < length && index < 64 /* inputBytes */) {
          let code = text.charCodeAt(offset++) | 0;
          if (code < 0x80) {
            // ASCII characters
            _byte[index++] = code;
          }
          else if (code < 0x800) {
            // 2 bytes
            _byte[index++] = 0xC0 | (code >>> 6);
            _byte[index++] = 0x80 | (code & 0x3F);
          }
          else if (code < 0xD800 || code > 0xDFFF) {
            // 3 bytes
            _byte[index++] = 0xE0 | (code >>> 12);
            _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);
            _byte[index++] = 0x80 | (code & 0x3F);
          }
          else if (surrogate) {
            // 4 bytes - surrogate pair
            code = ((surrogate & 0x3FF) << 10) + (code & 0x3FF) + 0x10000;
            _byte[index++] = 0xF0 | (code >>> 18);
            _byte[index++] = 0x80 | ((code >>> 12) & 0x3F);
            _byte[index++] = 0x80 | ((code >>> 6) & 0x3F);
            _byte[index++] = 0x80 | (code & 0x3F);
            surrogate = 0;
          }
          else {
            surrogate = code;
          }
        }
        if (index >= 64 /* inputBytes */) {
          this._int32(_word);
          _word[0] = _word[16 /* inputWords */];
        }
        this._size += index - start;
      }
      this._sp = surrogate;
      return this;
    }
    _int32(data, offset) {
      let { A, B, C, D, E, F, G, H } = this;
      let i = 0;
      offset = offset | 0;
      while (i < 16 /* inputWords */) {
        W[i++] = swap32(data[offset++]);
      }
      for (i = 16 /* inputWords */; i < 64 /* workWords */; i++) {
        W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;
      }
      for (i = 0; i < 64 /* workWords */; i++) {
        const T1 = (H + sigma1(E) + ch(E, F, G) + K[i] + W[i]) | 0;
        const T2 = (sigma0(A) + maj(A, B, C)) | 0;
        H = G;
        G = F;
        F = E;
        E = (D + T1) | 0;
        D = C;
        C = B;
        B = A;
        A = (T1 + T2) | 0;
      }
      this.A = (A + this.A) | 0;
      this.B = (B + this.B) | 0;
      this.C = (C + this.C) | 0;
      this.D = (D + this.D) | 0;
      this.E = (E + this.E) | 0;
      this.F = (F + this.F) | 0;
      this.G = (G + this.G) | 0;
      this.H = (H + this.H) | 0;
    }
    digest(encoding) {
      const { _byte, _word } = this;
      let i = (this._size % 64 /* inputBytes */) | 0;
      _byte[i++] = 0x80;
      // pad 0 for current word
      while (i & 3) {
        _byte[i++] = 0;
      }
      i >>= 2;
      if (i > 14 /* highIndex */) {
        while (i < 16 /* inputWords */) {
          _word[i++] = 0;
        }
        i = 0;
        this._int32(_word);
      }
      // pad 0 for rest words
      while (i < 16 /* inputWords */) {
        _word[i++] = 0;
      }
      // input size
      const bits64 = this._size * 8;
      const low32 = (bits64 & 0xffffffff) >>> 0;
      const high32 = (bits64 - low32) / 0x100000000;
      if (high32)
        _word[14 /* highIndex */] = swap32(high32);
      if (low32)
        _word[15 /* lowIndex */] = swap32(low32);
      this._int32(_word);
      return (encoding === "hex") ? this._hex() : this._bin();
    }
    _hex() {
      const { A, B, C, D, E, F, G, H } = this;
      return hex32(A) + hex32(B) + hex32(C) + hex32(D) + hex32(E) + hex32(F) + hex32(G) + hex32(H);
    }
    _bin() {
      const { A, B, C, D, E, F, G, H, _byte, _word } = this;
      _word[0] = swap32(A);
      _word[1] = swap32(B);
      _word[2] = swap32(C);
      _word[3] = swap32(D);
      _word[4] = swap32(E);
      _word[5] = swap32(F);
      _word[6] = swap32(G);
      _word[7] = swap32(H);
      return _byte.slice(0, 32);
    }
  }

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L290
  const W = new Int32Array(64 /* workWords */);
  let sharedBuffer;
  let sharedOffset = 0;
  const hex32 = num => (num + 0x100000000).toString(16).substr(-8);
  const swapLE = (c => (((c << 24) & 0xff000000) | ((c << 8) & 0xff0000) | ((c >> 8) & 0xff00) | ((c >> 24) & 0xff)));
  const swapBE = (c => c);
  const swap32 = isBE() ? swapBE : swapLE;
  const ch = (x, y, z) => (z ^ (x & (y ^ z)));
  const maj = (x, y, z) => ((x & y) | (z & (x | y)));
  const sigma0 = x => ((x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10));
  const sigma1 = x => ((x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7));
  const gamma0 = x => ((x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3));
  const gamma1 = x => ((x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10));

  //https://github.com/kawanet/sha256-uint8array/blob/52e8f1b891c84fcb436f0f2e1103527d3a6465ea/lib/sha256-uint8array.ts#L308
  function isBE() {
    const buf = new Uint8Array(new Uint16Array([0xFEFF]).buffer); // BOM
    return (buf[0] === 0xFE);
  }

  var MSB = 0x80
    , REST = 0x7F
    , MSBALL = ~REST
    , INT = Math.pow(2, 31);

  /*---------------------------------------------------------------------------------------------
  *  Copyright 2016-2020 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/ipld/js-dag-pb/blob/master/LICENSE-MIT
  *--------------------------------------------------------------------------------------------*/
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/util.js#L8
  const pbNodeProperties = ['Data', 'Links']
  const pbLinkProperties = ['Hash', 'Name', 'Tsize']

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L1
  const textEncoder = new TextEncoder();
  const maxInt32 = 2 ** 32
  const maxUInt32 = 2 ** 31

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L197
  const len8tab = [
    0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
  ]

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L23
  function encodeLink(link, bytes) {
    let i = bytes.length

    if (typeof link.Tsize === 'number') {
      if (link.Tsize < 0) {
        throw new Error('Tsize cannot be negative')
      }
      if (!Number.isSafeInteger(link.Tsize)) {
        throw new Error('Tsize too large for encoding')
      }
      i = encodeVarint(bytes, i, link.Tsize) - 1
      bytes[i] = 0x18
    }

    if (typeof link.Name === 'string') {
      const nameBytes = textEncoder.encode(link.Name)
      i -= nameBytes.length
      bytes.set(nameBytes, i)
      i = encodeVarint(bytes, i, nameBytes.length) - 1
      bytes[i] = 0x12
    }

    if (link.Hash) {
      i -= link.Hash.length
      bytes.set(link.Hash, i)
      i = encodeVarint(bytes, i, link.Hash.length) - 1
      bytes[i] = 0xa
    }

    return bytes.length - i
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L91
  function sizeLink(link) {
    let n = 0

    if (link.Hash) {
      const l = link.Hash.length
      n += 1 + l + sov(l)
    }

    if (typeof link.Name === 'string') {
      const l = textEncoder.encode(link.Name).length
      n += 1 + l + sov(l)
    }

    if (typeof link.Tsize === 'number') {
      n += 1 + sov(link.Tsize)
    }

    return n
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L179
  function len64(x) {
    let n = 0
    if (x >= maxInt32) {
      x = Math.floor(x / maxInt32)
      n = 32
    }
    if (x >= (1 << 16)) {
      x >>>= 16
      n += 16
    }
    if (x >= (1 << 8)) {
      x >>>= 8
      n += 8
    }
    return n + len8tab[x]
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L166
  function sov(x) {
    if (x % 2 === 0) {
      x++
    }
    return Math.floor((len64(x) + 6) / 7)
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L141
  function encodeVarint(bytes, offset, v) {
    offset -= sov(v)
    const base = offset

    while (v >= maxUInt32) {
      bytes[offset++] = (v & 0x7f) | 0x80
      v /= 128
    }

    while (v >= 128) {
      bytes[offset++] = (v & 0x7f) | 0x80
      v >>>= 7
    }

    bytes[offset] = v

    return base
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L141
  function sizeNode(node) {
    let n = 0

    if (node.Data) {
      const l = node.Data.length
      n += 1 + l + sov(l)
    }

    if (node.Links) {
      for (const link of node.Links) {
        const l = sizeLink(link)
        n += 1 + l + sov(l)
      }
    }

    return n
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-encode.js#L61
  function encodeNode(node) {
    const size = sizeNode(node)
    const bytes = new Uint8Array(size)
    let i = size

    if (node.Data) {
      i -= node.Data.length
      bytes.set(node.Data, i)
      i = encodeVarint(bytes, i, node.Data.length) - 1
      bytes[i] = 0xa
    }

    if (node.Links) {
      for (let index = node.Links.length - 1; index >= 0; index--) {
        const size = encodeLink(node.Links[index], bytes.subarray(0, i))
        i -= size
        i = encodeVarint(bytes, i, size) - 1
        bytes[i] = 0x12
      }
    }

    return bytes
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/util.js#L18
  function linkComparator(a, b) {
    if (a === b) {
      return 0
    }

    const abuf = a.Name ? textEncoder.encode(a.Name) : []
    const bbuf = b.Name ? textEncoder.encode(b.Name) : []

    let x = abuf.length
    let y = bbuf.length

    for (let i = 0, len = Math.min(x, y); i < len; ++i) {
      if (abuf[i] !== bbuf[i]) {
        x = abuf[i]
        y = bbuf[i]
        break
      }
    }

    return x < y ? -1 : y < x ? 1 : 0
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/util.js#L45
  function hasOnlyProperties(node, properties) {
    return !Object.keys(node).some((p) => !properties.includes(p))
  }

  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/util.js#L147
  function validate(node) {

    if (!node || typeof node !== 'object' || Array.isArray(node)) {
      throw new TypeError('Invalid DAG-PB form')
    }

    if (!hasOnlyProperties(node, pbNodeProperties)) {
      throw new TypeError('Invalid DAG-PB form (extraneous properties)')
    }

    if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {
      throw new TypeError('Invalid DAG-PB form (Data must be a Uint8Array)')
    }

    if (!Array.isArray(node.Links)) {
      throw new TypeError('Invalid DAG-PB form (Links must be an array)')
    }

    for (let i = 0; i < node.Links.length; i++) {
      const link = node.Links[i]
      if (!link || typeof link !== 'object' || Array.isArray(link)) {
        throw new TypeError('Invalid DAG-PB form (bad link object)')
      }

      if (!hasOnlyProperties(link, pbLinkProperties)) {
        throw new TypeError('Invalid DAG-PB form (extraneous properties on link object)')
      }

      if (!link.Hash) {
        throw new TypeError('Invalid DAG-PB form (link must have a Hash)')
      }

      if (link.Hash.asCID !== link.Hash) {
        throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')
      }

      if (link.Name !== undefined && typeof link.Name !== 'string') {
        throw new TypeError('Invalid DAG-PB form (link Name must be a string)')
      }

      if (link.Tsize !== undefined && (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0)) {
        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')
      }

      if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
        throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')
      }
    }
  }
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L16
  var decodeVarint = (bytes, offset) => {
    let v = 0
  
    for (let shift = 0; ; shift += 7) {
      /* c8 ignore next 3 */
      if (shift >= 64) {
        throw new Error('protobuf: varint overflow')
      }
      /* c8 ignore next 3 */
      if (offset >= bytes.length) {
        throw new Error('protobuf: unexpected end of data')
      }
  
      const b = bytes[offset++]
      v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)
      if (b < 0x80) {
        break
      }
    }
    return [v, offset]
  }
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L43
  var decodeBytes = (bytes, offset) => {
    let byteLen
    ;[byteLen, offset] = decodeVarint(bytes, offset)
    const postOffset = offset + byteLen
  
    /* c8 ignore next 3 */
    if (byteLen < 0 || postOffset < 0) {
      throw new Error('protobuf: invalid length')
    }
    /* c8 ignore next 3 */
    if (postOffset > bytes.length) {
      throw new Error('protobuf: unexpected end of data')
    }
  
    return [bytes.subarray(offset, postOffset), postOffset]
  }
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L65
  var decodeKey = (bytes, index) => {
    let wire
    ;[wire, index] = decodeVarint(bytes, index);
    return [wire & 0x7, wire >> 3, index]
  };
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L141
  var decodeNode =(bytes) => {
    const l = bytes.length
    let index = 0
    let links
    let linksBeforeData = false
    let data
    while (index < l) {
      let wireType, fieldNum
      ;[wireType, fieldNum, index] = decodeKey(bytes, index)

      if (wireType !== 2) {
        throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)
      }
      if (fieldNum === 1) {
        if (data) {
          throw new Error('protobuf: (PBNode) duplicate Data section')
        }

        ;[data, index] = decodeBytes(bytes, index)
        if (links) {
          linksBeforeData = true
        }
      } else if (fieldNum === 2) {
        if (linksBeforeData) { // interleaved Links/Dode/Links
          throw new Error('protobuf: (PBNode) duplicate Links section')
        } else if (!links) {
          links = []
        }
        let byts
        ;[byts, index] = decodeBytes(bytes, index)
        links.push(decodeLink(byts))
      } else {
        throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)
      }
    }
    if (index > l) {
      throw new Error('protobuf: (PBNode) unexpected end of data')
    }
    const node = {}
    if (data) {
      node.Data = data
    }
    node.Links = links || []
    return node
  }
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/pb-decode.js#L76
  var decodeLink = (bytes) => {
    const link = {}
    const l = bytes.length
    let index = 0
  
    while (index < l) {
      let wireType, fieldNum
      ;[wireType, fieldNum, index] = decodeKey(bytes, index)
  
      if (fieldNum === 1) {
        if (link.Hash) {
          throw new Error('protobuf: (PBLink) duplicate Hash section')
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)
        }
        if (link.Name !== undefined) {
          throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')
        }
        if (link.Tsize !== undefined) {
          throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')
        }
  
        ;[link.Hash, index] = decodeBytes(bytes, index)
      } else if (fieldNum === 2) {
        if (link.Name !== undefined) {
          throw new Error('protobuf: (PBLink) duplicate Name section')
        }
        if (wireType !== 2) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)
        }
        if (link.Tsize !== undefined) {
          throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')
        }
  
        let byts
        ;[byts, index] = decodeBytes(bytes, index)
        link.Name = textDecoder.decode(byts)
      } else if (fieldNum === 3) {
        if (link.Tsize !== undefined) {
          throw new Error('protobuf: (PBLink) duplicate Tsize section')
        }
        if (wireType !== 0) {
          throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)
        }
  
        ;[link.Tsize, index] = decodeVarint(bytes, index)
      } else {
        throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)
      }
    }  
    /* c8 ignore next 3 */
    if (index > l) {
      throw new Error('protobuf: (PBLink) unexpected end of data')
    }  
    return link
  };
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/index.js#L53
  var d_decode = (bytes) => {
    const pbn = decodeNode(bytes)
    const node = {}
    if (pbn.Data) {
      node.Data = pbn.Data
    }
    if (pbn.Links) {
      node.Links = pbn.Links.map((l) => {
        const link = {}
        try {
          link.Hash = CID.decode(l.Hash)
        } catch (e) {}
        if (!link.Hash) {
          throw new Error('Invalid Hash field found in link, expected CID')
        }
        if (l.Name !== undefined) {
          link.Name = l.Name
        }
        if (l.Tsize !== undefined) {
          link.Tsize = l.Tsize
        }
        return link
      })
    }
    return node
  };
  //https://github.com/ipld/js-dag-pb/blob/422f91ea722efdd119b25a8c41087ef9a61f2252/src/index.js#L23
  var d_encode = (node) => {
    validate(node)
    const pbn = {}
    if (node.Links) {
      pbn.Links = node.Links.map((l) => {
        const link = {}
        if (l.Hash) {
          link.Hash = l.Hash.bytes // cid -> bytes
        }
        if (l.Name !== undefined) {
          link.Name = l.Name
        }
        if (l.Tsize !== undefined) {
          link.Tsize = l.Tsize
        }
        return link
      })
    }
    if (node.Data) {
      pbn.Data = node.Data
    }

    return encodeNode(pbn)
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2016-2018 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/ipld/js-ipld-dag-pb/blob/master/LICENSE.md
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag-node/sortLinks.js#L28
  const sortLinks = (links) => {
    const sort = stable;
    sort.inplace(links, linkSort)
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag-node/sortLinks.js#L15
  const linkSort = (a, b) => {
    const buf1 = a.nameAsBuffer
    const buf2 = b.nameAsBuffer

    return uint8ArrayCompare(buf1, buf2)
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag-link/dagLink.js#L9
  class DAGLink {
    constructor(name, size, cid) {
      if (!cid) {
        throw new Error('A link requires a cid to point to')
      }
      this.Name = name || ''
      this.Tsize = size
      this.Hash = new CID1(cid)

      Object.defineProperties(this, {
        _nameBuf: { value: null, writable: true, enumerable: false }
      })
    }

    toString() {
      return `DAGLink <${this.Hash.toBaseEncodedString()} - name: "${this.Name}", size: ${this.Tsize}>`
    }

    toJSON() {
      if (!this._json) {
        this._json = Object.freeze({
          name: this.Name,
          size: this.Tsize,
          cid: this.Hash.toBaseEncodedString()
        })
      }

      return Object.assign({}, this._json)
    }
    get nameAsBuffer() {
      if (this._nameBuf != null) {
        return this._nameBuf
      }

      this._nameBuf = uint8ArrayFromString(this.Name)
      return this._nameBuf
    }
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag-node/dagNode.js#L18
  class DAGNode {

    constructor(data, links = [], serializedSize = null) {
      if (!data) {
        data = new Uint8Array(0)
      }
      if (typeof data === 'string') {
        data = uint8ArrayFromString(data)
      }

      if (!(data instanceof Uint8Array)) {
        throw new Error('Passed \'data\' is not a Uint8Array or a String!')
      }

      if (serializedSize !== null && typeof serializedSize !== 'number') {
        throw new Error('Passed \'serializedSize\' must be a number!')
      }

      const sortedLinks = links.map((link) => {
        return link instanceof DAGLink
          ? link
          : createDagLinkFromB58EncodedHash(link)
      })
      sortLinks(sortedLinks)

      this.Data = data
      this.Links = sortedLinks

      Object.defineProperties(this, {
        _serializedSize: { value: serializedSize, writable: true, enumerable: false },
        _size: { value: null, writable: true, enumerable: false }
      })
    }

    toJSON() {
      if (!this._json) {
        this._json = Object.freeze({
          data: this.Data,
          links: this.Links.map((l) => l.toJSON()),
          size: this.size
        })
      }

      return Object.assign({}, this._json)
    }

    toString() {
      return `DAGNode <data: "${uint8ArrayToString(this.Data, 'base64urlpad')}", links: ${this.Links.length}, size: ${this.size}>`
    }

    _invalidateCached() {
      this._serializedSize = null
      this._size = null
    }

    /**
     * @param {DAGLink | import('../types').DAGLinkLike} link
     */
    addLink(link) {
      this._invalidateCached()
      return addLink(this, link)
    }

    /**
     * @param {DAGLink | string | CID} link
     */
    rmLink(link) {
      this._invalidateCached()
      return rmLink(this, link)
    }

    /**
     * @param {import('./toDagLink').ToDagLinkOptions} [options]
     */
    toDAGLink(options) {
      return toDAGLink(this, options)
    }

    serialize() {
      const buf = serializeDAGNode(this)

      this._serializedSize = buf.length

      return buf
    }

    get size() {
      if (this._size == null) {
        let serializedSize

        if (serializedSize == null) {
          this._serializedSize = this.serialize().length
          serializedSize = this._serializedSize
        }

        this._size = this.Links.reduce((sum, l) => sum + l.Tsize, serializedSize)
      }

      return this._size
    }

    set size(size) {
      throw new Error("Can't set property: 'size' is immutable")
    }
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/serialize.js#L23
  const toProtoBuf = (node) => {
    const pbn = {}

    if (node.Data && node.Data.byteLength > 0) {
      pbn.Data = node.Data
    } else {
      // NOTE: this has to be null in order to match go-ipfs serialization
      // `null !== new Uint8Array(0)`
      pbn.Data = null
    }

    if (node.Links && node.Links.length > 0) {
      pbn.Links = node.Links
        .map((link) => ({
          Hash: link.Hash.bytes,
          Name: link.Name,
          Tsize: link.Tsize
        }))
    } else {
      pbn.Links = null
    }

    return pbn
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/serialize.js#L53
  const serializeDAGNode = (node) => {
    return encode(toProtoBuf(node))
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag.js#L31
  function PBLink(p) {
    if (p)
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
  }

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/dag.js#L71
  PBLink.encode = function encode(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.Hash != null && Object.hasOwnProperty.call(m, "Hash"))
      w.uint32(10).bytes(m.Hash);
    if (m.Name != null && Object.hasOwnProperty.call(m, "Name"))
      w.uint32(18).string(m.Name);
    if (m.Tsize != null && Object.hasOwnProperty.call(m, "Tsize"))
      w.uint32(24).uint64(m.Tsize);
    return w;
  };

  //https://github.com/ipld/js-ipld-dag-pb/blob/6b0e011b7917611386cff392d56bfd81c8cacf8c/src/serialize.js#L87
  function encode(pbf) {
    const writer = Writer.create()

    if (pbf.Links != null) {
      for (let i = 0; i < pbf.Links.length; i++) {
        PBLink.encode(pbf.Links[i], writer.uint32(18).fork()).ldelim()
      }
    }

    if (pbf.Data != null) {
      writer.uint32(10).bytes(pbf.Data)
    }

    return writer.finish()
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2013-2019 bl contributors
  *  Licensed under the MIT License.
  *  https://github.com/rvagg/bl/blob/master/LICENSE.md
  *--------------------------------------------------------------------------------------------*/
  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L4
  const symbol = Symbol.for('BufferList')
  function BufferList(buf) {
    if (!(this instanceof BufferList)) {
      return new BufferList(buf)
    }

    BufferList._init.call(this, buf)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L14
  BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, { value: true })

    this._bufs = []
    this.length = 0

    if (buf) {
      this.append(buf)
    }
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L25
  BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L29
  BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) {
      return [0, 0]
    }

    let tot = 0

    for (let i = 0; i < this._bufs.length; i++) {
      const _t = tot + this._bufs[i].length
      if (offset < _t || i === this._bufs.length - 1) {
        return [i, offset - tot]
      }
      tot = _t
    }
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L45
  BufferList.prototype._reverseOffset = function (blOffset) {
    const bufferId = blOffset[0]
    let offset = blOffset[1]

    for (let i = 0; i < bufferId; i++) {
      offset += this._bufs[i].length
    }

    return offset
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L56
  BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
      return undefined
    }

    const offset = this._offset(index)

    return this._bufs[offset[0]][offset[1]]
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L66
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === 'number' && start < 0) {
      start += this.length
    }

    if (typeof end === 'number' && end < 0) {
      end += this.length
    }

    return this.copy(null, 0, start, end)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L78
  BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== 'number' || srcStart < 0) {
      srcStart = 0
    }

    if (typeof srcEnd !== 'number' || srcEnd > this.length) {
      srcEnd = this.length
    }

    if (srcStart >= this.length) {
      return dst || Buffer.alloc(0)
    }

    if (srcEnd <= 0) {
      return dst || Buffer.alloc(0)
    }

    const copy = !!dst
    const off = this._offset(srcStart)
    const len = srcEnd - srcStart
    let bytes = len
    let bufoff = (copy && dstStart) || 0
    let start = off[1]

    // copy/slice everything
    if (srcStart === 0 && srcEnd === this.length) {
      if (!copy) {
        // slice, but full concat if multiple buffers
        return this._bufs.length === 1
          ? this._bufs[0]
          : util_Buffer.concat(this._bufs, this.length)
      }

      // copy, need to copy individual buffers
      for (let i = 0; i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff)
        bufoff += this._bufs[i].length
      }

      return dst
    }

    // easy, cheap case where it's a subset of one of the buffers
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy
        ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)
        : this._bufs[off[0]].slice(start, start + bytes)
    }

    if (!copy) {
      // a slice, we need something to copy in to
      dst = Buffer.allocUnsafe(len)
    }

    for (let i = off[0]; i < this._bufs.length; i++) {
      const l = this._bufs[i].length - start

      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start)
        bufoff += l
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes)
        bufoff += l
        break
      }

      bytes -= l

      if (start) {
        start = 0
      }
    }

    // safeguard so that we don't return uninitialized memory
    if (dst.length > bufoff) return dst.slice(0, bufoff)

    return dst
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L157
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0
    end = typeof end !== 'number' ? this.length : end

    if (start < 0) {
      start += this.length
    }

    if (end < 0) {
      end += this.length
    }

    if (start === end) {
      return this._new()
    }

    const startOffset = this._offset(start)
    const endOffset = this._offset(end)
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)

    if (endOffset[1] === 0) {
      buffers.pop()
    } else {
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])
    }

    if (startOffset[1] !== 0) {
      buffers[0] = buffers[0].slice(startOffset[1])
    }

    return this._new(buffers)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L190
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L194
  BufferList.prototype.consume = function consume(bytes) {
    // first, normalize the argument, in accordance with how Buffer does it
    bytes = Math.trunc(bytes)
    // do nothing if not a positive number
    if (Number.isNaN(bytes) || bytes <= 0) return this

    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length
        this.length -= this._bufs[0].length
        this._bufs.shift()
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes)
        this.length -= bytes
        break
      }
    }

    return this
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L215
  BufferList.prototype.duplicate = function duplicate() {
    const copy = this._new()

    for (let i = 0; i < this._bufs.length; i++) {
      copy.append(this._bufs[i])
    }

    return copy
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L225
  BufferList.prototype.append = function append(buf) {
    if (buf == null) {
      return this
    }

    if (buf.buffer) {
      // append a view of the underlying ArrayBuffer
      this._appendBuffer(util_Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))
    } else if (Array.isArray(buf)) {
      for (let i = 0; i < buf.length; i++) {
        this.append(buf[i])
      }
    } else if (this._isBufferList(buf)) {
      // unwrap argument into individual BufferLists
      for (let i = 0; i < buf._bufs.length; i++) {
        this.append(buf._bufs[i])
      }
    } else {
      // coerce number arguments to strings, since Buffer(number) does
      // uninitialized memory allocation
      if (typeof buf === 'number') {
        buf = buf.toString()
      }

      this._appendBuffer(util_Buffer.from(buf))
    }

    return this
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L255
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf)
    this.length += buf.length
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L260
  BufferList.prototype.indexOf = function (search, offset, encoding) {
    if (encoding === undefined && typeof offset === 'string') {
      encoding = offset
      offset = undefined
    }

    if (typeof search === 'function' || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
    } else if (typeof search === 'number') {
      search = util_Buffer.from([search])
    } else if (typeof search === 'string') {
      search = util_Buffer.from(search, encoding)
    } else if (this._isBufferList(search)) {
      search = search.slice()
    } else if (Array.isArray(search.buffer)) {
      search = util_Buffer.from(search.buffer, search.byteOffset, search.byteLength)
    } else if (!Buffer.isBuffer(search)) {
      search = util_Buffer.from(search)
    }

    offset = Number(offset || 0)

    if (isNaN(offset)) {
      offset = 0
    }

    if (offset < 0) {
      offset = this.length + offset
    }

    if (offset < 0) {
      offset = 0
    }

    if (search.length === 0) {
      return offset > this.length ? this.length : offset
    }

    const blOffset = this._offset(offset)
    let blIndex = blOffset[0] // index of which internal buffer we're working on
    let buffOffset = blOffset[1] // offset of the internal buffer we're working on

    // scan over each buffer
    for (; blIndex < this._bufs.length; blIndex++) {
      const buff = this._bufs[blIndex]

      while (buffOffset < buff.length) {
        const availableWindow = buff.length - buffOffset

        if (availableWindow >= search.length) {
          const nativeSearchResult = buff.indexOf(search, buffOffset)

          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult])
          }

          buffOffset = buff.length - search.length + 1 // end of native search window
        } else {
          const revOffset = this._reverseOffset([blIndex, buffOffset])

          if (this._match(revOffset, search)) {
            return revOffset
          }

          buffOffset++
        }
      }

      buffOffset = 0
    }

    return -1
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L334
  BufferList.prototype._match = function (offset, search) {
    if (this.length - offset < search.length) {
      return false
    }

    for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false
      }
    }
    return true
  }

    //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L347
    ; (function () {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      }

      for (const m in methods) {
        (function (m) {
          if (methods[m] === null) {
            BufferList.prototype[m] = function (offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m](0, byteLength)
            }
          } else {
            BufferList.prototype[m] = function (offset = 0) {
              return this.slice(offset, offset + methods[m])[m](0)
            }
          }
        }(m))
      }
    }())

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L388
  BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList || BufferList.isBufferList(b)
  }

  //https://github.com/rvagg/bl/blob/f7a00711cbf04a20d42f7aebfe2fa948390b9ccd/BufferList.js#L392
  BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[symbol]
  }

  // No license(?)
  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/util/bases.js#L15
  function createCodec(name, prefix, encode, decode) {
    return {
      name,
      prefix,
      encoder: {
        name,
        prefix,
        encode
      },
      decoder: { decode }
    };
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/util/bases.js#L30
  const string = createCodec('utf8', 'u', buf => {
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
  }, str => {
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/util/bases.js#L63
  var bases = {
    utf8: string,
    'utf-8': string,
  };

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/to-string.js#L18
  function uint8ArrayToString(array, encoding = 'utf8') {
    const base = bases[encoding];
    if (!base) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
    }
    return base.encoder.encode(array).substring(1);
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/alloc.js#L24
  function allocUnsafe(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
      return globalThis.Buffer.allocUnsafe(size);
    }
    return new Uint8Array(size);
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/concat.js#L9
  function uint8ArrayConcat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = allocUnsafe(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/compare.js#L7
  function uint8ArrayCompare(a, b) {
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] < b[i]) {
        return -1
      }

      if (a[i] > b[i]) {
        return 1
      }
    }

    if (a.byteLength > b.byteLength) {
      return 1
    }

    if (a.byteLength < b.byteLength) {
      return -1
    }

    return 0
  }

  //https://github.com/achingbrain/uint8arrays/blob/56329d16d6ca575c9638f3abb9601b8a034783b8/src/from-string.js#L18
  function uint8ArrayFromString(string, encoding = 'utf8') {
    const base = bases[encoding]

    if (!base) {
      throw new Error(`Unsupported encoding "${encoding}"`)
    }

    return base.decoder.decode(`${base.prefix}${string}`)
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multihash/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/constants.js#L18
  const mh_names = Object.freeze({
    'sha2-256': 0x12,
  })

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L13
  const mh_codes = /** @type {import('./types').CodeNameMap} */({})
  for (const key in mh_names) {
    const name = /** @type {HashName} */(key)
    mh_codes[mh_names[name]] = name
  }
  Object.freeze(mh_codes)

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L28
  function mh_toHexString(hash) {
    if (!(hash instanceof Uint8Array)) {
      throw new Error('must be passed a Uint8Array')
    }

    return uint8ArrayToString(hash, 'base16')
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L42
  function mh_fromHexString(hash) {
    return uint8ArrayFromString(hash, 'base16')
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L52
  function mh_toB58String(hash) {
    if (!(hash instanceof Uint8Array)) {
      throw new Error('must be passed a Uint8Array')
    }
    return uint8ArrayToString(multibase_encode('base58btc', hash)).slice(1)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L66
  function mh_fromB58String(hash) {
    const encoded = hash instanceof Uint8Array
      ? uint8ArrayToString(hash)
      : hash

    return multibase_decode('z' + encoded)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L80
  function mh_decode(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      throw new Error('multihash must be a Uint8Array')
    }

    if (bytes.length < 2) {
      throw new Error('multihash too short. must be > 2 bytes.')
    }

    const code = /** @type {HashCode} */(decode_2(bytes))
    if (!mh_isValidCode(code)) {
      throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
    }
    bytes = bytes.slice(decode_2.bytes)

    const len = decode_2(bytes)
    if (len < 0) {
      throw new Error(`multihash invalid length: ${len}`)
    }
    bytes = bytes.slice(decode_2.bytes)

    if (bytes.length !== len) {
      throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`)
    }

    return {
      code,
      name: mh_codes[code],
      length: len,
      digest: bytes
    }
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L123
  function mh_encode(digest, code, length) {
    if (!digest || code === undefined) {
      throw new Error('multihash encode requires at least two args: digest, code')
    }
    const hashfn = mh_coerceCode(code)

    if (!(digest instanceof Uint8Array)) {
      throw new Error('digest should be a Uint8Array')
    }

    if (length == null) {
      length = digest.length
    }

    if (length && digest.length !== length) {
      throw new Error('digest length should be equal to specified length.')
    }

    function alloc_allocUnsafe(size = 0) {
      if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return globalThis.Buffer.allocUnsafe(size);
      }
      return new Uint8Array(size);
    }

    const hash = encode_2(hashfn)
    const len = encode_2(length)
    function uint8ArrayConcat(arrays, length) {
      if (!length) {
        length = arrays.reduce((acc, curr) => acc + curr.length, 0);
      }
      const output = alloc_allocUnsafe(length);
      let offset = 0;
      for (const arr of arrays) {
        output.set(arr, offset);
        offset += arr.length;
      }
      return output;
    }
    return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L155
  function mh_coerceCode(name) {
    let code = name

    if (typeof name === 'string') {
      if (mh_names[name] === undefined) {
        throw new Error(`Unrecognized hash function named: ${name}`)
      }
      code = mh_names[name]
    }

    if (typeof code !== 'number') {
      throw new Error(`Hash function code should be a number. Got: ${code}`)
    }

    if (mh_codes[code] === undefined && !mh_isAppCode(code)) {
      throw new Error(`Unrecognized function code: ${code}`)
    }

    return code
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L183
  function mh_isAppCode(code) {
    return code > 0 && code < 0x10
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L212
  function mh_validate(multihash) {
    mh_decode(multihash)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L223
  function mh_prefix(multihash) {
    mh_validate(multihash)

    return multihash.subarray(0, 2)
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L193
  function mh_isValidCode(code) {
    if (mh_isAppCode(code)) {
      return true
    }

    if (mh_codes[code]) {
      return true
    }

    return false
  }

  //https://github.com/multiformats/js-multihash/blob/98ebff7e248bc842fbdfb22b14b58fb9c8679f96/src/index.js#L229
  const multihash = {
    mh_names,
    mh_codes,
    mh_toHexString,
    mh_fromHexString,
    mh_toB58String,
    mh_fromB58String,
    mh_decode,
    mh_encode,
    mh_coerceCode,
    mh_isAppCode,
    mh_validate,
    mh_prefix,
    mh_isValidCode
  }


  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020 Protocol Labs
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multihashing-async/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L21
  async function Multihashing(bytes, alg, length) {
    const digest = await Multihashing.digest(bytes, alg, length)
    return multihash.mh_encode(digest, alg, length)
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L29
  Multihashing.multihash = multihash

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L37
  Multihashing.digest = async (bytes, alg, length) => {
    const hash = Multihashing.createHash(alg)
    const digest = await hash(bytes)
    return length ? digest.slice(0, length) : digest
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L49
  Multihashing.createHash = function (alg) {
    if (!alg) {
      const e = errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED')
      throw e
    }
    const code = multihash.mh_coerceCode(alg)
    if (!Multihashing.functions[code]) {
      throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED')
    }
    return Multihashing.functions[code]
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/sha.js#L21
  const digest = async (data, alg) => {
    switch (alg) {
      case 'sha2-256':
        return createHash('sha256').update(data).digest()
      default:
        throw new Error(`${alg} is not a supported algorithm`)
    }
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/sha.js#L38
  const { factory: sha } = {
    factory: (alg) => async (data) => {
      return digest(data, alg)
    },
    digest,
    multihashing: async (buf, alg, length) => {
      const h = await digest(buf, alg)
      return multihash.encode(h, alg, length)
    }
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/crypto.js#L53
  var crypto = {
    sha2256: sha('sha2-256'),
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L69
  Multihashing.functions = {
    0x12: crypto.sha2256,
  }

  //https://github.com/multiformats/js-multihashing-async/blob/52b2c2b61a16a94ba0a93548209f85a01cffb5dc/src/index.js#L114
  Multihashing.validate = async (bytes, hash) => {
    const newHash = await Multihashing(bytes, multihash.decode(hash).name)
    return equals(hash, newHash)
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2020 Protocol Labs Inc
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multibase/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/base.js#L3
  const encodeText = (text) => textEncoder.encode(text)

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/base.js#L13
  class Base {
    constructor(name, code, factory, alphabet) {
      this.name = name
      this.code = code
      this.codeBuf = encodeText(this.code)
      this.alphabet = alphabet
      this.codec = factory(alphabet)
    }
    encode(buf) {
      return this.codec.encode(buf)
    }
    decode(string) {
      for (const char of string) {
        if (this.alphabet && this.alphabet.indexOf(char) < 0) {
          throw new Error(`invalid character '${char}' in '${string}'`)
        }
      }
      return this.codec.decode(string)
    }
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/rfc4648.js#L104
  const rfc4648_1 = (bitsPerChar) => (alphabet) => {
    return {
      encode(input) {
        return _encode(input, alphabet, bitsPerChar)
      },
      decode(input) {
        return _decode(input, alphabet, bitsPerChar)
      }
    }
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/constants.js#L27
  const constants = [
    ['base32', 'b', rfc4648_1(5), 'abcdefghijklmnopqrstuvwxyz234567'],
    ['base58btc', 'z', _basex, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
  ]

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/constants.js#L54
  const constants1_names = constants.reduce((prev, tupple) => {
    prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
    return prev
  }, /** @type {Record<BaseName,Base>} */({}))

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/constants.js#L59
  const constants1_codes = constants.reduce((prev, tupple) => {
    prev[tupple[1]] = constants1_names[tupple[0]]
    return prev
  }, /** @type {Record<BaseCode,Base>} */({}))

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L115
  function encoding(nameOrCode) {
    if (Object.prototype.hasOwnProperty.call(constants1_names, /** @type {BaseName} */(nameOrCode))) {
      return constants1_names[/** @type {BaseName} */(nameOrCode)]
    } else if (Object.prototype.hasOwnProperty.call(constants1_codes, /** @type {BaseCode} */(nameOrCode))) {
      return constants1_codes[/** @type {BaseCode} */(nameOrCode)]
    } else {
      throw new Error(`Unsupported encoding: ${nameOrCode}`)
    }
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/util.js#L24
  function concat(arrs, length) {
    const output = new Uint8Array(length)
    let offset = 0

    for (const arr of arrs) {
      output.set(arr, offset)
      offset += arr.length
    }

    return output
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/util.js#L3
  const textDecoder = new TextDecoder()
  const decodeText = (bytes) => textDecoder.decode(bytes)

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L103
  function validEncode(name, buf) {
    const enc = encoding(name)
    enc.decode(decodeText(buf))
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L23
  function multibase(nameOrCode, buf) {
    if (!buf) {
      throw new Error('requires an encoded Uint8Array')
    }
    const { name, codeBuf } = encoding(nameOrCode)
    validEncode(name, buf)

    return concat([codeBuf, buf], codeBuf.length + buf.length)
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L42
  function multibase_encode(nameOrCode, buf) {
    const enc = encoding(nameOrCode)
    const data = encodeText(enc.encode(buf))

    return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)
  }

  //https://github.com/multiformats/js-multibase/blob/f3a4e2dd0c0090b44bb0af67336594122ec930e2/src/index.js#L58
  function multibase_decode(data) {
    if (data instanceof Uint8Array) {
      data = decodeText(data)
    }
    const prefix = data[0]
    if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
      data = data.toLowerCase()
    }
    const enc = encoding(/** @type {BaseCode} */(data[0]))
    return enc.decode(data.substring(1))
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (c) 2016 Friedel Ziegelmayer
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-cid/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-cid/blob/2ed9449c7a7d2df522485822ae46f2d8d10fbbcc/src/cid-util.js#L5
  const CIDUtil = {
    checkCIDComponents: function (other) {
      if (other == null) {
        return 'null values are not valid CIDs'
      }

      if (!(other.version === 0 || other.version === 1)) {
        return 'Invalid version, must be a number equal to 1 or 0'
      }

      if (typeof other.codec !== 'string') {
        return 'codec must be string'
      }

      if (other.version === 0) {
        if (other.codec !== 'dag-pb') {
          return "codec must be 'dag-pb' for CIDv0"
        }
        if (other.multibaseName !== 'base58btc') {
          return "multibaseName must be 'base58btc' for CIDv0"
        }
      }

      if (!(other.multihash instanceof Uint8Array)) {
        return 'multihash must be a Uint8Array'
      }

      try {
        var mh = multihash
        mh.mh_validate(other.multihash)
      } catch (err) {
        let errorMsg = err.message
        if (!errorMsg) { // Just in case mh.validate() throws an error with empty error message
          errorMsg = 'Multihash validation failed'
        }
        return errorMsg
      }
    }
  }

  //https://github.com/multiformats/js-cid/blob/2ed9449c7a7d2df522485822ae46f2d8d10fbbcc/src/index.js#L38
  class CID1 {
    constructor(version, codec, multihash, multibaseName) {
      this.version
      this.codec
      this.multihash

      Object.defineProperty(this, symbol, { value: true })
      if (CID1.isCID(version)) {
        const cid = /** @type {CID1} */(version)
        this.version = cid.version
        this.codec = cid.codec
        this.multihash = cid.multihash
        this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32')
        return
      }

      this.version = version

      this.codec = /** @type {CodecName} */ (codec)
      this.multihash = /** @type {Uint8Array} */ (multihash)
      this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32')

      CID1.validateCID(this)
    }

    get bytes() {
      let bytes = this._bytes

      if (!bytes) {
        if (this.version === 0) {
          bytes = this.multihash
        } else if (this.version === 1) {
          const codec = multicodec.getCodeVarint(this.codec)
          bytes = uint8ArrayConcat([
            [1], codec, this.multihash
          ], 1 + codec.byteLength + this.multihash.byteLength)
        } else {
          throw new Error('unsupported version')
        }
        Object.defineProperty(this, '_bytes', { value: bytes })
      }

      return bytes
    }

    toBaseEncodedString(base = this.multibaseName) {
      if (this.string && this.string.length !== 0 && base === this.multibaseName) {
        return this.string
      }
      let str
      if (this.version === 0) {
        if (base !== 'base58btc') {
          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()')
        }
        str = multihash.mh_toB58String(this.multihash)
      } else if (this.version === 1) {
        str = uint8ArrayToString(multibase_encode(base, this.bytes))
      } else {
        throw new Error('unsupported version')
      }
      if (base === this.multibaseName) {
        // cache the string value
        Object.defineProperty(this, 'string', { value: str })
      }
      return str
    }

    toString(base) {
      return this.toBaseEncodedString(base)
    }

    static validateCID(other) {
      const errorMsg = CIDUtil.checkCIDComponents(other)
      if (errorMsg) {
        throw new Error(errorMsg)
      }
    }

    static isCID(value) {
      return value instanceof CID1 || Boolean(value && value[symbol])
    }
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright  2016 Multiformats
  *  Licensed under the MIT License.
  *  https://github.com/multiformats/js-multicodec/blob/master/LICENSE
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/util.js#L17
  function uint8ArrayToNumber(buf) {
    return parseInt(uint8ArrayToString(buf, 'base16'), 16)
  }

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/util.js#L35
  function varintUint8ArrayEncode(input) {
    return Uint8Array.from(encode_2(uint8ArrayToNumber(input)))
  }

  const baseTable = Object.freeze({
    'raw': CODE_RAW,
    'dag-pb': CODE_DAG_PB,
  })

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/util.js#L42
  function varintEncode(num) {
    return Uint8Array.from(encode_2(num))
  }

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/maps.js#L12
  const nameToVarint = /** @type {NameUint8ArrayMap} */ ({})
  const constantToCode = /** @type {ConstantCodeMap} */({})
  const codeToName = /** @type {CodeNameMap} */({})

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/index.js#L111
  function getVarintFromName(name) {
    const code = nameToVarint[name]
    if (code === undefined) {
      throw new Error(`Codec "${name}" not found`)
    }
    return code
  }

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/maps.js#L17
  for (const name in baseTable) {
    const codecName = /** @type {CodecName} */(name)
    const code = baseTable[codecName]
    nameToVarint[codecName] = varintEncode(code)

    const constant = /** @type {CodecConstant} */(codecName.toUpperCase().replace(/-/g, '_'))
    constantToCode[constant] = code

    if (!codeToName[code]) {
      codeToName[code] = codecName
    }
  }

  //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/maps.js#L30
  Object.freeze(nameToVarint)
  Object.freeze(constantToCode)
  Object.freeze(codeToName)

  const multicodec = {
    //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/index.js#L29
    addPrefix: function addPrefix(multicodecStrOrCode, data) {
      let prefix

      if (multicodecStrOrCode instanceof Uint8Array) {
        prefix = varintUint8ArrayEncode(multicodecStrOrCode)
      } else {
        if (nameToVarint[multicodecStrOrCode]) {
          prefix = nameToVarint[multicodecStrOrCode]
        } else {
          throw new Error('multicodec not recognized')
        }
      }

      return uint8ArrayConcat([prefix, data], prefix.length + data.length)
    },
    //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/index.js#L51
    rmPrefix: function rmPrefix(data) {
      varint.decode(/** @type {Buffer} */(data))
      return data.slice(varint.decode.bytes)
    },
    //https://github.com/multiformats/js-multicodec/blob/2945d8b4f65552cb93ae60892f69ee6fac24b359/src/index.js#L77
    getCodeVarint: function getCodeVarint(name) {
      return getVarintFromName(name)
    },
  }

  /*---------------------------------------------------------------------------------------------
  *  Copyright (C) 2018 Angry Bytes and contributors.
  *  https://github.com/Two-Screen/stable/blob/master/README.md
  *--------------------------------------------------------------------------------------------*/

  //https://github.com/Two-Screen/stable/blob/fff2be6088a96c9613e3799cb966c912c6d6fcb7/stable.js#L31
  function exec(arr, comp) {
    if (typeof (comp) !== 'function') {
      comp = function (a, b) {
        return String(a).localeCompare(b)
      };
    }
    var len = arr.length;
    if (len <= 1) {
      return arr
    }
    var buffer = new Array(len);
    for (var chk = 1; chk < len; chk *= 2) {
      pass(arr, comp, chk, buffer);

      var tmp = arr;
      arr = buffer;
      buffer = tmp;
    }

    return arr
  }

  //https://github.com/Two-Screen/stable/blob/fff2be6088a96c9613e3799cb966c912c6d6fcb7/stable.js#L60
  var pass = function (arr, comp, chk, result) {
    var len = arr.length;
    var i = 0;
    // Step size / double chunk size.
    var dbl = chk * 2;
    // Bounds of the left and right chunks.
    var l, r, e;
    // Iterators over the left and right chunk.
    var li, ri;

    // Iterate over pairs of chunks.
    for (l = 0; l < len; l += dbl) {
      r = l + chk;
      e = r + chk;
      if (r > len) r = len;
      if (e > len) e = len;

      // Iterate both chunks in parallel.
      li = l;
      ri = r;
      while (true) {
        // Compare the chunks.
        if (li < r && ri < e) {
          // This works for a regular `sort()` compatible comparator,
          // but also for a simple comparator like: `a > b`
          if (comp(arr[li], arr[ri]) <= 0) {
            result[i++] = arr[li++];
          }
          else {
            result[i++] = arr[ri++];
          }
        }
        // Nothing to compare, just flush what's left.
        else if (li < r) {
          result[i++] = arr[li++];
        }
        else if (ri < e) {
          result[i++] = arr[ri++];
        }
        // Both iterators are at the chunk ends.
        else {
          break
        }
      }
    }
  };

  //https://github.com/Two-Screen/stable/blob/fff2be6088a96c9613e3799cb966c912c6d6fcb7/stable.js#L13
  var stable = function (arr, comp) {
    return exec(arr.slice(), comp)
  };

  //https://github.com/Two-Screen/stable/blob/fff2be6088a96c9613e3799cb966c912c6d6fcb7/stable.js#L17
  stable.inplace = function (arr, comp) {
    var result = exec(arr, comp);

    if (result !== arr) {
      pass(result, null, arr.length, arr);
    }

    return arr
  };

  const globalThis = this;
  
  async function hashChunk(data, version){
    let size = data.length;
    const dataSize = data.length;
    let multihash;
    if (version == 0){
      const unixFS = new UnixFS({
        type: 'file',
        data: data
      })
      let bytes = d_encode({
        Data: unixFS.marshal(),
        Links: []
      })
      multihash = await Multihashing(bytes, 'sha2-256')
      size = bytes.length;
    }
    else{
      multihash = await Multihashing(data, 'sha2-256') // buffer is [Uint8Array]
    };
    let codec = version==1?'raw':'dag-pb';
    const cid = new CID1(version, codec, multihash)
    return {
      size: size,
      dataSize: dataSize,
      cid: cid
    };
  };
  async function hashChunks(chunks, version){
    let contentLength = 0;
    const unixfs = new UnixFS({
      type: 'file'
    });
    let links = [];
    for (let i = 0; i < chunks.length; i++) {
      let item = chunks[i];
      contentLength += (item.dataSize || item.size);      
      unixfs.addBlockSize(item.dataSize || item.size);
      let cid = item.cid
      if (typeof(cid) == 'string'){
        let parsed = parse(item.cid);
        cid = new CID1(version, 'raw', parsed.multihash.bytes)
      };
      links.push(new DAGLink('', item.size, cid))
    };
    const node = new DAGNode(unixfs.marshal(), links)
    const buffer = node.serialize();
    const multihash = await Multihashing(buffer, 'sha2-256') // buffer is [Uint8Array]
    const cid = new CID1(version, 'dag-pb', multihash)
    return {
      size: buffer.length + contentLength,
      type: 'file',
      cid: cid.toString(),
      bytes: buffer
    };
  };
  async function hashItems(items, version){
    if (version == undefined)
      version = 1;
    let Links = [];
    for (let i = 0; i < items.length; i++) {
      let item = items[i];
      Links.push({
        Name: item.name,
        Hash: parse(item.cid),
        Tsize: item.size
      })
    };
    Links.sort(linkComparator);
    try {
      const dirUnixFS = new UnixFS({
        type: 'directory',
        mtime: undefined,
        mode: 493
      });
      const node = {
        Data: dirUnixFS.marshal(),
        Links
      };
      const bytes = d_encode(node);
      const hash = await s_sha256.digest(bytes);
      // const cid = CID.create(version, RAW_CODE, hash);
      const cid = CID.create(version, CODE_DAG_PB, hash).toString();
      return {
        size: bytes.length + Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0),
        code: CODE_DAG_PB,
        name: '',
        type: 'dir',
        links: items,
        cid: cid,
        bytes: bytes
      }
    } catch (e) {
      throw e;
    }
  };
  function parse(cid, bytes) {
    let result = CID.parse(cid);
    if (bytes){
      let decoded = d_decode(bytes);
      result.links = decoded.Links;
      if (result.code == CODE_DAG_PB)
          result.size = bytes.length + decoded.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
      if (decoded.Data){
        decoded.Data = UnixFS.unmarshal(decoded.Data)
        result.type = decoded.Data.type;
        // if (result.type == 'directory')
        // else if(result.type == 'file' && result.code == CODE_DAG_PB){
        //   result.size = result.size || (decoded.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0))
        // };
      };
    };
    return result;
  };
  async function hashContent(content, version) {
    // let buffer = [];
    let items = [];
    let contentLength = 0;
    if (typeof content === 'string') {
      content = new TextEncoder("utf-8").encode(content)
      // // new TextEncoder("utf-8").encode(value);
      // let chunkSize = 1048576;
      // if (version == 0){
      //   chunkSize = 262144;
      //   let offset = 0  
      //   const size = Math.ceil(content.length/chunkSize);
      //   for (let i = 0; i < size; i++) {
      //     let data = textEncoder.encode(content.substr(offset, chunkSize));
      //     contentLength += data.length;
      //     items.push(await hashChunk(data, version));
      //     offset += chunkSize;
      //   }
      // }
      // else{
      //   content = new TextEncoder("utf-8").encode(content);

      // }
    }
    if (content instanceof Uint8Array){
      let chunkSize = 1048576;
      if (version == 0)
        chunkSize = 262144;

      let offset = 0  
      const size = Math.ceil(content.length/chunkSize)
      for (let i = 0; i < size; i++) {
        let data = content.slice(offset, offset + chunkSize);
        contentLength += data.length;
        items.push(await hashChunk(data, version));
        offset += chunkSize;
      }
    }
    else{
      for await (const data of content) {
        // buffer.push(data);
        contentLength += data.length;
        items.push(await hashChunk(data, version));
      };
    };
    if (items.length == 1){
      return {
        size: contentLength,
        type: 'file',
        code: CODE_RAW,
        cid: items[0].cid.toString()
      };
    }
    else{
      let result= await hashChunks(items, version);
      let links = [];
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        links.push({
          cid: item.cid.toString(),
          size: item.size
        })
      };
      return {
        cid: result.cid,
        size: result.size,
        code: CODE_DAG_PB,
        type: 'file',
        bytes: result.bytes,
        links: links
      };
    }
  };
  function base64Encode(binaryInput){
    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    let result = '';
    if (binaryInput.length % 3 === 1) {
      binaryInput += '00';
    } else if (binaryInput.length % 3 === 2) {
      binaryInput += '0';
    };
    for (let i = 0; i < binaryInput.length; i += 6) {
      const chunk = binaryInput.slice(i, i + 6);
      const decimalValue = parseInt(chunk, 2);
      result += base64Chars.charAt(decimalValue);
    };
    const padding = calculatePadding(result);
    result += '='.repeat(padding);
    return result;
  };
  function calculatePadding(inputNumber) {
    const inputLength = inputNumber.toString().length;
    const nextMultipleOf4 = Math.ceil(inputLength / 4) * 4;
    const difference = nextMultipleOf4 - inputLength;
    return difference;
  };
  function hexToBinary(hexString){
    return hexString
      .split('')
      .map(hex => parseInt(hex, 16).toString(2).padStart(4, '0'))
      .join('');
  };
  function cidToHash(cid) {
    const parsedCid = parse(cid);
    const hashBuffer = Buffer.from(parsedCid.multihash.bytes);
    const hashHex = Array.from(hashBuffer.slice(2)).map(byte => byte.toString(16).toUpperCase().padStart(2, '0')).join('');
    const binaryInput = hexToBinary(hashHex);
    return base64Encode(binaryInput);
  };
  // AMD
  if (typeof define == 'function' && define.amd)
    define('@ijstech/ipfs-utils', function () { return {cidToHash, parse, hashChunk, hashChunks, hashItems, hashContent }; })
  // Node.js
  else if (typeof module != 'undefined' && module.exports)
    module.exports = {cidToHash, parse, hashChunk, hashChunks, hashItems, hashContent }
  // Browser
  else {
    if (!globalObject)
      globalObject = typeof self != 'undefined' && self ? self : window;
    globalObject.IPFSUtils = {cidToHash, parse, hashChunk, hashChunks, hashItems, hashContent };
  };
})(this);
/*! @license DOMPurify 3.0.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.0.1/LICENSE */

(function (global, factory) {
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DOMPurify = factory());
})(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var entries = Object.entries,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return _construct(Func, _toConsumableArray(args));
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);
  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringToString = unapply(String.prototype.toString);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);
  var regExpTest = unapply(RegExp.prototype.test);
  var typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }
  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }
  /* Add properties to a lookup table */

  function addToSet(set, array, transformCaseFunc) {
    transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;

    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;

    while (l--) {
      var element = array[l];

      if (typeof element === 'string') {
        var lcElement = transformCaseFunc(element);

        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }
  /* Shallow clone an object */

  function clone(object) {
    var newObject = create(null);

    var _iterator = _createForOfIteratorHelper(entries(object)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            property = _step$value[0],
            value = _step$value[1];

        newObject[property] = value;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return newObject;
  }
  /* This method automatically checks if the prop is function
   * or getter and behaves accordingly. */

  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);

      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']); // SVG

  var svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']); // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.

  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
  var mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']); // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.

  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
  var text = freeze(['#text']);

  var html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);
  var svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
  var mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode

  var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  var TMPLIT_EXPR = seal(/\${[\w\W]*}/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape

  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape

  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );
  var DOCTYPE_NAME = seal(/^html$/i);

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };
  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */


  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if (_typeof(trustedTypes) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    } // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.


    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';

    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html) {
          return html;
        },
        createScriptURL: function createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };
    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */


    DOMPurify.version = '3.0.1';
    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */

    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;
      return DOMPurify;
    }

    var originalDocument = window.document;
    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === void 0 ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        HTMLFormElement = window.HTMLFormElement,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;
    var ElementPrototype = Element.prototype;
    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode'); // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.

    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');

      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);

    var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML('') : '';
    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;
    var hooks = {};
    /**
     * Expose whether this browser supports running the full DOMPurify.
     */

    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined';
    var MUSTACHE_EXPR$1 = MUSTACHE_EXPR,
        ERB_EXPR$1 = ERB_EXPR,
        TMPLIT_EXPR$1 = TMPLIT_EXPR,
        DATA_ATTR$1 = DATA_ATTR,
        ARIA_ATTR$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text)));
    /* Allowed attribute names */

    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html), _toConsumableArray(svg), _toConsumableArray(mathMl), _toConsumableArray(xml)));
    /*
     * Configure how DOMPUrify should handle custom elements and their attributes as well as customized built-in elements.
     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
     */

    var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */

    var FORBID_TAGS = null;
    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */

    var FORBID_ATTR = null;
    /* Decide if ARIA attributes are okay */

    var ALLOW_ARIA_ATTR = true;
    /* Decide if custom data attributes are okay */

    var ALLOW_DATA_ATTR = true;
    /* Decide if unknown protocols are okay */

    var ALLOW_UNKNOWN_PROTOCOLS = false;
    /* Decide if self-closing tags in attributes are allowed.
     * Usually removed due to a mXSS issue in jQuery 3.0 */

    var ALLOW_SELF_CLOSE_IN_ATTR = true;
    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */

    var SAFE_FOR_TEMPLATES = false;
    /* Decide if document with <html>... should be returned */

    var WHOLE_DOCUMENT = false;
    /* Track whether config is already set on this instance of DOMPurify. */

    var SET_CONFIG = false;
    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */

    var FORCE_BODY = false;
    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */

    var RETURN_DOM = false;
    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */

    var RETURN_DOM_FRAGMENT = false;
    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */

    var RETURN_TRUSTED_TYPE = false;
    /* Output should be free from DOM clobbering attacks?
     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
     */

    var SANITIZE_DOM = true;
    /* Achieve full DOM Clobbering protection by isolating the namespace of named
     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
     *
     * HTML/DOM spec rules that enable DOM Clobbering:
     *   - Named Access on Window (7.3.3)
     *   - DOM Tree Accessors (3.1.5)
     *   - Form Element Parent-Child Relations (4.10.3)
     *   - Iframe srcdoc / Nested WindowProxies (4.8.5)
     *   - HTMLCollection (4.2.10.2)
     *
     * Namespace isolation is implemented by prefixing `id` and `name` attributes
     * with a constant string, i.e., `user-content-`
     */

    var SANITIZE_NAMED_PROPS = false;
    var SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
    /* Keep element content when removing element? */

    var KEEP_CONTENT = true;
    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */

    var IN_PLACE = false;
    /* Allow usage of profiles like html, svg and mathMl */

    var USE_PROFILES = {};
    /* Tags to ignore content of when KEEP_CONTENT is true */

    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
    /* Tags that are safe for data: URIs */

    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
    /* Attributes safe for values like "javascript:" */

    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */

    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;
    /* Allowed XHTML+XML namespaces */

    var ALLOWED_NAMESPACES = null;
    var DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    /* Parsing of strict XHTML documents */

    var PARSER_MEDIA_TYPE;
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    var transformCaseFunc;
    /* Keep a reference to config to pass to hooks */

    var CONFIG = null;
    /* Ideally, do not touch anything below this line */

    /* ______________________________________________ */

    var formElement = document.createElement('form');

    var isRegexOrFunction = function isRegexOrFunction(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity


    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      /* Shield configuration object from tampering */


      if (!cfg || _typeof(cfg) !== 'object') {
        cfg = {};
      }
      /* Shield configuration object from prototype pollution */


      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE; // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.

      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
      /* Set configuration parameters */

      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), // eslint-disable-line indent
      cfg.ADD_URI_SAFE_ATTR, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), // eslint-disable-line indent
      cfg.ADD_DATA_URI_TAGS, // eslint-disable-line indent
      transformCaseFunc // eslint-disable-line indent
      ) // eslint-disable-line indent
      : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true

      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true

      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false

      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true

      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false

      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false

      RETURN_DOM = cfg.RETURN_DOM || false; // Default false

      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false

      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false

      FORCE_BODY = cfg.FORCE_BODY || false; // Default false

      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true

      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false

      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true

      IN_PLACE = cfg.IN_PLACE || false; // Default false

      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }

      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      /* Parse profile info */


      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, _toConsumableArray(text));
        ALLOWED_ATTR = [];

        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      /* Merge configuration parameters */


      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      /* Add #text in case KEEP_CONTENT is set to true */


      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }
      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */


      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }
      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */


      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      } // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.


      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']); // Certain elements are allowed in both SVG and HTML
    // namespace. We need to specify them explicitly
    // so that they don't get erroneously deleted from
    // HTML namespace.

    var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */

    var ALL_SVG_TAGS = addToSet({}, svg$1);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);
    var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */

    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element); // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.

      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        } // The only way to switch from MathML to SVG is via`
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.


        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        } // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.


        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        } // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points


        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        } // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.


        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        } // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace


        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      } // For XHTML and XML documents that support custom namespaces


      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      } // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
      // Return false just in case.


      return false;
    };
    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */


    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, {
        element: node
      });

      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        node.remove();
      }
    };
    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */


    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name); // We void attribute values for unremovable "is"" attributes

      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };
    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */


    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc;
      var leadingWhitespace;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */

      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }
      /* Use createHTMLDocument in case DOMParser is not available */


      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);

        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_) {// Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      /* Work on whole document or just its body */


      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */


    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };
    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */


    var _isClobbered = function _isClobbered(elm) {
      return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');
    };
    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */


    var _isNode = function _isNode(object) {
      return _typeof(Node) === 'object' ? object instanceof Node : object && _typeof(object) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };
    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */


    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };
    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */


    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeElements', currentNode, null);
      /* Check if element is clobbered or can clobber */


      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Now let's check the element's type and name */


      var tagName = transformCaseFunc(currentNode.nodeName);
      /* Execute a hook if present */

      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });
      /* Detect mXSS attempts abusing namespace confusion */


      if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Remove element if anything forbids its presence */


      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Check if we have a custom element to handle */
        if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;
        }
        /* Keep content except for bad-listed elements */


        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);

        return true;
      }
      /* Check whether element has a valid namespace */


      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Make sure that older browsers don't get noscript mXSS */


      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);

        return true;
      }
      /* Sanitize element content to be template-safe */


      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$1, ' ');
        content = stringReplace(content, ERB_EXPR$1, ' ');
        content = stringReplace(content, TMPLIT_EXPR$1, ' ');

        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content;
        }
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };
    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity


    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }
      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */


      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if ( // First condition does a very basic check if a) it's basically a valid custom element tagname AND
        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
        _basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND
        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
          return false;
        }
        /* Check value is safe. First, is attr inert? If so, is safe */

      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };
    /**
     * _basicCustomElementCheck
     * checks if at least one dash is included in tagName, and it's not the first char
     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
     * @param {string} tagName name of the tag of the node to sanitize
     */


    var _basicCustomElementTest = function _basicCustomElementTest(tagName) {
      return tagName.indexOf('-') > 0;
    };
    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */


    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr;
      var value;
      var lcName;
      var l;
      /* Execute a hook if present */

      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;
      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;
      /* Go backwards over all attributes; safely remove bad ones */

      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;
        value = name === 'value' ? attr.value : stringTrim(attr.value);
        lcName = transformCaseFunc(name);
        /* Execute a hook if present */

        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set

        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);

        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */

        if (hookEvent.forceKeepAttr) {
          continue;
        }
        /* Remove attribute */


        _removeAttribute(name, currentNode);
        /* Did the hooks approve of the attribute? */


        if (!hookEvent.keepAttr) {
          continue;
        }
        /* Work around a security issue in jQuery 3.0 */


        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);

          continue;
        }
        /* Sanitize attribute content to be template-safe */


        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$1, ' ');
          value = stringReplace(value, ERB_EXPR$1, ' ');
          value = stringReplace(value, TMPLIT_EXPR$1, ' ');
        }
        /* Is `value` valid for this attribute? */


        var lcTag = transformCaseFunc(currentNode.nodeName);

        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }
        /* Full DOM Clobbering protection via namespace isolation,
         * Prefix id and name attributes with `user-content-`
         */


        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
          // Remove the attribute with this value
          _removeAttribute(name, currentNode); // Prefix the value and later re-create the attribute with the sanitized value


          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        /* Handle attributes that require Trusted Types */


        if (trustedTypesPolicy && _typeof(trustedTypes) === 'object' && typeof trustedTypes.getAttributeType === 'function') {
          if (namespaceURI) ; else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case 'TrustedHTML':
                value = trustedTypesPolicy.createHTML(value);
                break;

              case 'TrustedScriptURL':
                value = trustedTypesPolicy.createScriptURL(value);
                break;
            }
          }
        }
        /* Handle invalid data-* attribute set by try-catching it */


        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeAttributes', currentNode, null);
    };
    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */


    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode;

      var shadowIterator = _createIterator(fragment);
      /* Execute a hook if present */


      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);
        /* Sanitize tags and elements */


        if (_sanitizeElements(shadowNode)) {
          continue;
        }
        /* Deep shadow DOM detected */


        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(shadowNode);
      }
      /* Execute a hook if present */


      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };
    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity


    DOMPurify.sanitize = function (dirty) {
      var cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var body;
      var importedNode;
      var currentNode;
      var returnNode;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */

      IS_EMPTY_INPUT = !dirty;

      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }
      /* Stringify, in case dirty is an object */


      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();

          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }
      /* Return dirty HTML if DOMPurify cannot run */


      if (!DOMPurify.isSupported) {
        return dirty;
      }
      /* Assign config vars */


      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      /* Clean up removed elements */


      DOMPurify.removed = [];
      /* Check if dirty is correctly typed for IN_PLACE */

      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) {
        /* Do some early pre-sanitization to avoid unsafe root nodes */
        if (dirty.nodeName) {
          var tagName = transformCaseFunc(dirty.nodeName);

          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
          }
        }
      } else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);

        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        /* Initialize the document to work on */


        body = _initDocument(dirty);
        /* Check we have a DOM node from the data */

        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
        }
      }
      /* Remove first element node (ours) if FORCE_BODY is set */


      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      /* Get node iterator */


      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
      /* Now start iterating over the created document */


      while (currentNode = nodeIterator.nextNode()) {
        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }
        /* Shadow DOM detected, sanitize it */


        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
        /* Check attributes, sanitize if necessary */


        _sanitizeAttributes(currentNode);
      }
      /* If we sanitized `dirty` in-place, return it. */


      if (IN_PLACE) {
        return dirty;
      }
      /* Return sanitized string or DOM */


      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmod) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      /* Serialize doctype if allowed */

      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
      }
      /* Sanitize final string template-safe */


      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, ' ');
        serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */


    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);

      SET_CONFIG = true;
    };
    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */


    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };
    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */


    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */


    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };
    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     * @return {Function} removed(popped) hook
     */


    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        return arrayPop(hooks[entryPoint]);
      }
    };
    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */


    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };
    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */


    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));
//# sourceMappingURL=purify.js.map

define("@ijstech/components",(require, exports)=>{
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key2 of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key2) && key2 !== "default")
        __defProp(target, key2, { get: () => module2[key2], enumerable: !(desc = __getOwnPropDesc(module2, key2)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __decorateClass = (decorators, target, key2, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key2) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key2, result);
  return result;
};

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend2(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend2(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment3(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment3 || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend2(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key2, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key2 in arguments[0]) {
                  if (hasOwnProp(arguments[0], key2)) {
                    arg += key2 + ": " + arguments[0][key2] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend2({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend2(res[prop], parentConfig[prop]);
              extend2(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend2({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key2, mom, now2) {
        var output = this._calendar[key2] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token2);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key2) {
        var format2 = this._longDateFormat[key2], formatUpper = this._longDateFormat[key2.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key2] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key2];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()));
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i");
            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i");
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i");
            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i");
            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i");
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i");
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key2) {
        return key2 ? key2.toLowerCase().replace("_", "-") : key2;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key2, values) {
        var data;
        if (key2) {
          if (isUndefined(values)) {
            data = getLocale(key2);
          } else {
            data = defineLocale(key2, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn("Locale " + key2 + " not found. Did you forget to load it?");
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info.");
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key2) {
        var locale2;
        if (key2 && key2._locale && key2._locale._abbr) {
          key2 = key2._locale._abbr;
        }
        if (!key2) {
          return globalLocale;
        }
        if (!isArray(key2)) {
          locale2 = loadLocale(key2);
          if (locale2) {
            return locale2;
          }
          key2 = [key2];
        }
        return chooseLocale(key2);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
      });
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
        if (configfLen === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend2(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment3(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment3(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      });
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key2, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key2 in m) {
          if (hasOwnProp(m, key2) && !(indexOf.call(ordering, key2) !== -1 && (m[key2] == null || !isNaN(m[key2])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + minutes2 * 6e4 + hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(this, createDuration(input - offset2, "m"), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key2) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key2) {
            duration[key2] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.");
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(output || this.localeData().calendar(format2, this, createLocal(now2)));
      }
      function clone() {
        return new Moment3(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ");
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key2) {
        var newLocaleData;
        if (key2 === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key2);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key2) {
        if (key2 === void 0) {
          return this.localeData();
        } else {
          return this.locale(key2);
        }
      });
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
            break;
          case "isoWeek":
            time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend2({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i");
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment3.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth);
      proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth);
      proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear);
      proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone);
      proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string) {
        return string;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale);
      hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        w: null,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1);
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        DATE: "YYYY-MM-DD",
        TIME: "HH:mm",
        TIME_SECONDS: "HH:mm:ss",
        TIME_MS: "HH:mm:ss.SSS",
        WEEK: "GGGG-[W]WW",
        MONTH: "YYYY-MM"
      };
      return hooks;
    });
  }
});

// src/index.ts
__export(exports, {
  Accordion: () => Accordion,
  AccordionItem: () => AccordionItem,
  Alert: () => Alert,
  BarChart: () => BarChart,
  Breadcrumb: () => Breadcrumb,
  Button: () => Button,
  CardLayout: () => CardLayout,
  CarouselSlider: () => CarouselSlider,
  Checkbox: () => Checkbox,
  ClearObservers: () => ClearObservers,
  CodeDiffEditor: () => CodeDiffEditor,
  CodeEditor: () => CodeEditor,
  ColorPicker: () => ColorPicker,
  ComboBox: () => ComboBox,
  Component: () => Component,
  Container: () => Container,
  ContextMenu: () => ContextMenu,
  Control: () => Control,
  DataGrid: () => DataGrid,
  DataGridCell: () => DataGridCell,
  DataSchemaValidator: () => DataSchemaValidator,
  Datepicker: () => Datepicker,
  EventBus: () => EventBus,
  Form: () => Form,
  FormatUtils: () => FormatUtils,
  GridLayout: () => GridLayout,
  HStack: () => HStack,
  IPFS: () => src_exports2,
  Icon: () => Icon,
  IdUtils: () => IdUtils,
  Iframe: () => Iframe,
  Image: () => Image2,
  Input: () => Input,
  Label: () => Label,
  LibPath: () => LibPath,
  LineChart: () => LineChart,
  Link: () => Link,
  Markdown: () => Markdown,
  MarkdownEditor: () => MarkdownEditor,
  Menu: () => Menu,
  MenuItem: () => MenuItem,
  Modal: () => Modal,
  Module: () => Module,
  Nav: () => Nav,
  Observe: () => Observe,
  Pagination: () => Pagination,
  Panel: () => Panel,
  PieChart: () => PieChart,
  Popover: () => Popover,
  Progress: () => Progress,
  Radio: () => Radio,
  RadioGroup: () => RadioGroup,
  Range: () => Range2,
  Repeater: () => Repeater,
  RequireJS: () => RequireJS,
  ScatterChart: () => ScatterChart,
  ScatterLineChart: () => ScatterLineChart,
  SchemaDesigner: () => SchemaDesigner,
  StackLayout: () => StackLayout,
  Styles: () => src_exports,
  Switch: () => Switch,
  Tab: () => Tab,
  Table: () => Table,
  TableCell: () => TableCell,
  TableColumn: () => TableColumn,
  Tabs: () => Tabs,
  Tooltip: () => Tooltip,
  TreeNode: () => TreeNode,
  TreeView: () => TreeView,
  Unobserve: () => Unobserve,
  Upload: () => Upload,
  UploadModal: () => UploadModal,
  VStack: () => VStack,
  Video: () => Video,
  application: () => application,
  customElements: () => customElements2,
  customModule: () => customModule,
  getCustomElements: () => getCustomElements,
  isObservable: () => isObservable,
  markdownToPlainText: () => markdownToPlainText,
  moment: () => moment,
  observable: () => observable,
  renderUI: () => renderUI
});

// packages/style/src/index.ts
var src_exports = {};
__export(src_exports, {
  Colors: () => Colors,
  Theme: () => theme_exports,
  cssRaw: () => cssRaw,
  cssRule: () => cssRule,
  fontFace: () => fontFace,
  keyframes: () => keyframes,
  rotate: () => rotate,
  style: () => style
});

// packages/style/src/theme.ts
var theme_exports = {};
__export(theme_exports, {
  ColorVars: () => ColorVars,
  Colors: () => Colors,
  ThemeVars: () => ThemeVars,
  applyTheme: () => applyTheme,
  currentTheme: () => currentTheme,
  darkTheme: () => darkTheme,
  defaultTheme: () => defaultTheme
});

// packages/style/src/colors.ts
var amber = {
  50: "#fff8e1",
  100: "#ffecb3",
  200: "#ffe082",
  300: "#ffd54f",
  400: "#ffca28",
  500: "#ffc107",
  600: "#ffb300",
  700: "#ffa000",
  800: "#ff8f00",
  900: "#ff6f00",
  A100: "#ffe57f",
  A200: "#ffd740",
  A400: "#ffc400",
  A700: "#ffab00"
};
var blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
var blueGrey = {
  50: "#eceff1",
  100: "#cfd8dc",
  200: "#b0bec5",
  300: "#90a4ae",
  400: "#78909c",
  500: "#607d8b",
  600: "#546e7a",
  700: "#455a64",
  800: "#37474f",
  900: "#263238",
  A100: "#cfd8dc",
  A200: "#b0bec5",
  A400: "#78909c",
  A700: "#455a64"
};
var brown = {
  50: "#efebe9",
  100: "#d7ccc8",
  200: "#bcaaa4",
  300: "#a1887f",
  400: "#8d6e63",
  500: "#795548",
  600: "#6d4c41",
  700: "#5d4037",
  800: "#4e342e",
  900: "#3e2723",
  A100: "#d7ccc8",
  A200: "#bcaaa4",
  A400: "#8d6e63",
  A700: "#5d4037"
};
var cyan = {
  50: "#e0f7fa",
  100: "#b2ebf2",
  200: "#80deea",
  300: "#4dd0e1",
  400: "#26c6da",
  500: "#00bcd4",
  600: "#00acc1",
  700: "#0097a7",
  800: "#00838f",
  900: "#006064",
  A100: "#84ffff",
  A200: "#18ffff",
  A400: "#00e5ff",
  A700: "#00b8d4"
};
var deepOrange = {
  50: "#fbe9e7",
  100: "#ffccbc",
  200: "#ffab91",
  300: "#ff8a65",
  400: "#ff7043",
  500: "#ff5722",
  600: "#f4511e",
  700: "#e64a19",
  800: "#d84315",
  900: "#bf360c",
  A100: "#ff9e80",
  A200: "#ff6e40",
  A400: "#ff3d00",
  A700: "#dd2c00"
};
var deepPurple = {
  50: "#ede7f6",
  100: "#d1c4e9",
  200: "#b39ddb",
  300: "#9575cd",
  400: "#7e57c2",
  500: "#673ab7",
  600: "#5e35b1",
  700: "#512da8",
  800: "#4527a0",
  900: "#311b92",
  A100: "#b388ff",
  A200: "#7c4dff",
  A400: "#651fff",
  A700: "#6200ea"
};
var green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
var grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
var indigo = {
  50: "#e8eaf6",
  100: "#c5cae9",
  200: "#9fa8da",
  300: "#7986cb",
  400: "#5c6bc0",
  500: "#3f51b5",
  600: "#3949ab",
  700: "#303f9f",
  800: "#283593",
  900: "#1a237e",
  A100: "#8c9eff",
  A200: "#536dfe",
  A400: "#3d5afe",
  A700: "#304ffe"
};
var lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
var lightGreen = {
  50: "#f1f8e9",
  100: "#dcedc8",
  200: "#c5e1a5",
  300: "#aed581",
  400: "#9ccc65",
  500: "#8bc34a",
  600: "#7cb342",
  700: "#689f38",
  800: "#558b2f",
  900: "#33691e",
  A100: "#ccff90",
  A200: "#b2ff59",
  A400: "#76ff03",
  A700: "#64dd17"
};
var lime = {
  50: "#f9fbe7",
  100: "#f0f4c3",
  200: "#e6ee9c",
  300: "#dce775",
  400: "#d4e157",
  500: "#cddc39",
  600: "#c0ca33",
  700: "#afb42b",
  800: "#9e9d24",
  900: "#827717",
  A100: "#f4ff81",
  A200: "#eeff41",
  A400: "#c6ff00",
  A700: "#aeea00"
};
var orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
var pink = {
  50: "#fce4ec",
  100: "#f8bbd0",
  200: "#f48fb1",
  300: "#f06292",
  400: "#ec407a",
  500: "#e91e63",
  600: "#d81b60",
  700: "#c2185b",
  800: "#ad1457",
  900: "#880e4f",
  A100: "#ff80ab",
  A200: "#ff4081",
  A400: "#f50057",
  A700: "#c51162"
};
var purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
var red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
var teal = {
  50: "#e0f2f1",
  100: "#b2dfdb",
  200: "#80cbc4",
  300: "#4db6ac",
  400: "#26a69a",
  500: "#009688",
  600: "#00897b",
  700: "#00796b",
  800: "#00695c",
  900: "#004d40",
  A100: "#a7ffeb",
  A200: "#64ffda",
  A400: "#1de9b6",
  A700: "#00bfa5"
};
var yellow = {
  50: "#fffde7",
  100: "#fff9c4",
  200: "#fff59d",
  300: "#fff176",
  400: "#ffee58",
  500: "#ffeb3b",
  600: "#fdd835",
  700: "#fbc02d",
  800: "#f9a825",
  900: "#f57f17",
  A100: "#ffff8d",
  A200: "#ffff00",
  A400: "#ffea00",
  A700: "#ffd600"
};
var Colors = {
  amber,
  blue,
  blueGrey,
  brown,
  cyan,
  deepOrange,
  deepPurple,
  green,
  grey,
  indigo,
  lightBlue,
  lightGreen,
  lime,
  orange,
  pink,
  purple,
  red,
  teal,
  yellow
};

// packages/style/src/theme.ts
var defaultTheme = {
  action: {
    active: "rgba(0, 0, 0, 0.54)",
    activeBackground: "rgba(0, 0, 0, 0.12)",
    activeOpacity: 0.12,
    disabled: "rgba(0, 0, 0, 0.26)",
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.26)",
    focusBackground: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    hover: "rgba(0, 0, 0, 0.12)",
    hoverBackground: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    selected: "rgba(0, 0, 0, 0.14)",
    selectedBackground: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08
  },
  background: {
    default: "#fafafa",
    paper: "#fff",
    main: "#ffffff",
    modal: "#ffffff",
    gradient: "linear-gradient(90deg, #a8327f 0%, #d4626a 100%)"
  },
  breakpoints: {
    xs: 0,
    sm: 600,
    md: 900,
    lg: 1200,
    xl: 1536
  },
  divider: "rgba(0, 0, 0, 0.12)",
  colors: {
    error: {
      contrastText: "#FFFFFF",
      dark: "#D32F2F",
      light: "#e57373",
      main: "#f44336"
    },
    info: {
      contrastText: "#fff",
      dark: "#1976d2",
      light: "#64b5f6",
      main: "#2196f3"
    },
    primary: {
      contrastText: "#fff",
      dark: "rgb(44, 56, 126)",
      light: "rgb(101, 115, 195)",
      main: "#3f51b5"
    },
    secondary: {
      contrastText: "#fff",
      dark: "rgb(171, 0, 60)",
      light: "rgb(247, 51, 120)",
      main: "#f50057"
    },
    success: {
      contrastText: "rgba(0, 0, 0, 0.87)",
      dark: "#388e3c",
      light: "#81c784",
      main: "#4caf50"
    },
    warning: {
      contrastText: "rgba(0, 0, 0, 0.87)",
      dark: "#f57c00",
      light: "#ffb74d",
      main: "#ff9800"
    }
  },
  layout: {
    container: {
      width: "100%",
      maxWidth: "100%",
      textAlign: "left",
      overflow: "auto"
    }
  },
  shadows: {
    0: "none",
    1: "0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12)",
    2: "0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12)",
    3: "0px 3px 3px -2px rgba(0,0,0,0.2),0px 3px 4px 0px rgba(0,0,0,0.14),0px 1px 8px 0px rgba(0,0,0,0.12)",
    4: "0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12)"
  },
  text: {
    primary: "rgba(0, 0, 0, 0.87)",
    secondary: "rgba(0, 0, 0, 0.6)",
    third: "#f6c958",
    disabled: "rgba(0, 0, 0, 0.38)",
    hint: "rgba(0, 0, 0, 0.38)"
  },
  docs: {
    background: "#f6f8fa",
    text0: "#393939",
    text1: "#717171"
  },
  typography: {
    fontSize: "14px",
    fontFamily: `'roboto', 'Helvetica', 'Arial', 'Lucida Grande', 'sans-serif'`
  },
  input: {
    background: "#fff",
    fontColor: "#000"
  },
  combobox: {
    background: "#fff",
    fontColor: "#000"
  }
};
var darkTheme = {
  action: {
    active: "#fff",
    activeBackground: "rgba(0, 0, 0, 0.5)",
    activeOpacity: 0.12,
    disabled: "rgba(255,255,255,0.3)",
    disabledBackground: "rgba(255,255,255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255,255,255, 0.3)",
    focusBackground: "rgba(255,255,255,0.12)",
    focusOpacity: 0.12,
    hover: "rgba(255,255,255,0.3)",
    hoverBackground: "rgba(255,255,255,0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255,255,255, 0.6)",
    selectedOpacity: 0.16,
    selectedBackground: "rgba(255,255,255, 0.16)"
  },
  background: {
    default: "#303030",
    paper: "#424242",
    main: "#181e3e",
    modal: "#192046",
    gradient: "linear-gradient(90deg, #a8327f 0%, #d4626a 100%)"
  },
  breakpoints: {
    xs: 0,
    sm: 600,
    md: 900,
    lg: 1200,
    xl: 1536
  },
  colors: {
    error: {
      contrastText: "#fff",
      dark: "#d32f2f",
      light: "#e57373",
      main: "#f44336"
    },
    info: {
      contrastText: "rgba(0, 0, 0, 0.87)",
      dark: "#0288d1",
      light: "#4fc3f7",
      main: "#29b6f6"
    },
    primary: {
      contrastText: "#fff",
      dark: "rgb(44, 56, 126)",
      light: "rgb(101, 115, 195)",
      main: "#3f51b5"
    },
    secondary: {
      contrastText: "#fff",
      dark: "rgb(171, 0, 60)",
      light: "rgb(247, 51, 120)",
      main: "#f50057"
    },
    success: {
      contrastText: "rgba(0, 0, 0, 0.87)",
      dark: "#388e3c",
      light: "#81c784",
      main: "#66bb6a"
    },
    warning: {
      contrastText: "rgba(0, 0, 0, 0.87)",
      dark: "#f57c00",
      light: "#ffb74d",
      main: "#ffa726"
    }
  },
  layout: {
    container: {
      width: "100%",
      maxWidth: "100%",
      textAlign: "left",
      overflow: "auto"
    }
  },
  divider: "rgba(255, 255, 255, 0.12)",
  shadows: {
    0: "none",
    1: "0px 2px 1px -1px rgba(0,0,0,0.2),0px 1px 1px 0px rgba(0,0,0,0.14),0px 1px 3px 0px rgba(0,0,0,0.12)",
    2: "0px 3px 1px -2px rgba(0,0,0,0.2),0px 2px 2px 0px rgba(0,0,0,0.14),0px 1px 5px 0px rgba(0,0,0,0.12)",
    3: "0px 3px 3px -2px rgba(0,0,0,0.2),0px 3px 4px 0px rgba(0,0,0,0.14),0px 1px 8px 0px rgba(0,0,0,0.12)",
    4: "0px 2px 4px -1px rgba(0,0,0,0.2),0px 4px 5px 0px rgba(0,0,0,0.14),0px 1px 10px 0px rgba(0,0,0,0.12)"
  },
  text: {
    primary: "#fff",
    secondary: "rgba(255, 255, 255, 0.7)",
    third: "#f6c958",
    disabled: "rgba(255, 255, 255, 0.5)",
    hint: "rgba(255, 255, 255, 0.5)"
  },
  docs: {
    background: "#010132",
    text0: "#fff",
    text1: "#fff"
  },
  typography: {
    fontSize: "14px",
    fontFamily: `'roboto', 'Helvetica', 'Arial', 'Lucida Grande', 'sans-serif'`
  },
  input: {
    background: "#fff",
    fontColor: "#000"
  },
  combobox: {
    background: "#fff",
    fontColor: "#000"
  }
};
function createThemeVars(theme2, vars, prefix) {
  vars = vars || {};
  for (let v in theme2) {
    if (typeof theme2[v] == "object") {
      vars[v] = {};
      createThemeVars(theme2[v], vars[v], prefix ? prefix + v + "-" : v + "-");
    } else {
      let name = ((prefix || "") + v).split(/(?=[A-Z])/).join("_").toLowerCase();
      vars[v] = `var(--${name})`;
    }
  }
  return vars;
}
function createThemeCss(theme2, vars, prefix) {
  vars = vars || {};
  for (let v in theme2) {
    if (typeof theme2[v] == "object") {
      createThemeCss(theme2[v], vars, prefix ? prefix + v + "-" : v + "-");
    } else {
      let name = ((prefix || "") + v).split(/(?=[A-Z])/).join("_").toLowerCase();
      vars[name] = theme2[v];
    }
  }
  return vars;
}
var ThemeVars = createThemeVars(defaultTheme);
var ColorVars = createThemeVars(Colors);
var themeStyle;
var currentTheme;
function applyTheme(theme2) {
  let cssVars = createThemeCss(theme2);
  let css = `:root{`;
  for (let p in cssVars)
    css += `--${p}: ${cssVars[p]};`;
  css += "}";
  if (!themeStyle) {
    themeStyle = document.createElement("style");
    document.head.appendChild(themeStyle);
  }
  themeStyle.textContent = css;
  currentTheme = theme2;
}
applyTheme(defaultTheme);

// packages/style/src/styles.ts
var uniqueId = 0;
var CSS_NUMBER = Object.create(null);
var CSS_NUMBER_KEYS = [
  "animation-iteration-count",
  "border-image-outset",
  "border-image-slice",
  "border-image-width",
  "box-flex",
  "box-flex-group",
  "box-ordinal-group",
  "column-count",
  "columns",
  "counter-increment",
  "counter-reset",
  "flex",
  "flex-grow",
  "flex-positive",
  "flex-shrink",
  "flex-negative",
  "flex-order",
  "font-weight",
  "grid-area",
  "grid-column",
  "grid-column-end",
  "grid-column-span",
  "grid-column-start",
  "grid-row",
  "grid-row-end",
  "grid-row-span",
  "grid-row-start",
  "line-clamp",
  "line-height",
  "opacity",
  "order",
  "orphans",
  "tab-size",
  "widows",
  "z-index",
  "zoom",
  "fill-opacity",
  "flood-opacity",
  "stop-opacity",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width"
];
for (const property of CSS_NUMBER_KEYS) {
  for (const prefix of ["-webkit-", "-ms-", "-moz-", "-o-", ""]) {
    CSS_NUMBER[prefix + property] = true;
  }
}
function escape(str) {
  return str.replace(/[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g, "\\$&");
}
function interpolate(selector, styleName) {
  return selector.replace(/&/g, styleName);
}
function hyphenate(propertyName) {
  return propertyName.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`).replace(/^ms-/, "-ms-");
}
function stringHash(str) {
  let value = 5381;
  let len = str.length;
  while (len--)
    value = value * 33 ^ str.charCodeAt(len);
  return (value >>> 0).toString(36);
}
function styleToString(name, value) {
  const suffix = typeof value === "number" && value && !CSS_NUMBER[name] ? "px" : "";
  return `${name}:${value}${suffix}`;
}
function sortTuples(value) {
  return value.sort((a, b) => a[0] > b[0] ? 1 : -1);
}
function stringifyProperties(properties) {
  return properties.map(([name, value]) => {
    if (!Array.isArray(value))
      return styleToString(name, value);
    return value.map((x) => styleToString(name, x)).join(";");
  }).join(";");
}
function child(selector, parent) {
  if (!selector)
    return parent;
  if (!selector.includes("&"))
    return `${parent} ${selector}`;
  return interpolate(selector, parent);
}
function stylize(rulesList, stylesList, key2, styles, parentClassName) {
  const properties = [];
  const nestedStyles = [];
  for (const key3 of Object.keys(styles)) {
    const value = styles[key3];
    if (key3.charCodeAt(0) !== 36 && value != null) {
      if (typeof value === "object" && !Array.isArray(value)) {
        nestedStyles.push([key3, value]);
      } else {
        properties.push([hyphenate(key3), value]);
      }
    }
  }
  const isUnique = !!styles.$unique;
  const parent = styles.$global ? "" : parentClassName;
  const nested = parent ? nestedStyles : sortTuples(nestedStyles);
  const style2 = stringifyProperties(sortTuples(properties));
  let pid = style2;
  if (key2.charCodeAt(0) === 64) {
    pid += `:${key2}`;
    const childRules = [];
    const childStyles = [];
    if (parent && style2) {
      pid += `:${parent}`;
      childStyles.push({ selector: parent, style: style2, isUnique });
    }
    for (const [name, value] of nested) {
      pid += `:${stylize(childRules, childStyles, name, value, parent)}`;
    }
    rulesList.push({
      selector: key2,
      rules: childRules,
      styles: childStyles,
      style: parent ? "" : style2
    });
  } else {
    const selector = parent ? child(key2, parent) : key2;
    pid += `:${selector}`;
    if (style2) {
      stylesList.push({ selector, style: style2, isUnique });
    }
    for (const [name, value] of nested) {
      pid += `:${stylize(rulesList, stylesList, name, value, selector)}`;
    }
  }
  return pid;
}
function compose(cache, rulesList, stylesList, id, name) {
  for (const { selector, style: style2, isUnique } of stylesList) {
    const key2 = interpolate(selector, name);
    const item = new Style(style2, `s:${isUnique ? (++uniqueId).toString(36) : id}:${style2}`);
    item.add(new Selector(key2, `k:${key2}`));
    cache.add(item);
  }
  for (const { selector, style: style2, rules, styles } of rulesList) {
    const key2 = interpolate(selector, name);
    const item = new Rule(key2, style2, `r:${id}:${key2}:${style2}`);
    compose(item, rules, styles, id, name);
    cache.add(item);
  }
}
function join(arr) {
  let res = "";
  for (let i = 0; i < arr.length; i++)
    res += arr[i];
  return res;
}
var Cache = class {
  constructor(changes) {
    this.changes = changes;
    this.sheet = [];
    this.changeId = 0;
    this._keys = [];
    this._children = Object.create(null);
    this._counters = Object.create(null);
  }
  add(style2) {
    const count = this._counters[style2.id] || 0;
    const item = this._children[style2.id] || style2.clone();
    this._counters[style2.id] = count + 1;
    if (count === 0) {
      this._children[item.id] = item;
      this._keys.push(item.id);
      this.sheet.push(item.getStyles());
      this.changeId++;
      if (this.changes)
        this.changes.add(item, this._keys.length - 1);
    } else if (item instanceof Cache && style2 instanceof Cache) {
      const prevItemChangeId = item.changeId;
      item.merge(style2);
      if (item.changeId !== prevItemChangeId) {
        const index = this._keys.indexOf(style2.id);
        this.sheet.splice(index, 1, item.getStyles());
        this.changeId++;
        if (this.changes)
          this.changes.change(item, index, index);
      }
    }
  }
  remove(style2) {
    const count = this._counters[style2.id];
    if (count) {
      this._counters[style2.id] = count - 1;
      const item = this._children[style2.id];
      const index = this._keys.indexOf(item.id);
      if (count === 1) {
        delete this._counters[style2.id];
        delete this._children[style2.id];
        this._keys.splice(index, 1);
        this.sheet.splice(index, 1);
        this.changeId++;
        if (this.changes)
          this.changes.remove(item, index);
      } else if (item instanceof Cache && style2 instanceof Cache) {
        const prevChangeId = item.changeId;
        item.unmerge(style2);
        if (item.changeId !== prevChangeId) {
          this.sheet.splice(index, 1, item.getStyles());
          this.changeId++;
          if (this.changes)
            this.changes.change(item, index, index);
        }
      }
    }
  }
  values() {
    return this._keys.map((key2) => this._children[key2]);
  }
  merge(cache) {
    for (const item of cache.values())
      this.add(item);
    return this;
  }
  unmerge(cache) {
    for (const item of cache.values())
      this.remove(item);
    return this;
  }
  clone() {
    return new Cache().merge(this);
  }
};
var Selector = class {
  constructor(selector, id) {
    this.selector = selector;
    this.id = id;
  }
  getStyles() {
    return this.selector;
  }
  clone() {
    return this;
  }
};
var Style = class extends Cache {
  constructor(style2, id) {
    super();
    this.style = style2;
    this.id = id;
  }
  getStyles() {
    return `${this.sheet.join(",")}{${this.style}}`;
  }
  clone() {
    return new Style(this.style, this.id).merge(this);
  }
};
var Rule = class extends Cache {
  constructor(rule, style2, id) {
    super();
    this.rule = rule;
    this.style = style2;
    this.id = id;
  }
  getStyles() {
    return `${this.rule}{${this.style}${join(this.sheet)}}`;
  }
  clone() {
    return new Rule(this.rule, this.style, this.id).merge(this);
  }
};
function key(id, styles) {
  if (!styles.$displayName)
    return id;
  return `${styles.$displayName}_${id}`;
}
var FreeStyle = class extends Cache {
  constructor(id, changes) {
    super(changes);
    this.id = id;
  }
  registerStyle(css) {
    const ruleList = [];
    const styleList = [];
    const pid = stylize(ruleList, styleList, "", css, ".&");
    const id = `f${stringHash(pid)}`;
    const name = key(id, css);
    compose(this, ruleList, styleList, id, false ? name : escape(name));
    return name;
  }
  registerKeyframes(keyframes2) {
    return this.registerHashRule("@keyframes", keyframes2);
  }
  registerHashRule(prefix, styles) {
    return this.registerStyle({
      $global: true,
      $displayName: styles.$displayName,
      [`${prefix} &`]: styles
    });
  }
  registerRule(rule, styles) {
    return this.registerStyle({ $global: true, [rule]: styles });
  }
  registerCss(styles) {
    return this.registerRule("", styles);
  }
  getStyles() {
    return join(this.sheet);
  }
  clone() {
    return new FreeStyle(this.id, this.changes).merge(this);
  }
};
function create(changes) {
  return new FreeStyle(`f${(++uniqueId).toString(36)}`, changes);
}

// packages/style/src/formatting.ts
function convertToStyles(object) {
  const styles = {};
  for (const key2 in object) {
    const val = object[key2];
    if (key2 === "$nest") {
      const nested = val;
      for (let selector in nested) {
        const subproperties = nested[selector];
        styles[selector] = convertToStyles(subproperties);
      }
    } else if (key2 === "$debugName") {
      styles.$displayName = val;
    } else {
      styles[key2] = val;
    }
  }
  return styles;
}
function convertToKeyframes(frames) {
  const result = {};
  for (const offset in frames) {
    if (offset !== "$debugName") {
      result[offset] = frames[offset];
    }
  }
  if (frames.$debugName) {
    result.$displayName = frames.$debugName;
  }
  return result;
}

// packages/style/src/utilities.ts
var raf = typeof requestAnimationFrame === "undefined" ? (cb) => setTimeout(cb) : typeof window === "undefined" ? requestAnimationFrame : requestAnimationFrame.bind(window);
function extend(...objects) {
  const result = {};
  for (const object of objects) {
    if (object == null || object === false) {
      continue;
    }
    for (const key2 in object) {
      const val = object[key2];
      if (!val && val !== 0) {
        continue;
      }
      if (key2 === "$nest" && val) {
        result[key2] = result["$nest"] ? extend(result["$nest"], val) : val;
      } else if (key2.indexOf("&") !== -1 || key2.indexOf("@media") === 0) {
        result[key2] = result[key2] ? extend(result[key2], val) : val;
      } else {
        result[key2] = val;
      }
    }
  }
  return result;
}

// packages/style/src/typestyle.ts
var createFreeStyle = () => create();
var TypeStyle = class {
  constructor({ autoGenerateTag }) {
    this.cssRaw = (mustBeValidCSS) => {
      if (!mustBeValidCSS) {
        return;
      }
      this._raw += mustBeValidCSS || "";
      this._pendingRawChange = true;
      this._styleUpdated();
    };
    this.cssRule = (selector, ...objects) => {
      const styles = convertToStyles(extend(...objects));
      this._freeStyle.registerRule(selector, styles);
      this._styleUpdated();
      return;
    };
    this.forceRenderStyles = () => {
      const target = this._getTag();
      if (!target) {
        return;
      }
      target.textContent = this.getStyles();
    };
    this.fontFace = (...fontFace2) => {
      const freeStyle = this._freeStyle;
      for (const face of fontFace2) {
        freeStyle.registerRule("@font-face", face);
      }
      this._styleUpdated();
      return;
    };
    this.getStyles = () => {
      return (this._raw || "") + this._freeStyle.getStyles();
    };
    this.keyframes = (frames) => {
      const keyframes2 = convertToKeyframes(frames);
      const animationName = this._freeStyle.registerKeyframes(keyframes2);
      this._styleUpdated();
      return animationName;
    };
    this.reinit = () => {
      const freeStyle = createFreeStyle();
      this._freeStyle = freeStyle;
      this._lastFreeStyleChangeId = freeStyle.changeId;
      this._raw = "";
      this._pendingRawChange = false;
      const target = this._getTag();
      if (target) {
        target.textContent = "";
      }
    };
    this.setStylesTarget = (tag) => {
      if (this._tag) {
        this._tag.textContent = "";
      }
      this._tag = tag;
      this.forceRenderStyles();
    };
    this.stylesheet = (classes) => {
      const classNames = Object.getOwnPropertyNames(classes);
      const result = {};
      for (let className of classNames) {
        const classDef = classes[className];
        if (classDef) {
          classDef.$debugName = className;
          result[className] = this.style(classDef);
        }
      }
      return result;
    };
    const freeStyle = createFreeStyle();
    this._autoGenerateTag = autoGenerateTag;
    this._freeStyle = freeStyle;
    this._lastFreeStyleChangeId = freeStyle.changeId;
    this._pending = 0;
    this._pendingRawChange = false;
    this._raw = "";
    this._tag = void 0;
    this.style = this.style.bind(this);
  }
  _afterAllSync(cb) {
    this._pending++;
    const pending = this._pending;
    raf(() => {
      if (pending !== this._pending) {
        return;
      }
      cb();
    });
  }
  _getTag() {
    if (this._tag) {
      return this._tag;
    }
    if (this._autoGenerateTag) {
      const tag = typeof window === "undefined" ? { textContent: "" } : document.createElement("style");
      if (typeof document !== "undefined") {
        document.head.appendChild(tag);
      }
      this._tag = tag;
      return tag;
    }
    return void 0;
  }
  _styleUpdated() {
    const changeId = this._freeStyle.changeId;
    const lastChangeId = this._lastFreeStyleChangeId;
    if (!this._pendingRawChange && changeId === lastChangeId) {
      return;
    }
    this._lastFreeStyleChangeId = changeId;
    this._pendingRawChange = false;
    this._afterAllSync(() => this.forceRenderStyles());
  }
  style(...args) {
    const className = this._freeStyle.registerStyle(convertToStyles(extend.apply(void 0, args)));
    this._styleUpdated();
    return className;
  }
};
var typeStyle = new TypeStyle({ autoGenerateTag: true });

// packages/style/src/snippets.ts
function rotate(degree) {
  if (degree !== 0 && !degree)
    return "";
  let value = `rotate(${degree}deg)`;
  return style({
    transform: value
  });
}

// packages/style/src/index.ts
var cssRaw = typeStyle.cssRaw;
var cssRule = typeStyle.cssRule;
var fontFace = typeStyle.fontFace;
var keyframes = typeStyle.keyframes;
var style = typeStyle.style;

// packages/base/src/observable.ts
var INSERT = "insert";
var UPDATE = "update";
var DELETE = "delete";
var REVERSE = "reverse";
var SHUFFLE = "shuffle";
var oMetaKey = Symbol.for("object-observer-meta-key-0");
var validObservableOptionKeys = { async: 1 };
var processObserveOptions = (options) => {
  if (!options || typeof options !== "object") {
    return null;
  }
  const result = {};
  const invalidOptions = [];
  for (const [optName, optVal] of Object.entries(options)) {
    if (optName === "path") {
      if (typeof optVal !== "string" || optVal === "") {
        throw new Error('"path" option, if/when provided, MUST be a non-empty string');
      }
      result[optName] = optVal;
    } else if (optName === "pathsOf") {
      if (options.path) {
        throw new Error('"pathsOf" option MAY NOT be specified together with "path" option');
      }
      if (typeof optVal !== "string") {
        throw new Error('"pathsOf" option, if/when provided, MUST be a string (MAY be empty)');
      }
      result[optName] = options.pathsOf.split(".").filter(Boolean);
    } else if (optName === "pathsFrom") {
      if (options.path || options.pathsOf) {
        throw new Error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf" option/s');
      }
      if (typeof optVal !== "string" || optVal === "") {
        throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string');
      }
      result[optName] = optVal;
    } else {
      invalidOptions.push(optName);
    }
  }
  if (invalidOptions.length) {
    throw new Error(`'${invalidOptions.join(", ")}' is/are not a valid observer option/s`);
  }
  return result;
};
var observe = function observe2(observer, options) {
  if (typeof observer !== "function") {
    throw new Error(`observer MUST be a function, got '${observer}'`);
  }
  const observers = this[oMetaKey].observers;
  if (!observers.some((o) => o[0] === observer)) {
    observers.push([observer, processObserveOptions(options)]);
  } else {
    console.warn("observer may be bound to an observable only once; will NOT rebind");
  }
};
var unobserve = function unobserve2() {
  const observers = this[oMetaKey].observers;
  let ol = observers.length;
  if (ol) {
    let al = arguments.length;
    if (al) {
      while (al--) {
        let i = ol;
        while (i--) {
          if (observers[i][0] === arguments[al]) {
            observers.splice(i, 1);
            ol--;
          }
        }
      }
    } else {
      observers.splice(0);
    }
  }
};
var clearObservers = function unobserve3() {
  this[oMetaKey].observers = [];
};
var propertiesBluePrint = { __observe: { value: observe }, __unobserve: { value: unobserve }, __clearObservers: { value: clearObservers } };
var prepareObject = (source, oMeta) => {
  const target = Object.defineProperties({}, propertiesBluePrint);
  target[oMetaKey] = oMeta;
  for (const key2 in source) {
    target[key2] = getObservedOf(source[key2], key2, oMeta);
  }
  return target;
};
var prepareArray = (source, oMeta) => {
  let l = source.length;
  const target = Object.defineProperties(new Array(l), propertiesBluePrint);
  target[oMetaKey] = oMeta;
  for (let i = 0; i < l; i++) {
    target[i] = getObservedOf(source[i], i, oMeta);
  }
  return target;
};
var prepareTypedArray = (source, oMeta) => {
  Object.defineProperties(source, propertiesBluePrint);
  source[oMetaKey] = oMeta;
  return source;
};
var filterChanges = (options, changes) => {
  if (!options) {
    return changes;
  }
  let result = changes;
  if (options.path) {
    const oPath = options.path;
    result = changes.filter((change) => change.path.join(".") === oPath);
  } else if (options.pathsOf) {
    const oPathsOf = options.pathsOf;
    const oPathsOfStr = oPathsOf.join(".");
    result = changes.filter((change) => (change.path.length === oPathsOf.length + 1 || change.path.length === oPathsOf.length && (change.type === REVERSE || change.type === SHUFFLE)) && change.path.join(".").startsWith(oPathsOfStr));
  } else if (options.pathsFrom) {
    const oPathsFrom = options.pathsFrom;
    result = changes.filter((change) => change.path.join(".").startsWith(oPathsFrom));
  }
  return result;
};
var callObserverSafe = (listener, changes) => {
  try {
    listener(changes);
  } catch (e) {
    console.error(`failed to notify listener ${listener} with ${changes}`, e);
  }
};
var callObserversFromMT = function callObserversFromMT2() {
  const batches = this.batches;
  this.batches = null;
  for (const [listener, changes] of batches) {
    callObserverSafe(listener, changes);
  }
};
var callObservers = (oMeta, changes) => {
  let currentObservable = oMeta;
  let observers, target, options, relevantChanges, i;
  const l = changes.length;
  do {
    observers = currentObservable.observers;
    i = observers.length;
    while (i--) {
      [target, options] = observers[i];
      relevantChanges = filterChanges(options, changes);
      if (relevantChanges.length) {
        if (currentObservable.options.async) {
          if (!currentObservable.batches) {
            currentObservable.batches = [];
            queueMicrotask(callObserversFromMT.bind(currentObservable));
          }
          let rb;
          for (const b of currentObservable.batches) {
            if (b[0] === target) {
              rb = b;
              break;
            }
          }
          if (!rb) {
            rb = [target, []];
            currentObservable.batches.push(rb);
          }
          Array.prototype.push.apply(rb[1], relevantChanges);
        } else {
          callObserverSafe(target, relevantChanges);
        }
      }
    }
    if (currentObservable.parent) {
      const clonedChanges = new Array(l);
      for (let j = 0; j < l; j++) {
        clonedChanges[j] = { ...changes[j] };
        clonedChanges[j].path = [currentObservable.ownKey, ...clonedChanges[j].path];
      }
      changes = clonedChanges;
      currentObservable = currentObservable.parent;
    } else {
      currentObservable = null;
    }
  } while (currentObservable);
};
var getObservedOf = (item, key2, parent) => {
  if (!item || typeof item !== "object") {
    return item;
  } else if (Array.isArray(item)) {
    return new ArrayOMeta({ target: item, ownKey: key2, parent }).proxy;
  } else if (ArrayBuffer.isView(item)) {
    return new TypedArrayOMeta({ target: item, ownKey: key2, parent }).proxy;
  } else if (item instanceof Date) {
    return item;
  } else {
    return new ObjectOMeta({ target: item, ownKey: key2, parent }).proxy;
  }
};
var proxiedPop = function proxiedPop2() {
  const oMeta = this[oMetaKey], target = oMeta.target, poppedIndex = target.length - 1;
  let popResult = target.pop();
  if (popResult && typeof popResult === "object") {
    const tmpObserved = popResult[oMetaKey];
    if (tmpObserved) {
      popResult = tmpObserved.detach();
    }
  }
  const changes = [new Change(DELETE, [poppedIndex], void 0, popResult, this)];
  callObservers(oMeta, changes);
  return popResult;
};
var proxiedPush = function proxiedPush2() {
  const oMeta = this[oMetaKey], target = oMeta.target, l = arguments.length, pushContent = new Array(l), initialLength = target.length;
  for (let i = 0; i < l; i++) {
    pushContent[i] = getObservedOf(arguments[i], initialLength + i, oMeta);
  }
  const pushResult = Reflect.apply(target.push, target, pushContent);
  const changes = [];
  for (let i = initialLength, j = target.length; i < j; i++) {
    changes[i - initialLength] = new Change(INSERT, [i], target[i], void 0, this);
  }
  callObservers(oMeta, changes);
  return pushResult;
};
var proxiedShift = function proxiedShift2() {
  const oMeta = this[oMetaKey], target = oMeta.target;
  let shiftResult, i, l, item, tmpObserved;
  shiftResult = target.shift();
  if (shiftResult && typeof shiftResult === "object") {
    tmpObserved = shiftResult[oMetaKey];
    if (tmpObserved) {
      shiftResult = tmpObserved.detach();
    }
  }
  for (i = 0, l = target.length; i < l; i++) {
    item = target[i];
    if (item && typeof item === "object") {
      tmpObserved = item[oMetaKey];
      if (tmpObserved) {
        tmpObserved.ownKey = i;
      }
    }
  }
  const changes = [new Change(DELETE, [0], void 0, shiftResult, this)];
  callObservers(oMeta, changes);
  return shiftResult;
};
var proxiedUnshift = function proxiedUnshift2() {
  const oMeta = this[oMetaKey], target = oMeta.target, al = arguments.length, unshiftContent = new Array(al);
  for (let i = 0; i < al; i++) {
    unshiftContent[i] = getObservedOf(arguments[i], i, oMeta);
  }
  const unshiftResult = Reflect.apply(target.unshift, target, unshiftContent);
  for (let i = 0, l2 = target.length, item; i < l2; i++) {
    item = target[i];
    if (item && typeof item === "object") {
      const tmpObserved = item[oMetaKey];
      if (tmpObserved) {
        tmpObserved.ownKey = i;
      }
    }
  }
  const l = unshiftContent.length;
  const changes = new Array(l);
  for (let i = 0; i < l; i++) {
    changes[i] = new Change(INSERT, [i], target[i], void 0, this);
  }
  callObservers(oMeta, changes);
  return unshiftResult;
};
var proxiedReverse = function proxiedReverse2() {
  const oMeta = this[oMetaKey], target = oMeta.target;
  let i, l, item;
  target.reverse();
  for (i = 0, l = target.length; i < l; i++) {
    item = target[i];
    if (item && typeof item === "object") {
      const tmpObserved = item[oMetaKey];
      if (tmpObserved) {
        tmpObserved.ownKey = i;
      }
    }
  }
  const changes = [new Change(REVERSE, [], void 0, void 0, this)];
  callObservers(oMeta, changes);
  return this;
};
var proxiedSort = function proxiedSort2(comparator) {
  const oMeta = this[oMetaKey], target = oMeta.target;
  let i, l, item;
  target.sort(comparator);
  for (i = 0, l = target.length; i < l; i++) {
    item = target[i];
    if (item && typeof item === "object") {
      const tmpObserved = item[oMetaKey];
      if (tmpObserved) {
        tmpObserved.ownKey = i;
      }
    }
  }
  const changes = [new Change(SHUFFLE, [], void 0, void 0, this)];
  callObservers(oMeta, changes);
  return this;
};
var proxiedFill = function proxiedFill2(filVal, start, end) {
  const oMeta = this[oMetaKey], target = oMeta.target, changes = [], tarLen = target.length, prev = target.slice(0);
  start = start === void 0 ? 0 : start < 0 ? Math.max(tarLen + start, 0) : Math.min(start, tarLen);
  end = end === void 0 ? tarLen : end < 0 ? Math.max(tarLen + end, 0) : Math.min(end, tarLen);
  if (start < tarLen && end > start) {
    target.fill(filVal, start, end);
    let tmpObserved;
    for (let i = start, item, tmpTarget; i < end; i++) {
      item = target[i];
      target[i] = getObservedOf(item, i, oMeta);
      if (i in prev) {
        tmpTarget = prev[i];
        if (tmpTarget && typeof tmpTarget === "object") {
          tmpObserved = tmpTarget[oMetaKey];
          if (tmpObserved) {
            tmpTarget = tmpObserved.detach();
          }
        }
        changes.push(new Change(UPDATE, [i], target[i], tmpTarget, this));
      } else {
        changes.push(new Change(INSERT, [i], target[i], void 0, this));
      }
    }
    callObservers(oMeta, changes);
  }
  return this;
};
var proxiedCopyWithin = function proxiedCopyWithin2(dest, start, end) {
  const oMeta = this[oMetaKey], target = oMeta.target, tarLen = target.length;
  dest = dest < 0 ? Math.max(tarLen + dest, 0) : dest;
  start = start === void 0 ? 0 : start < 0 ? Math.max(tarLen + start, 0) : Math.min(start, tarLen);
  end = end === void 0 ? tarLen : end < 0 ? Math.max(tarLen + end, 0) : Math.min(end, tarLen);
  const len = Math.min(end - start, tarLen - dest);
  if (dest < tarLen && dest !== start && len > 0) {
    const prev = target.slice(0), changes = [];
    target.copyWithin(dest, start, end);
    for (let i = dest, nItem, oItem, tmpObserved; i < dest + len; i++) {
      nItem = target[i];
      if (nItem && typeof nItem === "object") {
        nItem = getObservedOf(nItem, i, oMeta);
        target[i] = nItem;
      }
      oItem = prev[i];
      if (oItem && typeof oItem === "object") {
        tmpObserved = oItem[oMetaKey];
        if (tmpObserved) {
          oItem = tmpObserved.detach();
        }
      }
      if (typeof nItem !== "object" && nItem === oItem) {
        continue;
      }
      changes.push(new Change(UPDATE, [i], nItem, oItem, this));
    }
    callObservers(oMeta, changes);
  }
  return this;
};
var proxiedSplice = function proxiedSplice2() {
  const oMeta = this[oMetaKey], target = oMeta.target, splLen = arguments.length, spliceContent = new Array(splLen), tarLen = target.length;
  for (let i2 = 0; i2 < splLen; i2++) {
    spliceContent[i2] = getObservedOf(arguments[i2], i2, oMeta);
  }
  const startIndex = splLen === 0 ? 0 : spliceContent[0] < 0 ? tarLen + spliceContent[0] : spliceContent[0], removed = splLen < 2 ? tarLen - startIndex : spliceContent[1], inserted = Math.max(splLen - 2, 0), spliceResult = Reflect.apply(target.splice, target, spliceContent), newTarLen = target.length;
  let tmpObserved;
  for (let i2 = 0, item2; i2 < newTarLen; i2++) {
    item2 = target[i2];
    if (item2 && typeof item2 === "object") {
      tmpObserved = item2[oMetaKey];
      if (tmpObserved) {
        tmpObserved.ownKey = i2;
      }
    }
  }
  let i, l, item;
  for (i = 0, l = spliceResult.length; i < l; i++) {
    item = spliceResult[i];
    if (item && typeof item === "object") {
      tmpObserved = item[oMetaKey];
      if (tmpObserved) {
        spliceResult[i] = tmpObserved.detach();
      }
    }
  }
  const changes = [];
  let index;
  for (index = 0; index < removed; index++) {
    if (index < inserted) {
      changes.push(new Change(UPDATE, [startIndex + index], target[startIndex + index], spliceResult[index], this));
    } else {
      changes.push(new Change(DELETE, [startIndex + index], void 0, spliceResult[index], this));
    }
  }
  for (; index < inserted; index++) {
    changes.push(new Change(INSERT, [startIndex + index], target[startIndex + index], void 0, this));
  }
  callObservers(oMeta, changes);
  return spliceResult;
};
var proxiedTypedArraySet = function proxiedTypedArraySet2(source, offset) {
  const oMeta = this[oMetaKey], target = oMeta.target, souLen = source.length, prev = target.slice(0);
  offset = offset || 0;
  target.set(source, offset);
  const changes = new Array(souLen);
  for (let i = offset; i < souLen + offset; i++) {
    changes[i - offset] = new Change(UPDATE, [i], target[i], prev[i], this);
  }
  callObservers(oMeta, changes);
};
var proxiedArrayMethods = {
  pop: proxiedPop,
  push: proxiedPush,
  shift: proxiedShift,
  unshift: proxiedUnshift,
  reverse: proxiedReverse,
  sort: proxiedSort,
  fill: proxiedFill,
  copyWithin: proxiedCopyWithin,
  splice: proxiedSplice
};
var proxiedTypedArrayMethods = {
  reverse: proxiedReverse,
  sort: proxiedSort,
  fill: proxiedFill,
  copyWithin: proxiedCopyWithin,
  set: proxiedTypedArraySet
};
var Change = class {
  constructor(type, path, value, oldValue, object) {
    this.type = type;
    this.path = path;
    this.value = value;
    this.oldValue = oldValue;
    this.object = object;
  }
};
var OMetaBase = class {
  constructor(properties, cloningFunction) {
    const { target, parent, ownKey } = properties;
    if (parent && ownKey !== void 0) {
      this.parent = parent;
      this.ownKey = ownKey;
    } else {
      this.parent = null;
      this.ownKey = null;
    }
    const targetClone = cloningFunction(target, this);
    this.observers = [];
    this.revocable = Proxy.revocable(targetClone, this);
    this.proxy = this.revocable.proxy;
    this.target = targetClone;
    this.options = this.processOptions(properties.options);
  }
  processOptions(options) {
    if (options) {
      if (typeof options !== "object") {
        throw new Error(`Observable options if/when provided, MAY only be an object, got '${options}'`);
      }
      const invalidOptions = Object.keys(options).filter((option) => !(option in validObservableOptionKeys));
      if (invalidOptions.length) {
        throw new Error(`'${invalidOptions.join(", ")}' is/are not a valid Observable option/s`);
      }
      return Object.assign({}, options);
    } else {
      return {};
    }
  }
  detach() {
    this.parent = null;
    return this.target;
  }
  set(target, key2, value) {
    let oldValue = target[key2];
    if (value !== oldValue) {
      const newValue = getObservedOf(value, key2, this);
      target[key2] = newValue;
      if (oldValue && typeof oldValue === "object") {
        const tmpObserved = oldValue[oMetaKey];
        if (tmpObserved) {
          oldValue = tmpObserved.detach();
        }
      }
      const changes = oldValue === void 0 ? [new Change(INSERT, [key2], newValue, void 0, this.proxy)] : [new Change(UPDATE, [key2], newValue, oldValue, this.proxy)];
      callObservers(this, changes);
    }
    return true;
  }
  deleteProperty(target, key2) {
    let oldValue = target[key2];
    delete target[key2];
    if (oldValue && typeof oldValue === "object") {
      const tmpObserved = oldValue[oMetaKey];
      if (tmpObserved) {
        oldValue = tmpObserved.detach();
      }
    }
    const changes = [new Change(DELETE, [key2], void 0, oldValue, this.proxy)];
    callObservers(this, changes);
    return true;
  }
};
var ObjectOMeta = class extends OMetaBase {
  constructor(properties) {
    super(properties, prepareObject);
  }
};
var ArrayOMeta = class extends OMetaBase {
  constructor(properties) {
    super(properties, prepareArray);
  }
  get(target, key2) {
    return proxiedArrayMethods[key2] || target[key2];
  }
};
var TypedArrayOMeta = class extends OMetaBase {
  constructor(properties) {
    super(properties, prepareTypedArray);
  }
  get(target, key2) {
    return proxiedTypedArrayMethods[key2] || target[key2];
  }
};
var Observable = Object.freeze({
  from: (target, options) => {
    if (!target || typeof target !== "object") {
      throw new Error("observable MAY ONLY be created from a non-null object");
    } else if (target[oMetaKey]) {
      return target;
    } else if (Array.isArray(target)) {
      return new ArrayOMeta({ target, ownKey: null, parent: null, options }).proxy;
    } else if (ArrayBuffer.isView(target)) {
      return new TypedArrayOMeta({ target, ownKey: null, parent: null, options }).proxy;
    } else if (target instanceof Date) {
      throw new Error(`${target} found to be one of a non-observable types`);
    } else {
      return new ObjectOMeta({ target, ownKey: null, parent: null, options }).proxy;
    }
  },
  isObservable: (input) => {
    return !!(input && input[oMetaKey]);
  }
});
function isObservable(input) {
  return !!(input && input[oMetaKey]);
}
function Observe(target, callback, options) {
  if (!target)
    return;
  if (!!(target && target[oMetaKey])) {
    if (callback)
      target.__observe(callback, options);
    return target;
  }
  ;
  let result;
  if (!target || typeof target !== "object") {
    throw new Error("observable MAY ONLY be created from a non-null object");
  } else if (target[oMetaKey]) {
    result = target;
  } else if (Array.isArray(target)) {
    result = new ArrayOMeta({ target, ownKey: null, parent: null }).proxy;
  } else if (ArrayBuffer.isView(target)) {
    result = new TypedArrayOMeta({ target, ownKey: null, parent: null }).proxy;
  } else if (target instanceof Date) {
    throw new Error(`${target} found to be one of a non-observable types`);
  } else {
    result = new ObjectOMeta({ target, ownKey: null, parent: null }).proxy;
  }
  if (callback)
    result.__observe(callback, options);
  return result;
}
function Unobserve(target, observer) {
  if (!target)
    return;
  if (!!(target && target[oMetaKey])) {
    target.__unobserve(observer);
  }
}
function ClearObservers(target) {
  if (!target)
    return;
  if (!!(target && target[oMetaKey])) {
    target.__clearObservers();
  }
}
function observable(propName) {
  return function(target, propertyName) {
    target["$observableProps"] = target["$observableProps"] || {};
    target["$observableProps"][propName || propertyName] = propertyName;
  };
}
function initObservables(target) {
  let observables = target["$observableProps"];
  target["$observables"] = target["$observables"] || {};
  for (let propName in observables) {
    let propertyName = observables[propName];
    let val = Observe({});
    let isObject = false;
    target["$observables"][propName] = val;
    const getter = function() {
      if (isObject)
        return val;
      else {
        return val.value;
      }
    };
    const setter = function(newVal) {
      if (typeof newVal == "object") {
        isObject = true;
        Object.assign(val, newVal);
      } else {
        isObject = false;
        val.value = newVal;
      }
    };
    Object.defineProperty(target, propertyName, {
      get: getter,
      set: setter
    });
  }
}

// packages/base/src/component.ts
var ComponentPropertyType;
(function(ComponentPropertyType2) {
  ComponentPropertyType2[ComponentPropertyType2["string"] = 1] = "string";
  ComponentPropertyType2[ComponentPropertyType2["number"] = 2] = "number";
  ComponentPropertyType2[ComponentPropertyType2["boolean"] = 3] = "boolean";
  ComponentPropertyType2[ComponentPropertyType2["object"] = 4] = "object";
  ComponentPropertyType2[ComponentPropertyType2["array"] = 5] = "array";
  ComponentPropertyType2[ComponentPropertyType2["event"] = 6] = "event";
})(ComponentPropertyType || (ComponentPropertyType = {}));
var notifyEventParams = [{ name: "target", type: "Control", isControl: true }, { name: "event", type: "Event" }];
var GroupType;
(function(GroupType2) {
  GroupType2["BASIC"] = "Basic";
  GroupType2["LAYOUT"] = "Layout";
  GroupType2["FIELDS"] = "Fields";
})(GroupType || (GroupType = {}));
var ComponentProperty = {
  props: {
    "id": { type: "string" }
  },
  events: {}
};
var Component = class extends HTMLElement {
  constructor(parent, options, defaults) {
    super();
    this.deferReadyCallback = false;
    this._readyCallback = [];
    this.initializing = false;
    this.initialized = false;
    this.attrs = {};
    this._uuid = IdUtils.generateUUID();
    this.options = options || {};
    this.defaults = defaults || {};
    initObservables(this);
  }
  connectedCallback() {
    if (this.connected)
      return;
    this.connected = true;
    if (!this.initializing && !this.initialized) {
      this.init();
    }
  }
  disconnectedCallback() {
    this.connected = false;
  }
  parseDesignPropValue(value) {
    if (value.startsWith("{") && value.endsWith("}")) {
      value = value.substring(1, value.length - 1);
      if (value.startsWith("{") && value.endsWith("}"))
        return JSON.parse(value);
    } else if (value.startsWith('"') && value.endsWith('"')) {
      value = value.substring(1, value.length - 1);
    } else if (value.startsWith("'") && value.endsWith("'")) {
      value = value.substring(1, value.length - 1);
    }
    return value;
  }
  _getDesignPropValue(prop) {
    return this._designProps && this._designProps[prop];
  }
  _setDesignPropValue(prop, value, breakpointProp) {
    this._designProps = this._designProps || {};
    this._designProps[prop] = value;
    if (ComponentProperty.props[prop] && prop !== "mediaQueries") {
      this[prop] = breakpointProp != null ? breakpointProp : value;
    } else {
      let propInfo = this._propInfo || getCustomElementProperties(this.tagName);
      this._propInfo = propInfo;
      if (propInfo && propInfo.props[prop] && prop !== "mediaQueries") {
        if (!["link", "icon", "image", "rightIcon"].includes(prop)) {
          this[prop] = breakpointProp != null ? breakpointProp : value;
        }
      }
      ;
    }
    ;
  }
  _setDesignProps(props, breakpoint = {}) {
    var _a;
    if (breakpoint) {
      for (let prop in breakpoint) {
        if (!Object.hasOwnProperty.call(props, prop))
          props[prop] = (_a = this._designProps) == null ? void 0 : _a[prop];
      }
    }
    for (let prop in props) {
      const hasQuery = Object.hasOwnProperty.call(breakpoint, prop);
      this._setDesignPropValue(prop, props[prop], hasQuery ? breakpoint[prop] : void 0);
    }
  }
  _getDesignProps() {
    return this._designProps;
  }
  createElement(tagName, parentElm) {
    let result = document.createElement(tagName);
    if (parentElm)
      parentElm.appendChild(result);
    return result;
  }
  getAttributeValue(target, paths, idx) {
    idx = idx || 0;
    let path = paths[idx];
    let value = target[path];
    idx++;
    if (paths.length > idx)
      try {
        return this.getAttributeValue(value, paths, idx);
      } catch (error) {
        return value;
      }
    else
      return value;
  }
  getAttribute(name, removeAfter, defaultValue) {
    if (this.options[name] != null)
      return this.options[name];
    else if (this.attrs[name] != null && this.attrs[name] != void 0) {
      if (removeAfter)
        this.removeAttribute(name);
      if (this.attrs[name].__target)
        return this.getAttributeValue(this.attrs[name].__target, this.attrs[name].__path);
      else
        return this.attrs[name];
    } else {
      let value = super.getAttribute(name);
      if (value && value.__target)
        return;
      else if (value != null) {
        if (value == "false" || value == "true")
          value = JSON.parse(value);
        this.options[name] = value;
        if (removeAfter)
          this.removeAttribute(name);
        return value;
      } else if (this.defaults[name] != null)
        return this.defaults[name];
    }
    ;
    return defaultValue;
  }
  getPositionAttribute(name, removeAfter, defaultValue) {
    let result = parseFloat(this.getAttribute(name, removeAfter, defaultValue));
    if (removeAfter && result)
      this.style[name] = result + "px";
    return result;
  }
  getStyleAttribute(name, removeAfter, defaultValue) {
    let result = this.getAttribute(name, removeAfter, defaultValue);
    if (removeAfter && result)
      this.style[name] = result;
    return result;
  }
  get uuid() {
    return this._uuid;
  }
  get id() {
    return this.getAttribute("id");
  }
  set id(value) {
    this.options.id = value;
    this.setAttribute("id", value);
  }
  async ready() {
    if (this.initialized)
      return;
    return new Promise((resolve) => {
      if (this.initialized)
        return resolve();
      this._readyCallback.push(resolve);
      if (!this.initializing && !this.initialized) {
        this.init();
      }
    });
  }
  executeReadyCallback() {
    if (this.initialized)
      return;
    this.initialized = true;
    this.initializing = false;
    let callbacks = this._readyCallback;
    for (let i = 0; i < callbacks.length; i++) {
      callbacks[i]();
    }
    ;
    this._readyCallback = [];
  }
  init() {
    if (!this.initializing && !this.initialized) {
      this.initializing = true;
      if (this.options["class"]) {
        this.setAttribute("class", this.options["class"]);
      }
      if (!this.deferReadyCallback) {
        this.executeReadyCallback();
      }
      ;
    }
    ;
  }
};

// packages/base/src/style/base.css.ts
var spinnerAnim = keyframes({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
cssRule("html", {
  overscrollBehavior: "none"
});
cssRule("body", {
  background: theme_exports.ThemeVars.background.default,
  backgroundAttachment: "fixed !important",
  margin: 0,
  padding: 0,
  overflowX: "hidden",
  overflowY: "auto",
  overscrollBehavior: "none",
  $nest: {
    "*, *:before, *:after": {
      boxSizing: "border-box"
    },
    ".text-left": {
      textAlign: "left"
    },
    ".text-right": {
      textAlign: "right"
    },
    ".text-center": {
      textAlign: "center"
    },
    ".bold": {
      fontWeight: "bold"
    },
    ".inline-flex": {
      display: "inline-flex"
    },
    ".flex": {
      display: "flex"
    },
    ".inline-block": {
      display: "inline-block"
    },
    ".mr-1": {
      marginRight: "1rem !important"
    },
    ".ml-1": {
      marginLeft: "1rem !important"
    },
    ".mb-1": {
      marginBottom: "1rem !important"
    },
    ".mt-1": {
      marginTop: "1rem !important"
    },
    ".mb-2": {
      marginBottom: "2rem"
    },
    ".pointer": {
      cursor: "pointer"
    },
    ".text-underline": {
      textDecoration: "underline"
    },
    ".text-none i-link > a": {
      textDecoration: "none"
    },
    ".i-loading-overlay": {
      position: "absolute",
      zIndex: 9,
      margin: 0,
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      transition: "opacity .3s",
      background: theme_exports.ThemeVars.background.default,
      $nest: {
        "&:after": {
          content: '""',
          position: "absolute",
          opacity: ".5",
          width: "100%",
          height: "100%"
        },
        ".i-loading-spinner_text": {
          fontSize: "1rem",
          color: theme_exports.ThemeVars.text.primary,
          fontFamily: theme_exports.ThemeVars.typography.fontFamily,
          marginTop: ".5rem"
        },
        ".i-loading-spinner_icon": {
          display: "block",
          animation: `${spinnerAnim} 2s linear infinite`,
          $nest: {
            "i-image": {
              display: "block",
              maxHeight: "100%",
              maxWidth: "100%"
            }
          }
        },
        ".i-loading-spinner": {
          position: "absolute",
          top: "50%",
          left: "50%",
          transform: "translate(-50%, -50%)",
          zIndex: 9999,
          padding: "1rem"
        }
      }
    }
  }
});
var disabledStyle = style({
  opacity: 0.4,
  cursor: "default"
});
var containerStyle = style({
  $nest: {
    "span.resizer": {
      zIndex: 999
    },
    "span.resizer:hover": {
      backgroundColor: theme_exports.ThemeVars.colors.info.main,
      transitionDelay: "0.5s"
    },
    "span.resizer.highlight": {
      backgroundColor: theme_exports.ThemeVars.colors.info.main
    },
    "span.e-resize": {
      position: "absolute",
      right: "0px",
      height: "100%",
      width: "4px",
      cursor: "e-resize"
    },
    "span.n-resize": {
      position: "absolute",
      top: "0px",
      height: "4px",
      width: "100%",
      cursor: "n-resize"
    },
    "span.s-resize": {
      position: "absolute",
      bottom: "0px",
      height: "4px",
      width: "100%",
      cursor: "s-resize"
    },
    "span.w-resize": {
      position: "absolute",
      left: "0px",
      height: "100%",
      width: "4px",
      cursor: "w-resize"
    },
    "span.resizing": {
      userSelect: "none",
      pointerEvents: "none"
    }
  }
});
var getBorderSideObj = (side, value) => {
  let styleObj = {};
  if (value.width !== void 0) {
    let borderWidthProp = `border-${side}-width`;
    styleObj[borderWidthProp] = getSpacingValue(value.width);
  }
  if (value.style !== void 0) {
    let borderStyleProp = `border-${side}-style`;
    styleObj[borderStyleProp] = value.style;
  }
  if (value.color !== void 0) {
    let borderColorProp = `border-${side}-color`;
    styleObj[borderColorProp] = value.color || "transparent";
  }
  return styleObj;
};
var getBorderSideStyleClass = (side, value) => {
  const styleObj = getBorderSideObj(side, value);
  return style(styleObj);
};
var getBorderStyleClass = (value) => {
  if (!value)
    return "";
  const { width, style: bdStyle, color, top, right, bottom, left } = value;
  let styleObj = {};
  if (Object.hasOwnProperty.call(value, "radius")) {
    styleObj["borderRadius"] = value.radius;
  }
  let borderWidth = width || "1px";
  let borderColor = color || "transparent";
  let borderStyle = bdStyle || "solid";
  styleObj.borderWidth = "";
  styleObj.borderColor = "";
  styleObj.borderStyle = "";
  if (top) {
    const { width: width2, color: color2, style: style2 } = top;
    styleObj.borderWidth = `${getSpacingValue(width2 || borderWidth)}`;
    styleObj.borderColor = `${color2 || borderColor}`;
    styleObj.borderStyle = `${style2 || borderStyle}`;
  }
  if (right) {
    const { width: width2, color: color2, style: style2 } = right;
    styleObj.borderWidth += ` ${getSpacingValue(width2 || borderWidth)}`;
    styleObj.borderColor += ` ${color2 || borderColor}`;
    styleObj.borderStyle += ` ${style2 || borderStyle}`;
  }
  if (bottom) {
    const { width: width2, color: color2, style: style2 } = bottom;
    styleObj.borderWidth += ` ${getSpacingValue(width2 || borderWidth)}`;
    styleObj.borderColor += ` ${color2 || borderColor}`;
    styleObj.borderStyle += ` ${style2 || borderStyle}`;
  }
  if (left) {
    const { width: width2, color: color2, style: style2 } = left;
    styleObj.borderWidth += ` ${getSpacingValue(width2 || borderWidth)}`;
    styleObj.borderColor += ` ${color2 || borderColor}`;
    styleObj.borderStyle += ` ${style2 || borderStyle}`;
  }
  if (!styleObj.borderWidth) {
    styleObj.borderWidth = borderWidth;
  }
  if (!styleObj.borderColor) {
    styleObj.borderColor = borderColor || "transparent";
  }
  if (!styleObj.borderStyle) {
    styleObj.borderStyle = borderStyle || "solid";
  }
  return style(styleObj);
};
var getOverflowStyleClass = (value) => {
  let styleObj = {};
  if (value.x === value.y) {
    styleObj.overflow = value.x;
  } else {
    if (value.x) {
      styleObj.overflowX = value.x;
    }
    if (value.y) {
      styleObj.overflowY = value.y;
    }
  }
  return style(styleObj);
};
var getBackground = (value) => {
  let styleObj = { background: "" };
  let bg = "";
  value.image && (bg += `url(${value.image})`);
  value.color && (bg += `${value.color}`);
  styleObj.background = bg;
  return styleObj;
};
var getBackgroundStyleClass = (value) => {
  return style(getBackground(value));
};
var getSpacingValue = (value) => {
  const isNumber = typeof value === "number" || value !== "" && !Number.isNaN(Number(value));
  return isNumber ? `${value}px` : value;
};
var getMediaQueryRule = (mediaQuery) => {
  let mediaQueryRule;
  const maxWidth = mediaQuery.maxWidth ? getSpacingValue(mediaQuery.maxWidth) : 0;
  const minWidth = mediaQuery.minWidth ? getSpacingValue(mediaQuery.minWidth) : 0;
  if (minWidth && maxWidth) {
    mediaQueryRule = `@media (min-width: ${minWidth}) and (max-width: ${maxWidth})`;
  } else if (minWidth) {
    mediaQueryRule = `@media (min-width: ${minWidth})`;
  } else if (maxWidth) {
    mediaQueryRule = `@media (max-width: ${maxWidth})`;
  }
  return mediaQueryRule;
};
var getControlMediaQueriesStyle = (mediaQueries, props) => {
  var _a;
  let styleObj = {
    $nest: {}
  };
  if (mediaQueries) {
    for (let mediaQuery of mediaQueries) {
      let mediaQueryRule = getMediaQueryRule(mediaQuery);
      if (mediaQueryRule) {
        styleObj["$nest"][mediaQueryRule] = {};
        let {
          display,
          visible,
          padding,
          margin,
          position,
          border,
          overflow,
          background,
          grid,
          zIndex,
          top,
          left,
          right,
          bottom,
          maxHeight,
          maxWidth,
          font,
          width,
          height,
          minWidth,
          minHeight,
          opacity: opacity2,
          stack
        } = mediaQuery.properties || {};
        if (display) {
          styleObj["$nest"][mediaQueryRule]["display"] = `${display} !important`;
        }
        if (typeof visible === "boolean") {
          const currentDisplay = (_a = display != null ? display : props == null ? void 0 : props.display) != null ? _a : "flex";
          styleObj["$nest"][mediaQueryRule]["display"] = visible ? `${currentDisplay} !important` : "none !important";
        }
        if (padding) {
          const { top: top2 = 0, right: right2 = 0, bottom: bottom2 = 0, left: left2 = 0 } = padding;
          styleObj["$nest"][mediaQueryRule]["padding"] = `${getSpacingValue(top2)} ${getSpacingValue(right2)} ${getSpacingValue(bottom2)} ${getSpacingValue(left2)} !important`;
        }
        if (margin) {
          const { top: top2 = 0, right: right2 = 0, bottom: bottom2 = 0, left: left2 = 0 } = margin;
          styleObj["$nest"][mediaQueryRule]["margin"] = `${getSpacingValue(top2)} ${getSpacingValue(right2)} ${getSpacingValue(bottom2)} ${getSpacingValue(left2)} !important`;
        }
        if (border) {
          const { radius, width: width2, style: style2, color, bottom: bottom2, top: top2, left: left2, right: right2 } = border;
          if (width2 !== void 0 && width2 !== null)
            styleObj["$nest"][mediaQueryRule]["border"] = `${width2 || ""} ${style2 || ""} ${color || ""}!important`;
          if (radius)
            styleObj["$nest"][mediaQueryRule]["borderRadius"] = `${getSpacingValue(radius)} !important`;
          if (bottom2)
            styleObj["$nest"][mediaQueryRule]["borderBottom"] = `${getSpacingValue(bottom2.width || "")} ${bottom2.style || ""} ${bottom2.color || ""}!important`;
          if (top2)
            styleObj["$nest"][mediaQueryRule]["borderTop"] = `${getSpacingValue(top2.width || "") || ""} ${top2.style || ""} ${top2.color || ""}!important`;
          if (left2)
            styleObj["$nest"][mediaQueryRule]["borderLeft"] = `${getSpacingValue(left2.width || "")} ${left2.style || ""} ${left2.color || ""}!important`;
          if (right2)
            styleObj["$nest"][mediaQueryRule]["borderRight"] = `${getSpacingValue(right2.width || "")} ${right2.style || ""} ${right2.color || ""}!important`;
        }
        if (background) {
          const value = getBackground(background);
          styleObj["$nest"][mediaQueryRule]["background"] = value.background + "!important";
        }
        if (grid) {
          const {
            column,
            columnSpan,
            row,
            rowSpan,
            horizontalAlignment,
            verticalAlignment,
            area
          } = grid;
          if (column && columnSpan) {
            styleObj["$nest"][mediaQueryRule]["gridColumn"] = `${column + " / span " + columnSpan}!important`;
          } else if (column)
            styleObj["$nest"][mediaQueryRule]["gridColumnStart"] = `${column.toString()}!important`;
          else if (columnSpan)
            styleObj["$nest"][mediaQueryRule]["gridColumn"] = `${"span " + columnSpan}!important`;
          if (row && rowSpan)
            styleObj["$nest"][mediaQueryRule]["gridRow"] = `${row + " / span " + rowSpan}!important`;
          else if (row)
            styleObj["$nest"][mediaQueryRule]["gridRowStart"] = `${row.toString()}!important`;
          else if (rowSpan)
            styleObj["$nest"][mediaQueryRule]["gridRow"] = `${"span " + rowSpan}!important`;
          if (area)
            styleObj["$nest"][mediaQueryRule]["gridArea"] = `${area}!important`;
          if (horizontalAlignment)
            styleObj["$nest"][mediaQueryRule]["justifyContent"] = `${horizontalAlignment}!important`;
          if (verticalAlignment)
            styleObj["$nest"][mediaQueryRule]["alignItems"] = `${verticalAlignment}!important`;
        }
        if (position) {
          styleObj["$nest"][mediaQueryRule]["position"] = `${position} !important`;
        }
        if (zIndex !== void 0 && zIndex !== null) {
          styleObj["$nest"][mediaQueryRule]["zIndex"] = `${zIndex} !important`;
        }
        if (top !== void 0 && top !== null) {
          styleObj["$nest"][mediaQueryRule]["top"] = `${getSpacingValue(top)} !important`;
        }
        if (left !== void 0 && left !== null) {
          styleObj["$nest"][mediaQueryRule]["left"] = `${getSpacingValue(left)} !important`;
        }
        if (right !== void 0 && right !== null) {
          styleObj["$nest"][mediaQueryRule]["right"] = `${getSpacingValue(right)} !important`;
        }
        if (bottom !== void 0 && bottom !== null) {
          styleObj["$nest"][mediaQueryRule]["bottom"] = `${getSpacingValue(bottom)} !important`;
        }
        if (maxHeight !== void 0 && maxHeight !== null) {
          styleObj["$nest"][mediaQueryRule]["maxHeight"] = `${getSpacingValue(maxHeight)} !important`;
        }
        if (maxWidth !== void 0 && maxWidth !== null) {
          styleObj["$nest"][mediaQueryRule]["maxWidth"] = `${getSpacingValue(maxWidth)} !important`;
        }
        if (width !== void 0 && width !== null) {
          styleObj["$nest"][mediaQueryRule]["width"] = `${getSpacingValue(width)} !important`;
        }
        if (height !== void 0 && height !== null) {
          styleObj["$nest"][mediaQueryRule]["height"] = `${getSpacingValue(height)} !important`;
        }
        if (minWidth !== void 0 && minWidth !== null) {
          styleObj["$nest"][mediaQueryRule]["minWidth"] = `${getSpacingValue(minWidth)} !important`;
        }
        if (minHeight !== void 0 && minHeight !== null) {
          styleObj["$nest"][mediaQueryRule]["minHeight"] = `${getSpacingValue(minHeight)} !important`;
        }
        if (overflow) {
          if (typeof overflow === "string") {
            styleObj["$nest"][mediaQueryRule]["overflow"] = `${overflow} !important`;
          } else {
            const { x, y } = overflow || {};
            if (x === y) {
              styleObj["$nest"][mediaQueryRule]["overflow"] = `${x} !important`;
            } else {
              if (x)
                styleObj["$nest"][mediaQueryRule]["overflowX"] = `${x} !important`;
              if (y)
                styleObj["$nest"][mediaQueryRule]["overflowY"] = `${y} !important`;
            }
          }
        }
        if (font) {
          const { size, weight, style: style2, name, color, bold, transform } = font;
          if (size)
            styleObj["$nest"][mediaQueryRule]["fontSize"] = `${size}!important`;
          if (typeof bold === "boolean") {
            styleObj["$nest"][mediaQueryRule]["fontWeight"] = bold === true ? `bold !important` : `normal !important`;
          }
          if (weight)
            styleObj["$nest"][mediaQueryRule]["fontWeight"] = `${weight}!important`;
          if (style2)
            styleObj["$nest"][mediaQueryRule]["fontStyle"] = `${style2}!important`;
          if (name)
            styleObj["$nest"][mediaQueryRule]["fontFamily"] = `${name}!important`;
          if (color)
            styleObj["$nest"][mediaQueryRule]["color"] = `${color}!important`;
          if (transform)
            styleObj["$nest"][mediaQueryRule]["textTransform"] = `${transform}!important`;
        }
        if (opacity2 !== void 0 && opacity2 !== null) {
          styleObj["$nest"][mediaQueryRule]["opacity"] = `${opacity2}!important`;
        }
        if (stack) {
          const { basis, grow, shrink } = stack;
          if (basis !== void 0 && basis !== null)
            styleObj["$nest"][mediaQueryRule]["flexBasis"] = `${basis}!important`;
          if (grow !== void 0 && grow !== null)
            styleObj["$nest"][mediaQueryRule]["flexGrow"] = `${grow}!important`;
          if (shrink !== void 0 && shrink !== null)
            styleObj["$nest"][mediaQueryRule]["flexShrink"] = `${shrink}!important`;
        }
      }
    }
  }
  return styleObj;
};
var getControlMediaQueriesStyleClass = (mediaQueries, props) => {
  let styleObj = getControlMediaQueriesStyle(mediaQueries, props);
  return style(styleObj);
};
var getOpacityStyleClass = (opacity2) => {
  return style({
    opacity: opacity2
  });
};

// packages/tooltip/src/style/tooltip.css.ts
var Theme = theme_exports.ThemeVars;
var arrowBackgroundColor = "var(--tooltips-arrow-background, rgba(97, 97, 97, 0.92))";
cssRule("body", {
  $nest: {
    ".ii-tooltip": {
      position: "absolute",
      display: "inline-block",
      fontFamily: Theme.typography.fontFamily,
      backgroundColor: "rgba(97, 97, 97, 0.92)",
      borderRadius: "4px",
      color: "rgb(255, 255, 255)",
      padding: "4px 8px",
      fontSize: "0.6875rem",
      maxWidth: "300px",
      overflowWrap: "break-word",
      fontWeight: 500,
      zIndex: 9999
    },
    ".ii-tooltip-top::after": {
      content: "''",
      position: "absolute",
      top: "100%",
      left: "50%",
      marginLeft: "-5px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `${arrowBackgroundColor} transparent transparent transparent`
    },
    ".ii-tooltip-topLeft::after": {
      content: "''",
      position: "absolute",
      top: "100%",
      left: "0%",
      marginLeft: "12px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `${arrowBackgroundColor} transparent transparent transparent`
    },
    ".ii-tooltip-topRight::after": {
      content: "''",
      position: "absolute",
      top: "100%",
      right: "0%",
      marginRight: "12px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `${arrowBackgroundColor} transparent transparent transparent`
    },
    ".ii-tooltip-left::after": {
      content: "''",
      position: "absolute",
      top: "50%",
      left: "100%",
      marginTop: "-5px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent transparent transparent ${arrowBackgroundColor}`
    },
    ".ii-tooltip-leftTop::after": {
      content: "''",
      position: "absolute",
      top: "0%",
      left: "100%",
      marginTop: "5px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent transparent transparent ${arrowBackgroundColor}`
    },
    ".ii-tooltip-leftBottom::after": {
      content: "''",
      position: "absolute",
      bottom: "0%",
      left: "100%",
      marginBottom: "5px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent transparent transparent ${arrowBackgroundColor}`
    },
    ".ii-tooltip-right::after": {
      content: "''",
      position: "absolute",
      top: "50%",
      right: "100%",
      marginTop: "-5px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent ${arrowBackgroundColor} transparent transparent`
    },
    ".ii-tooltip-rightTop::after": {
      content: "''",
      position: "absolute",
      top: "0%",
      right: "100%",
      marginTop: "5px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent ${arrowBackgroundColor} transparent transparent`
    },
    ".ii-tooltip-rightBottom::after": {
      content: "''",
      position: "absolute",
      bottom: "0%",
      right: "100%",
      marginBottom: "5px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent ${arrowBackgroundColor} transparent transparent`
    },
    ".ii-tooltip-bottom::after": {
      content: "''",
      position: "absolute",
      bottom: "100%",
      left: "50%",
      marginLeft: "-5px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent transparent ${arrowBackgroundColor} transparent`
    },
    ".ii-tooltip-bottomLeft::after": {
      content: "''",
      position: "absolute",
      bottom: "100%",
      left: "0%",
      marginLeft: "12px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent transparent ${arrowBackgroundColor} transparent`
    },
    ".ii-tooltip-bottomRight::after": {
      content: "''",
      position: "absolute",
      bottom: "100%",
      right: "0%",
      marginRight: "12px",
      borderWidth: "5px",
      borderStyle: "solid",
      borderColor: `transparent transparent ${arrowBackgroundColor} transparent`
    }
  }
});

// packages/tooltip/src/tooltip.ts
var Tooltip = class {
  constructor(source) {
    this.initData(source);
    this.initEvents(source);
  }
  initData(source) {
    const data = source.getAttribute("tooltip", true);
    let options = data;
    if (typeof data === "string") {
      try {
        options = JSON.parse(data);
      } catch (e) {
        options = null;
      }
    }
    this.content = (options == null ? void 0 : options.content) || "";
    this.popperClass = (options == null ? void 0 : options.popperClass) || "tooltip-content";
    this.placement = (options == null ? void 0 : options.placement) || "top";
    this.trigger = (options == null ? void 0 : options.trigger) || "hover";
    this.color = (options == null ? void 0 : options.color) || "rgba(0,0,0,.75)";
    if (options == null ? void 0 : options.maxWidth)
      this.maxWidth = options.maxWidth;
  }
  positionAt(parent, tooltip, placement) {
    const parentCoords = parent.getBoundingClientRect();
    let left = 0;
    let top = 0;
    const dist = 10;
    switch (placement) {
      case "top":
        top = parentCoords.top - tooltip.offsetHeight - dist;
        left = parentCoords.left + (parent.offsetWidth - tooltip.offsetWidth) / 2;
        break;
      case "topLeft":
        top = parentCoords.top - tooltip.offsetHeight - dist;
        left = parentCoords.left;
        break;
      case "topRight":
        top = parentCoords.top - tooltip.offsetHeight - dist;
        left = parentCoords.left + parent.offsetWidth - tooltip.offsetWidth;
        break;
      case "left":
        top = (parentCoords.top + parentCoords.bottom) / 2 - tooltip.offsetHeight / 2;
        left = parentCoords.left - dist - tooltip.offsetWidth;
        if (parentCoords.left - tooltip.offsetWidth < 0) {
          left = dist;
        }
        break;
      case "leftTop":
        top = parentCoords.top;
        left = parentCoords.left - dist - tooltip.offsetWidth;
        if (parentCoords.left - tooltip.offsetWidth < 0) {
          left = dist;
        }
        break;
      case "leftBottom":
        top = parentCoords.top + parent.offsetHeight - tooltip.offsetHeight;
        left = parentCoords.left - dist - tooltip.offsetWidth;
        if (parentCoords.left - tooltip.offsetWidth < 0) {
          left = dist;
        }
        break;
      case "right":
        top = (parentCoords.top + parentCoords.bottom) / 2 - tooltip.offsetHeight / 2;
        left = parentCoords.right + dist;
        if (parentCoords.right + tooltip.offsetWidth > document.documentElement.clientWidth) {
          left = document.documentElement.clientWidth - tooltip.offsetWidth - dist;
        }
        break;
      case "rightTop":
        top = parentCoords.top;
        left = parentCoords.right + dist;
        if (parentCoords.right + tooltip.offsetWidth > document.documentElement.clientWidth) {
          left = document.documentElement.clientWidth - tooltip.offsetWidth - dist;
        }
        break;
      case "rightBottom":
        top = parentCoords.top + parent.offsetHeight - tooltip.offsetHeight;
        left = parentCoords.right + dist;
        if (parentCoords.right + tooltip.offsetWidth > document.documentElement.clientWidth) {
          left = document.documentElement.clientWidth - tooltip.offsetWidth - dist;
        }
        break;
      case "bottom":
        top = parentCoords.bottom + dist;
        left = parentCoords.left + (parent.offsetWidth - tooltip.offsetWidth) / 2;
        break;
      case "bottomLeft":
        top = parentCoords.bottom + dist;
        left = parentCoords.left;
        break;
      case "bottomRight":
        top = parentCoords.bottom + dist;
        left = parentCoords.left + parent.offsetWidth - tooltip.offsetWidth;
        break;
    }
    left = left < 0 ? parentCoords.left : left;
    top = top < 0 ? parentCoords.bottom + dist : top;
    tooltip.style.left = left + "px";
    tooltip.style.top = top + pageYOffset + "px";
  }
  get trigger() {
    return this._trigger;
  }
  set trigger(value) {
    this._trigger = value;
  }
  get popperClass() {
    return this._popperClass;
  }
  set popperClass(value) {
    this._popperClass = value;
    if (this.tooltipElm && value)
      this.tooltipElm.classList.add(this.popperClass);
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    if (this.tooltipElm && value) {
      this.tooltipElm.style.backgroundColor = this.color;
      this.tooltipElm.style.setProperty("--tooltips-arrow-background", this.color);
    }
  }
  get content() {
    return this._content;
  }
  set content(value) {
    this._content = value;
    if (this.tooltipElm)
      this.tooltipElm.innerHTML = this.content;
  }
  get placement() {
    return this._placement;
  }
  set placement(value) {
    this._placement = value;
    if (this.tooltipElm)
      this.tooltipElm.classList.add(`ii-tooltip-${this.placement}`);
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(value) {
    this._maxWidth = value;
    if (this.tooltipElm && value)
      this.tooltipElm.style.maxWidth = this.maxWidth;
  }
  show(elm) {
    if (!this.tooltipElm)
      this.renderTooltip();
    document.body.appendChild(this.tooltipElm);
    this.positionAt(elm, this.tooltipElm, this.placement);
  }
  close() {
    if (this.tooltipElm && document.body.contains(this.tooltipElm))
      document.body.removeChild(this.tooltipElm);
  }
  onHandleClick(elm) {
    this.show(elm);
    this.timeout = setTimeout(() => {
      clearTimeout(this.timeout);
      if (this.tooltipElm && document.body.contains(this.tooltipElm))
        document.body.removeChild(this.tooltipElm);
    }, 200);
  }
  renderTooltip() {
    this.tooltipElm = document.createElement("div");
    this.tooltipElm.classList.add("ii-tooltip");
    this.tooltipElm.innerHTML = this.content;
    this.tooltipElm.classList.add(this.popperClass);
    this.tooltipElm.classList.add(`ii-tooltip-${this.placement}`);
    if (this.color) {
      this.tooltipElm.style.backgroundColor = this.color;
      this.tooltipElm.style.setProperty("--tooltips-arrow-background", this.color);
    }
    if (this.maxWidth)
      this.tooltipElm.style.maxWidth = this.maxWidth;
  }
  initEvents(source) {
    source.addEventListener("mouseover", (e) => {
      if (!this.content)
        return;
      if (this.trigger === "hover") {
        e.preventDefault();
        e.stopImmediatePropagation();
        this.show(source);
        source.addEventListener("mouseleave", (e2) => {
          this.close();
        });
      }
    });
    source.addEventListener("mousedown", (e) => {
      if (!this.content)
        return;
      if (this.trigger === "click") {
        this.onHandleClick(source);
      } else {
        this.close();
      }
    });
  }
};

// packages/base/src/control.ts
function getParentControl(elm) {
  if (elm.parentElement instanceof Control) {
    return elm.parentElement;
  } else if (elm.parentElement)
    return getParentControl(elm.parentElement);
  return null;
}
function getParentControlById(elm, id) {
  if (elm.parentElement instanceof Control) {
    if (elm.parentElement[id] instanceof Control)
      return elm.parentElement[id];
    else
      return getParentControlById(elm.parentElement, id);
  }
  ;
  return null;
}
var toNumberValue = (value) => {
  return parseFloat(value.replace("px", ""));
};
var _refreshTimeout;
function refresh() {
  if (!document.body.style.opacity)
    document.body.style.opacity = "0";
  clearTimeout(_refreshTimeout);
  _refreshTimeout = setTimeout(() => {
    try {
      clearTimeout(_refreshTimeout);
      _refreshTimeout = void 0;
      for (let i = 0; i < document.body.childNodes.length; i++) {
        let node = document.body.childNodes[i];
        if (node instanceof Container && node.nodeName !== "I-MODAL") {
          node.style.position = "absolute";
          node.style.width = "100%";
          node.style.height = "100%";
          node.refresh();
        }
      }
    } finally {
      document.body.style.opacity = "1";
    }
  }, 10);
}
window.addEventListener("resize", () => {
  refresh();
});
var SpaceValue = class {
  constructor(owner, value, prop) {
    this._owner = owner;
    this._value = value;
    this._prop = prop;
    this.update();
  }
  get left() {
    return this._value.left;
  }
  set left(value) {
    this._value.left = value;
    this.update();
  }
  get top() {
    return this._value.top;
  }
  set top(value) {
    this._value.top = value;
    this.update();
  }
  get right() {
    return this._value.right;
  }
  set right(value) {
    this._value.right = value;
    this.update();
  }
  get bottom() {
    return this._value.bottom;
  }
  set bottom(value) {
    this._value.bottom = value;
    this.update();
  }
  getSpacingValue(value) {
    if (value === "")
      return "0px";
    const isNumber = !Number.isNaN(Number(value));
    if (typeof value === "number" || isNumber)
      return value + "px";
    if (value === "auto")
      return value;
    const unit = value.replace(/^-?\d+(\.\d+)?/g, "");
    const number = value.replace(unit, "");
    const isValidUnit = ["px", "em", "rem", "%"].includes(unit);
    return isValidUnit ? value : `${number}px`;
  }
  update(value) {
    if (value)
      this._value = value;
    const { top = 0, right = 0, bottom = 0, left = 0 } = this._value;
    switch (this._prop) {
      case "margin":
        this._owner.style.margin = `${this.getSpacingValue(top)} ${this.getSpacingValue(right)} ${this.getSpacingValue(bottom)} ${this.getSpacingValue(left)}`;
        break;
      case "padding":
        this._owner.style.padding = `${this.getSpacingValue(top)} ${this.getSpacingValue(right)} ${this.getSpacingValue(bottom)} ${this.getSpacingValue(left)}`;
        break;
    }
    ;
  }
};
var DefaultBorderSideStyles = {
  width: void 0,
  style: void 0,
  color: void 0
};
var DefaultAnchor = { top: true, left: true, right: false, bottom: false };
var Border = class {
  constructor(target, options) {
    this._styleClassMap = {};
    this._target = target;
    if (options)
      this.updateValue(options);
  }
  updateValue(options) {
    if (options && Object.keys(options).length) {
      this.updateAllSidesProps(options);
    } else {
      this.removeStyles();
    }
  }
  isNumber(value) {
    if (value === void 0 || value === "")
      return false;
    return !Number.isNaN(Number(value));
  }
  updateAllSidesProps(options) {
    this._width = this.isNumber(options.width) ? options.width + "px" : options.width || "";
    this._style = options.style || "solid";
    this._color = options.color || "";
    this._radius = this.isNumber(options.radius) ? options.radius + "px" : options.radius || "";
    this._top = options.top || {};
    this._right = options.right || {};
    this._bottom = options.bottom || {};
    this._left = options.left || {};
    this.setBorderStyles({
      width: this._width,
      style: this._style,
      color: this._color,
      radius: this._radius,
      top: this._top,
      right: this._right,
      bottom: this._bottom,
      left: this._left
    });
  }
  removeStyles() {
    this.removeStyleClass("left");
    this.removeStyleClass("bottom");
    this.removeStyleClass("right");
    this.removeStyleClass("top");
    this.removeStyleClass("style");
    this.removeStyleClass("color");
    this.removeStyleClass("radius");
    this.removeStyleClass("width");
  }
  get radius() {
    return this._radius;
  }
  set radius(value) {
    if (this.isNumber(value)) {
      this._radius = value + "px";
      this._target.style.borderRadius = value + "px";
    } else if (typeof value === "string") {
      this._radius = value;
      this._target.style.borderRadius = value;
    }
  }
  get width() {
    return this._width;
  }
  set width(value) {
    if (this.isNumber(value)) {
      this._width = value + "px";
    } else if (typeof value === "string") {
      this._width = value;
    }
    this.setBorderProp("width", this._width);
  }
  get style() {
    return this._style;
  }
  set style(value) {
    this._style = value;
    this.setBorderProp("style", this._style);
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this.setBorderProp("color", this._color);
  }
  get top() {
    if (!this._top) {
      this._top = { ...DefaultBorderSideStyles };
    }
    return this._top;
  }
  set top(value) {
    this._top = value;
    this.setSideBorderStyles("top", value);
  }
  get right() {
    if (!this._right) {
      this._right = { ...DefaultBorderSideStyles };
    }
    return this._right;
  }
  set right(value) {
    this._right = value;
    this.setSideBorderStyles("right", value);
  }
  get bottom() {
    if (!this._bottom) {
      this._bottom = { ...DefaultBorderSideStyles };
    }
    return this._bottom;
  }
  set bottom(value) {
    this._bottom = value;
    this.setSideBorderStyles("bottom", value);
  }
  get left() {
    if (!this._left) {
      this._left = { ...DefaultBorderSideStyles };
    }
    return this._left;
  }
  set left(value) {
    this._left = value;
    this.setSideBorderStyles("left", value);
  }
  removeStyleClass(name) {
    const style2 = this._styleClassMap[name];
    if (style2) {
      this._target.classList.remove(style2);
      delete this._styleClassMap[name];
    }
  }
  setSideBorderStyles(side, value) {
    if (value && (value.width !== void 0 || value.style || value.color !== void 0)) {
      let style2 = getBorderSideStyleClass(side, value);
      this.removeStyleClass(side);
      this._styleClassMap[side] = style2;
      this._target.classList.add(style2);
    }
  }
  setBorderStyles(value) {
    let style2 = getBorderStyleClass(value);
    this.removeStyles();
    this._styleClassMap["width"] = style2;
    this._styleClassMap["style"] = style2;
    this._styleClassMap["color"] = style2;
    this._styleClassMap["radius"] = style2;
    this._target.classList.add(style2);
  }
  setBorderProp(prop, value) {
    let style2 = getBorderStyleClass({ [prop]: value });
    this.removeStyleClass("left");
    this.removeStyleClass("bottom");
    this.removeStyleClass("right");
    this.removeStyleClass("top");
    this.removeStyleClass(prop);
    this._styleClassMap[prop] = style2;
    this._target.classList.add(style2);
  }
};
var Overflow = class {
  constructor(target, value) {
    this._target = target;
    if (value) {
      this.updateValue(value);
      this.setOverflowStyle();
    }
  }
  get x() {
    var _a, _b;
    return (_b = (_a = this._value) == null ? void 0 : _a.x) != null ? _b : "visible";
  }
  set x(value) {
    if (!this._value) {
      this._value = { x: value };
    } else {
      this._value.x = value;
    }
    this.setOverflowStyle();
  }
  get y() {
    var _a, _b;
    return (_b = (_a = this._value) == null ? void 0 : _a.y) != null ? _b : "visible";
  }
  set y(value) {
    if (!this._value) {
      this._value = { x: value };
    } else {
      this._value.y = value;
    }
    this.setOverflowStyle();
  }
  updateValue(value) {
    if (typeof value === "string") {
      this._value = { x: value, y: value };
    } else {
      this._value = value;
    }
  }
  setOverflowStyle(value) {
    if (value) {
      this.updateValue(value);
    }
    let style2 = getOverflowStyleClass(this._value);
    if (this._style) {
      this._target.classList.remove(this._style);
    }
    this._style = style2;
    this._target.classList.add(style2);
  }
};
var Background = class {
  constructor(target, value) {
    this._target = target;
    value && this.setBackgroundStyle(value);
  }
  get color() {
    var _a;
    return ((_a = this._value) == null ? void 0 : _a.color) || "";
  }
  set color(value) {
    if (!this._value) {
      this._value = { color: value };
    } else {
      this._value.color = value;
    }
    this.setBackgroundStyle();
  }
  get image() {
    var _a;
    return ((_a = this._value) == null ? void 0 : _a.image) || "";
  }
  set image(value) {
    if (!this._value) {
      this._value = { image: value };
    } else {
      this._value.image = value;
    }
    this.setBackgroundStyle();
  }
  updateValue(value) {
    this._value = value;
  }
  setBackgroundStyle(value) {
    value && this.updateValue(value);
    let style2 = getBackgroundStyleClass(this._value);
    this._style && this._target.classList.remove(this._style);
    this._style = style2;
    this._target.classList.add(style2);
  }
};
var ControlProperties = {
  props: {
    dock: { type: "string", default: "none", values: ["none", "fill", "left", "top", "right", "bottom"] },
    top: { type: "number", default: "auto" },
    left: { type: "number", default: "auto" },
    right: { type: "number", default: "auto" },
    bottom: { type: "number", default: "auto" },
    width: { type: "number", default: "auto" },
    height: { type: "number", default: "auto" },
    minWidth: { type: "number", default: "auto" },
    minHeight: { type: "number", default: "auto" },
    maxWidth: { type: "number", default: "auto" },
    maxHeight: { type: "number", default: "auto" },
    visible: { type: "boolean", default: true },
    enabled: { type: "boolean", default: true },
    background: { type: "object", default: { color: "", image: "" } },
    margin: { type: "object", default: {} },
    padding: { type: "object", default: {} },
    opacity: { type: "string", default: "1" },
    position: { type: "string", default: "" },
    overflow: { type: "object", default: { x: "", y: "" } },
    zIndex: { type: "string", default: "" },
    border: { type: "object", default: {} },
    display: { type: "string", default: "" },
    mediaQueries: { type: "array", default: [] },
    font: { type: "object", default: { color: "", size: "", name: "", shadow: "", style: "normal", transform: "none", weight: "", bold: false } },
    stack: { type: "object", default: { basis: "", grow: "", shrink: "" } },
    class: { type: "string" },
    cursor: { type: "string", default: "auto" },
    boxShadow: { type: "string", default: "" }
  },
  events: {
    onClick: notifyEventParams,
    onContextMenu: notifyEventParams,
    onDblClick: notifyEventParams,
    onFocus: notifyEventParams,
    onKeyDown: notifyEventParams,
    onKeyUp: notifyEventParams,
    onMouseDown: notifyEventParams,
    onMouseMove: notifyEventParams,
    onMouseUp: notifyEventParams
  }
};
var Control = class extends Component {
  constructor(parent, options, defaults) {
    super(parent, options, defaults);
    this._controls = [];
    this._enabled = true;
    this._visible = true;
    this._designMode = false;
    this.propertyClassMap = {};
    this.parent = parent;
  }
  static async create(options, parent, defaults) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  _setDesignPropValue(prop, value, breakpointProp) {
    super._setDesignPropValue(prop, value, breakpointProp);
    if (ControlProperties.props[prop] && prop !== "mediaQueries") {
      if (typeof breakpointProp === "object" && typeof value === "object") {
        this[prop] = { ...value, ...breakpointProp };
      } else
        this[prop] = breakpointProp != null ? breakpointProp : value;
    }
    ;
  }
  _getCustomProperties() {
    let result = {
      props: {},
      events: {}
    };
    for (let n in ComponentProperty.props)
      result.props[n] = ComponentProperty.props[n];
    for (let n in ComponentProperty.events)
      result.events[n] = ComponentProperty.events[n];
    for (let n in ControlProperties.props)
      result.props[n] = ControlProperties.props[n];
    for (let n in ControlProperties.events)
      result.events[n] = ControlProperties.events[n];
    let propInfo = getCustomElementProperties(this.tagName);
    if (propInfo) {
      result.tagName = propInfo.tagName;
      result.className = propInfo.className;
      result.icon = propInfo.icon;
      for (let n in propInfo.props)
        result.props[n] = propInfo.props[n];
      for (let n in propInfo.events)
        result.events[n] = propInfo.events[n];
    }
    ;
    result.dataSchema = JSON.parse(JSON.stringify((propInfo == null ? void 0 : propInfo.dataSchema) || {}));
    return result;
  }
  getMarginStyle() {
    const computedStyle = window.getComputedStyle(this);
    const left = toNumberValue(computedStyle.marginLeft);
    const right = toNumberValue(computedStyle.marginRight);
    const bottom = toNumberValue(computedStyle.marginBottom);
    const top = toNumberValue(computedStyle.marginTop);
    return { top, right, bottom, left };
  }
  getPaddingStyle() {
    const computedStyle = window.getComputedStyle(this);
    const left = toNumberValue(computedStyle.paddingLeft);
    const right = toNumberValue(computedStyle.paddingRight);
    const bottom = toNumberValue(computedStyle.paddingBottom);
    const top = toNumberValue(computedStyle.paddingTop);
    return { top, right, bottom, left };
  }
  xssSanitize(value) {
    return DOMPurify.sanitize(value);
  }
  get contextMenu() {
    if (this._contextMenuId && !this._contextMenuControl)
      this._contextMenuControl = getParentControlById(this, this._contextMenuId);
    return this._contextMenuControl;
  }
  set contextMenu(value) {
    if (typeof value === "string") {
      this._contextMenuId = value;
      this._contextMenuControl = null;
    } else if (value instanceof Control) {
      this._contextMenuId = value.id;
      this._contextMenuControl = value;
    } else {
      this._contextMenuId = null;
      this._contextMenuControl = null;
    }
    ;
  }
  get margin() {
    return this._margin;
  }
  set margin(value) {
    if (!this._margin)
      this._margin = new SpaceValue(this, value, "margin");
    else
      this._margin.update(value);
  }
  get marginStyle() {
    return (side) => this.getMarginStyle()[side];
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (!this._padding)
      this._padding = new SpaceValue(this, value, "padding");
    else
      this._padding.update(value);
  }
  get paddingStyle() {
    return (side) => this.getPaddingStyle()[side];
  }
  addChildControl(control) {
    if (!control.parentNode)
      this.appendChild(control);
  }
  removeChildControl(control) {
    if (this.contains(control))
      this.removeChild(control);
  }
  get parent() {
    return this._parent;
  }
  set parent(value) {
    if (value && value._controls.indexOf(this) < 0)
      value._controls.push(this);
    if (this._parent != value) {
      if (this._parent) {
        if (this._parent._controls.indexOf(this) > -1)
          this._parent._controls.splice(this._parent._controls.indexOf(this), 1);
        this._parent.removeChildControl(this);
        if (!_refreshTimeout)
          this._parent.refresh();
      }
      ;
      this._parent = value;
      if (this._parent) {
        this._parent.addChildControl(this);
        if (!_refreshTimeout)
          this._parent.refresh();
      }
    }
  }
  connectedCallback() {
    super.connectedCallback();
    refresh();
    if (!this.mediaQueries)
      this.setAttributeToProperty("mediaQueries");
  }
  disconnectedCallback() {
    if (this._tooltip) {
      this._tooltip.close();
    }
    super.disconnectedCallback();
  }
  getParentHeight() {
    if (!this._parent)
      return window.innerHeight;
    else if (this._parent._container)
      return this._parent._container.offsetHeight;
    else
      return this._parent.offsetHeight;
  }
  getParentWidth() {
    if (!this._parent)
      return window.innerWidth;
    else if (this._parent._container)
      return this._parent._container.offsetWidth;
    else {
      return this._parent.offsetWidth;
    }
  }
  getParentOccupiedLeft() {
    if (!this._parent)
      return 0;
    else {
      let result = this._parent.paddingStyle("left");
      for (let i = 0; i < this._parent._controls.length; i++) {
        let control = this._parent._controls[i];
        if (control === this) {
          if (this.dock == "left")
            return result;
        } else if (control.visible && control.dock == "left") {
          result += control.offsetWidth + control.marginStyle("left");
        }
      }
      ;
      return result;
    }
    ;
  }
  getParentOccupiedRight() {
    if (!this._parent)
      return 0;
    else {
      let result = this._parent.paddingStyle("right");
      for (let i = 0; i < this._parent._controls.length; i++) {
        let control = this._parent._controls[i];
        if (control === this) {
          if (this.dock == "right")
            return result;
        } else if (control.dock == "right") {
          result += control.offsetWidth + control.marginStyle("right");
        }
      }
      ;
      return result;
    }
    ;
  }
  getParentOccupiedBottom() {
    if (!this._parent)
      return 0;
    else {
      let result = this._parent.paddingStyle("bottom");
      for (let i = 0; i < this._parent._controls.length; i++) {
        let control = this._parent._controls[i];
        if (control === this) {
          if (this.dock == "bottom")
            return result;
        } else if (control.visible && control.dock == "bottom") {
          result += control.offsetHeight + control.marginStyle("bottom");
        }
      }
      ;
      return result;
    }
    ;
  }
  getParentOccupiedTop() {
    if (!this._parent)
      return 0;
    else {
      let result = this._parent.paddingStyle("top");
      for (let i = 0; i < this._parent._controls.length; i++) {
        let control = this._parent._controls[i];
        if (control === this) {
          if (this.dock == "top")
            return result;
        } else if (control.visible && control.dock == "top") {
          result += control.offsetHeight + control.marginStyle("top");
        }
      }
      ;
      return result;
    }
    ;
  }
  get dock() {
    return this._dock || "";
  }
  set dock(value) {
    this._dock = value;
    if (this._resizer)
      this._resizer.reset();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    if (this._enabled != value) {
      this._enabled = value;
      if (value) {
        this.classList.remove("disabled");
        this.classList.remove(disabledStyle);
      } else {
        this.classList.add("disabled");
        this.classList.add(disabledStyle);
      }
    }
  }
  _handleClick(event, stopPropagation) {
    if (this._onClick && typeof this._onClick === "function") {
      this._onClick(this, event);
      return true;
    } else if (!stopPropagation) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleClick = parent._handleClick.bind(parent);
      return parent._handleClick(event);
    } else
      return true;
  }
  _handleContextMenu(event, stopPropagation) {
    let contextMenu = this.contextMenu;
    if (contextMenu) {
      contextMenu.show({ x: event.clientX, y: event.clientY });
    }
    ;
    if (this._onContextMenu) {
      this._onContextMenu(this, event);
      return true;
    } else if (!stopPropagation && !contextMenu) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleContextMenu = parent._handleContextMenu.bind(parent);
      return parent._handleContextMenu(event);
    } else
      return true;
  }
  _handleDblClick(event, stopPropagation) {
    if (this._onDblClick) {
      this._onDblClick(this, event);
      return true;
    } else if (!stopPropagation) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleDblClick = parent._handleDblClick.bind(parent);
      return parent._handleDblClick(event);
    } else
      return true;
  }
  _handleFocus(event, stopPropagation) {
    if (this._onFocus) {
      this._onFocus(this, event);
      return true;
    } else if (!stopPropagation) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleFocus = parent._handleFocus.bind(parent);
      return parent._handleFocus(event);
    } else
      return true;
  }
  _handleKeyDown(event, stopPropagation) {
    if (this._onKeyDown) {
      this._onKeyDown(this, event);
      return true;
    } else if (!stopPropagation) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleKeyDown = parent._handleKeyDown.bind(parent);
      return parent._handleKeyDown(event);
    } else
      return true;
  }
  _handleKeyUp(event, stopPropagation) {
    if (this._onKeyUp) {
      this._onKeyUp(this, event);
      return true;
    } else if (!stopPropagation) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleKeyUp = parent._handleKeyUp.bind(parent);
      return parent._handleKeyUp(event);
    } else
      return true;
  }
  _handleMouseDown(event, stopPropagation) {
    if (this._onMouseDown) {
      this._onMouseDown(this, event);
      return true;
    } else if (!stopPropagation) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleMouseDown = parent._handleMouseDown.bind(parent);
      return parent._handleMouseDown(event);
    } else
      return true;
  }
  _handleMouseMove(event, stopPropagation) {
    if (this._onMouseMove) {
      this._onMouseMove(this, event);
      return true;
    } else if (!stopPropagation) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleMouseMove = parent._handleMouseMove.bind(parent);
      return parent._handleMouseMove(event);
    } else
      return true;
  }
  _handleMouseUp(event, stopPropagation) {
    if (this._onMouseUp) {
      this._onMouseUp(this, event);
      return true;
    } else if (!stopPropagation) {
      let parent = getParentControl(this);
      if (!parent)
        return false;
      parent._handleMouseUp = parent._handleMouseUp.bind(parent);
      return parent._handleMouseUp(event);
    } else
      return true;
  }
  get maxWidth() {
    return this.style.maxWidth;
  }
  set maxWidth(value) {
    if (!isNaN(Number(value))) {
      this.style.maxWidth = value + "px";
    } else {
      this.style.maxWidth = value + "";
    }
  }
  get minWidth() {
    return this.style.minWidth;
  }
  set minWidth(value) {
    if (!isNaN(Number(value))) {
      this.style.minWidth = value + "px";
    } else {
      this.style.minWidth = value + "";
    }
  }
  get designMode() {
    var _a;
    return (_a = this._designMode) != null ? _a : false;
  }
  set designMode(value) {
    this._designMode = value != null ? value : false;
  }
  observables(propName) {
    let self = this;
    if (self["$observables"] && self["$observables"][propName])
      return self["$observables"][propName];
  }
  get onClick() {
    return this._onClick;
  }
  set onClick(callback) {
    this._onClick = callback;
  }
  get onContextMenu() {
    return this._onContextMenu;
  }
  set onContextMenu(callback) {
    this._onContextMenu = callback;
  }
  get onDblClick() {
    return this._onDblClick;
  }
  set onDblClick(callback) {
    this._onDblClick = callback;
  }
  get onMouseDown() {
    return this._onMouseDown;
  }
  set onMouseDown(callback) {
    this._onMouseDown = callback;
  }
  get onMouseUp() {
    return this._onMouseUp;
  }
  set onMouseUp(callback) {
    this._onMouseUp = callback;
  }
  clearInnerHTML() {
    this.innerHTML = "";
  }
  refresh() {
    if (this._dock != null) {
      if (!this.position)
        this.style.position = "absolute";
      switch (this.dock) {
        case "none": {
          if (this.anchor.top === false)
            this.top = (this.getParentHeight() - this.offsetHeight) / 2;
          if (this.anchor.left === false)
            this.left = (this.getParentWidth() - this.offsetWidth) / 2;
          break;
        }
        case "left": {
          let top = this.getParentOccupiedTop();
          this.top = top;
          this.left = this.getParentOccupiedLeft();
          this.height = this.getParentHeight() - top - this.getParentOccupiedBottom() - this.marginStyle("top") - this.marginStyle("bottom");
          break;
        }
        case "top": {
          this.top = this.getParentOccupiedTop();
          this.width = this.getParentWidth();
          if (this.anchor.left)
            this.left = 0;
          else
            this.left = (this.getParentWidth() - this.offsetWidth) / 2;
          break;
        }
        case "right": {
          let top = this.getParentOccupiedTop();
          this.top = top;
          this.left = this.getParentWidth() - this.getParentOccupiedRight() - this.offsetWidth;
          this.height = this.getParentHeight() - top - this.getParentOccupiedBottom();
          break;
        }
        case "bottom":
          this.top = this.getParentHeight() - this.getParentOccupiedBottom() - this.offsetHeight;
          this.left = 0;
          this.width = this.getParentWidth();
          break;
        case "fill":
          this.width = this.getParentWidth() - this.getParentOccupiedLeft() - this.getParentOccupiedRight();
          this.height = this.getParentHeight() - this.getParentOccupiedTop() - this.getParentOccupiedBottom();
          this.left = this.getParentOccupiedLeft();
          this.top = this.getParentOccupiedTop();
          break;
        case "center":
          this.left = (this.getParentWidth() - this.offsetWidth) / 2;
          this.top = (this.getParentHeight() - this.offsetHeight) / 2;
          break;
      }
    }
    ;
  }
  get resizable() {
    return this.attrs["resizer"] == true && ["left", "top", "right", "bottom"].indexOf(this.dock) >= 0;
  }
  setProperty(propName, value) {
    if (value == null ? void 0 : value.__target) {
      let target = value.__target;
      let path = value.__path;
      this[propName] = target[path[0]];
      Observe(target.observables(path[0]), (changes) => {
        let change = changes[0];
        this[propName] = change.value;
      });
    } else {
      this.setAttribute(propName, value);
    }
  }
  setAttributeToProperty(propertyName) {
    const prop = this.getAttribute(propertyName, true);
    if (prop !== null && prop !== void 0)
      this[propertyName] = prop;
  }
  init() {
    super.init();
    this.setAttributeToProperty("height");
    this.setAttributeToProperty("left");
    this.setAttributeToProperty("top");
    this.setAttributeToProperty("right");
    this.setAttributeToProperty("bottom");
    this.setAttributeToProperty("width");
    this.setAttributeToProperty("dock");
    this.setAttributeToProperty("margin");
    this.setAttributeToProperty("padding");
    this.setAttributeToProperty("tag");
    this.setAttributeToProperty("anchor");
    this.setAttributeToProperty("contextMenu");
    this.setAttributeToProperty("maxWidth");
    this.setAttributeToProperty("minWidth");
    this.setAttributeToProperty("stack");
    this.setAttributeToProperty("grid");
    this.setAttributeToProperty("display");
    this.setAttributeToProperty("position");
    if ((this._left != null || this._top != null) && !this.position)
      this.style.position = "absolute";
    if (this.getAttribute("enabled") !== false)
      this.classList.add("enabled");
    else
      this.enabled = false;
    if (this.getAttribute("visible") == false)
      this.visible = false;
    this.setAttributeToProperty("background");
    this.setAttributeToProperty("zIndex");
    this.setAttributeToProperty("lineHeight");
    this.setAttributeToProperty("linkTo");
    this.setAttributeToProperty("maxHeight");
    this.setAttributeToProperty("minHeight");
    this.setAttributeToProperty("opacity");
    const tooltip = this.getAttribute("tooltip", true);
    tooltip && (this._tooltip = new Tooltip(this));
    const font = this.getAttribute("font", true);
    font && (this.font = font);
    let border = this.getAttribute("border", true);
    if (border) {
      this.border = new Border(this, border);
    }
    this.setAttributeToProperty("overflow");
    this.setAttributeToProperty("cursor");
    this.setAttributeToProperty("letterSpacing");
    this.setAttributeToProperty("boxShadow");
    this.setAttributeToProperty("designMode");
  }
  setElementPosition(elm, prop, value) {
    if (value != null && !isNaN(value)) {
      this["_" + prop] = parseFloat(value);
      elm.style[prop] = parseFloat(value) + "px";
    } else if (value != null) {
      this["_" + prop] = value;
      elm.style[prop] = value;
    }
  }
  setPosition(prop, value) {
    if (value != null && !isNaN(value)) {
      this["_" + prop] = parseFloat(value);
      this.style[prop] = parseFloat(value) + "px";
    } else if (value != null) {
      this["_" + prop] = value;
      this.style[prop] = value;
    }
    ;
  }
  get height() {
    return !isNaN(this._height) ? this._height : this.offsetHeight;
  }
  set height(value) {
    this.setPosition("height", value);
  }
  get heightValue() {
    if (typeof this._height == "string")
      return parseInt(this._height, 10);
    else
      return this._height;
  }
  get left() {
    return !isNaN(this._left) ? this._left : this.offsetLeft;
  }
  set left(value) {
    if (!this.dock)
      this.dock = "none";
    this.setPosition("left", value);
  }
  set right(value) {
    if (!this.dock)
      this.dock = "none";
    this.setPosition("right", value);
  }
  set bottom(value) {
    if (!this.dock)
      this.dock = "none";
    this.setPosition("bottom", value);
  }
  get top() {
    return !isNaN(this._top) ? this._top : this.offsetTop;
  }
  set top(value) {
    if (!this.dock)
      this.dock = "none";
    this.setPosition("top", value);
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    if (!this._visible)
      this.style.display = "none";
    else if (this._left != null || this._top != null)
      this.style.display = "";
    else
      this.style.display = "";
    if (this._parent && !_refreshTimeout)
      this._parent.refresh();
  }
  get width() {
    return !isNaN(this._width) ? this._width : this.offsetWidth;
  }
  set width(value) {
    this.setPosition("width", value);
  }
  get widthValue() {
    if (typeof this._width == "string")
      return parseInt(this._width, 10);
    else
      return this._width;
  }
  get stack() {
    return this._stack;
  }
  set stack(value) {
    this._stack = value;
    this.style.flexBasis = value.basis || "";
    this.style.flexGrow = value.grow || "";
    this.style.flexShrink = value.shrink || "";
  }
  get grid() {
    return this._grid;
  }
  set grid(value) {
    this._grid = value;
    if (value.column && value.columnSpan)
      this.style.gridColumn = value.column + " / span " + value.columnSpan;
    else if (value.column)
      this.style.gridColumnStart = value.column.toString();
    else if (value.columnSpan)
      this.style.gridColumn = "span " + value.columnSpan;
    if (value.row && value.rowSpan)
      this.style.gridRow = value.row + " / span " + value.rowSpan;
    else if (value.row)
      this.style.gridRowStart = value.row.toString();
    else if (value.rowSpan)
      this.style.gridRow = "span " + value.rowSpan;
    if (value.area)
      this.style.gridArea = value.area;
    if (value.horizontalAlignment)
      this.style.justifyContent = value.horizontalAlignment;
    if (value.verticalAlignment)
      this.style.alignItems = value.verticalAlignment;
  }
  get background() {
    if (!this._background) {
      this._background = new Background(this);
    }
    return this._background;
  }
  set background(value) {
    if (!this._background) {
      this._background = new Background(this, value);
    } else {
      this._background.setBackgroundStyle(value);
    }
  }
  get zIndex() {
    return this._zIndex;
  }
  set zIndex(value) {
    this.style.zIndex = value + "";
    this._zIndex = value + "";
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(value) {
    this._lineHeight = value;
    this.style.lineHeight = "" + value;
  }
  get linkTo() {
    return this._linkTo;
  }
  set linkTo(value) {
    this._linkTo = value;
  }
  get position() {
    return this.style.position;
  }
  set position(value) {
    this.style.position = value;
  }
  get maxHeight() {
    return this.style.maxHeight;
  }
  set maxHeight(value) {
    if (!isNaN(Number(value))) {
      this.style.maxHeight = value + "px";
    } else {
      this.style.maxHeight = value + "";
    }
  }
  get minHeight() {
    return this.style.minHeight;
  }
  set minHeight(value) {
    if (!isNaN(Number(value))) {
      this.style.minHeight = value + "px";
    } else {
      this.style.minHeight = value + "";
    }
  }
  get border() {
    if (!this._border) {
      this._border = new Border(this);
    }
    return this._border;
  }
  set border(value) {
    if (!this.border) {
      this._border = new Border(this, value);
    } else {
      this._border.updateValue(value);
    }
  }
  get overflow() {
    if (!this._overflow) {
      this._overflow = new Overflow(this);
    }
    return this._overflow;
  }
  set overflow(value) {
    if (!this._overflow) {
      this._overflow = new Overflow(this, value);
    } else {
      this._overflow.setOverflowStyle(value);
    }
  }
  get tooltip() {
    if (!this._tooltip) {
      this._tooltip = new Tooltip(this);
    }
    return this._tooltip;
  }
  get font() {
    return {
      color: this.style.color,
      name: this.style.fontFamily,
      size: this.style.fontSize,
      bold: this.style.fontStyle.indexOf("bold") >= 0,
      style: this.style.fontStyle,
      transform: this.style.textTransform,
      weight: this.style.fontWeight,
      shadow: this.style.textShadow
    };
  }
  set font(value) {
    this.style.color = value.color || "";
    this.style.fontSize = value.size || "";
    this.style.fontFamily = value.name || "";
    this.style.fontStyle = value.style || "";
    this.style.textTransform = value.transform || "none";
    this.style.fontWeight = value.bold ? "bold" : `${value.weight || ""}`;
    this.style.textShadow = value.shadow || "none";
  }
  get display() {
    return this._display;
  }
  set display(value) {
    this._display = value;
    this.style.display = this.visible === false ? "none" : value;
  }
  get anchor() {
    return this._anchor || DefaultAnchor;
  }
  set anchor(value) {
    const data = { ...DefaultAnchor, ...value };
    this._anchor = data;
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(value) {
    this._opacity = typeof value === "string" ? value : `${value}`;
    if (this._opacity) {
      const style2 = getOpacityStyleClass(value);
      this.setStyle("opacity", style2);
    } else {
      this.removeStyle("opacity");
    }
  }
  get cursor() {
    return this.style.cursor;
  }
  set cursor(value) {
    this.style.cursor = value;
  }
  get letterSpacing() {
    return this.style.letterSpacing;
  }
  set letterSpacing(value) {
    if (!isNaN(Number(value))) {
      this.style.letterSpacing = value + "px";
    } else {
      this.style.letterSpacing = value + "";
    }
  }
  get boxShadow() {
    return this.style.boxShadow;
  }
  set boxShadow(value) {
    this.style.boxShadow = value;
  }
  get mediaQueries() {
    return this._cmediaQueries;
  }
  set mediaQueries(value) {
    this._cmediaQueries = value;
    let style2 = getControlMediaQueriesStyleClass(this._cmediaQueries, { display: this.display });
    this._mediaStyle && this.classList.remove(this._mediaStyle);
    this._mediaStyle = style2;
    this.classList.add(style2);
  }
  removeStyle(propertyName) {
    let style2 = this.propertyClassMap[propertyName];
    if (style2)
      this.classList.remove(style2);
  }
  setStyle(propertyName, value) {
    this.removeStyle(propertyName);
    if (value) {
      this.propertyClassMap[propertyName] = value;
      this.classList.add(value);
    }
  }
};
var ContainerResizer = class {
  constructor(target) {
    this.target = target;
    this._mouseDownHandler = this.handleMouseDown.bind(this);
    this._mouseUpHandler = this.handleMouseUp.bind(this);
    this._mouseMoveHandler = this.handleMouseMove.bind(this);
  }
  reset() {
    if (!this.target.resizable && this._resizer) {
      this._resizer.removeEventListener("mousedown", this._mouseDownHandler);
      this.target.removeChild(this._resizer);
      this._resizer = void 0;
    } else if (this.target.resizable) {
      switch (this.target.dock) {
        case "left":
          this.resizer.classList.value = "resizer e-resize";
          break;
        case "top":
          this.resizer.classList.value = "resizer s-resize";
          break;
        case "right":
          this.resizer.classList.value = "resizer w-resize";
          break;
        case "bottom":
          this.resizer.classList.value = "resizer n-resize";
          break;
      }
      ;
    }
    ;
  }
  handleMouseDown(e) {
    this.target.classList.add("resizing");
    this._origHeight = this.target.offsetHeight;
    this._origWidth = this.target.offsetWidth;
    if (this._resizer) {
      this._resizer.classList.add("highlight");
      this._mouseDownPos = {
        x: e.clientX,
        y: e.clientY
      };
      document.addEventListener("mousemove", this._mouseMoveHandler);
      document.addEventListener("mouseup", this._mouseUpHandler);
    }
  }
  handleMouseMove(e) {
    var _a, _b, _c, _d;
    e.preventDefault();
    e.stopPropagation();
    let offsetX = e.clientX - this._mouseDownPos.x;
    let offsetY = e.clientY - this._mouseDownPos.y;
    switch (this.target.dock) {
      case "left":
        this.target.style.width = this._origWidth + offsetX + "px";
        (_a = this.target.parent) == null ? void 0 : _a.refresh();
        break;
      case "top":
        this.target.style.height = this._origHeight + offsetY + "px";
        (_b = this.target.parent) == null ? void 0 : _b.refresh();
        break;
      case "right":
        this.target.style.width = this._origWidth - offsetX + "px";
        (_c = this.target.parent) == null ? void 0 : _c.refresh();
        break;
      case "bottom":
        this.target.style.height = this._origHeight - offsetY + "px";
        (_d = this.target.parent) == null ? void 0 : _d.refresh();
        break;
    }
  }
  handleMouseUp(e) {
    document.removeEventListener("mousemove", this._mouseMoveHandler);
    document.removeEventListener("mouseup", this._mouseUpHandler);
    this.target.classList.remove("resizing");
    if (this._resizer)
      this._resizer.classList.remove("highlight");
  }
  get resizer() {
    if (!this._resizer) {
      this._resizer = document.createElement("span");
      this.target.appendChild(this._resizer);
      this._resizer.addEventListener("mousedown", this._mouseDownHandler);
    }
    ;
    return this._resizer;
  }
};
var Container = class extends Control {
  get controls() {
    return this._controls;
  }
  get resizer() {
    return this.attrs["resizer"] == true;
  }
  set resizer(value) {
    this.attrs["resizer"] = value;
    if (this.resizable && !this._resizer)
      this._resizer = new ContainerResizer(this);
    if (this._resizer)
      this._resizer.reset();
  }
  init() {
    super.init();
    this.classList.add(containerStyle);
    if (this.resizable && !this._resizer) {
      this._resizer = new ContainerResizer(this);
      this._resizer.reset();
    }
    ;
  }
  refreshControls() {
    for (let i = 0; i < this._controls.length; i++)
      this._controls[i].refresh();
  }
  refresh(skipRefreshControls) {
    super.refresh();
    for (let i = 0; i < this.childNodes.length; i++) {
      let node = this.childNodes[i];
      if (node instanceof Control) {
        node.parent = this;
      }
      ;
    }
    ;
    if (!skipRefreshControls)
      this.refreshControls();
  }
};

// packages/base/src/index.ts
var scripts = document.getElementsByTagName("script");
var pathname = scripts[scripts.length - 1].src;
var lastIndex = pathname.lastIndexOf("/");
var LibPath = pathname.slice(0, lastIndex + 1);
var RequireJS = {
  config(config) {
    window.require.config(config);
  },
  require(reqs2, callback) {
    window.require(reqs2, callback);
  },
  defined(module2) {
    return window.require.defined(module2);
  }
};
var _customElementProperties = {};
function getCustomElementProperties(name) {
  return _customElementProperties[name == null ? void 0 : name.toLowerCase()];
}
function getCustomElements() {
  return _customElementProperties;
}
function customElements2(tagName, properties) {
  return (constructor) => {
    try {
      if (properties)
        properties.tagName = tagName;
      else
        properties = {
          props: {},
          events: {},
          tagName
        };
      _customElementProperties[tagName] = properties;
      window.customElements.define(tagName, constructor);
    } catch (err) {
    }
  };
}
function customModule(target) {
  _currentDefineModule = target;
}
function setAttributeToProperty(element, propertyName, defaultValue) {
  const prop = element.getAttribute(propertyName, true, defaultValue);
  if (prop)
    element[propertyName] = prop;
}

// packages/application/src/event-bus.ts
var _EventBus = class {
  constructor() {
    this.subscribers = {};
  }
  static getInstance() {
    if (this.instance === void 0) {
      this.instance = new _EventBus();
    }
    return this.instance;
  }
  dispatch(event, arg) {
    const subscriber = this.subscribers[event];
    if (subscriber === void 0) {
      return;
    }
    Object.keys(subscriber).forEach((key2) => subscriber[key2](arg));
  }
  register(sender, event, callback) {
    const id = this.getNextId();
    if (!this.subscribers[event])
      this.subscribers[event] = {};
    this.subscribers[event][id] = callback.bind(sender);
    return {
      unregister: () => {
        delete this.subscribers[event][id];
        if (Object.keys(this.subscribers[event]).length === 0)
          delete this.subscribers[event];
      }
    };
  }
  getNextId() {
    return _EventBus.nextId++;
  }
};
var EventBus = _EventBus;
EventBus.nextId = 0;
EventBus.instance = void 0;

// packages/checkbox/src/style/checkbox.css.ts
var Theme2 = theme_exports.ThemeVars;
cssRule("i-checkbox", {
  fontFamily: Theme2.typography.fontFamily,
  fontSize: Theme2.typography.fontSize,
  userSelect: "none",
  "$nest": {
    ".i-checkbox": {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      maxWidth: "100%"
    },
    ".i-checkbox_input": {
      cursor: "pointer",
      whiteSpace: "nowrap",
      display: "inline-flex",
      position: "relative"
    },
    ".checkmark": {
      width: 15,
      height: 15,
      display: "inline-block",
      position: "relative",
      backgroundColor: Theme2.background.paper,
      border: `1px solid ${Theme2.divider}`,
      boxSizing: "border-box",
      transition: "border-color .25s cubic-bezier(.71,-.46,.29,1.46),background-color .25s cubic-bezier(.71,-.46,.29,1.46)"
    },
    ".i-checkbox_label": {
      boxSizing: "border-box",
      color: Theme2.text.primary,
      display: "inline-block",
      paddingLeft: 8,
      maxWidth: "100%"
    },
    "input": {
      opacity: 0,
      width: 0,
      height: 0,
      position: "absolute",
      top: 0,
      left: 0
    },
    "&.is-checked": {
      "$nest": {
        ".i-checkbox_label": {
          color: Theme2.colors.info.main
        },
        ".checkmark": {
          backgroundColor: Theme2.colors.info.main
        },
        ".checkmark:after": {
          transform: "rotate(45deg) scaleY(1)"
        },
        ".is-indeterminate .checkmark:after": {
          transform: "none"
        }
      }
    },
    "&:not(.disabled):hover input ~ .checkmark": {
      borderColor: Theme2.colors.info.main
    },
    "&.disabled": {
      cursor: "not-allowed"
    },
    ".checkmark:after": {
      content: "''",
      boxSizing: "content-box",
      border: `1px solid ${Theme2.background.paper}`,
      borderLeft: 0,
      borderTop: 0,
      height: 7.5,
      left: "35%",
      top: 1,
      transform: "rotate(45deg) scaleY(0)",
      width: 3.5,
      transition: "transform .15s ease-in .05s",
      transformOrigin: "center",
      display: "inline-block",
      position: "absolute"
    },
    ".is-indeterminate .checkmark": {
      backgroundColor: Theme2.colors.info.main
    },
    ".is-indeterminate .checkmark:after": {
      width: "80%",
      height: 0,
      top: "50%",
      left: "10%",
      borderRight: 0,
      transform: "none"
    }
  }
});

// packages/checkbox/src/checkbox.ts
var DEFAULT_VALUES = {
  indeterminate: false,
  checked: false,
  captionWidth: 0,
  readOnly: false,
  caption: ""
};
var Checkbox = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      height: 30
    });
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    if (!value)
      this.captionSpanElm.style.display = "none";
    else
      this.captionSpanElm.style.display = "";
    this.captionSpanElm && (this.captionSpanElm.innerHTML = value);
  }
  get captionWidth() {
    return this._captionWidth;
  }
  set captionWidth(value) {
    if (!value)
      return;
    this._captionWidth = value;
    this.setElementPosition(this.captionSpanElm, "width", value);
  }
  get height() {
    return this.offsetHeight;
  }
  set height(value) {
    this.setPosition("height", value);
  }
  get indeterminate() {
    return this._indeterminate;
  }
  set indeterminate(value) {
    this._indeterminate = value;
    if (this.inputSpanElm)
      value ? this.inputSpanElm.classList.add("is-indeterminate") : this.inputSpanElm.classList.remove("is-indeterminate");
    this.inputElm.indeterminate = value;
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = value;
    this.addClass(value, "is-checked");
    this.inputElm && (this.inputElm.checked = value);
  }
  get value() {
    return this.inputElm.value;
  }
  set value(data) {
    this.inputElm.value = data;
  }
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(value) {
    this._readOnly = value;
    if (this.inputElm) {
      this.inputElm.readOnly = value;
    }
  }
  _handleChange(event) {
    if (this.readOnly || this._designMode)
      return;
    this.checked = this.inputElm.checked || false;
    this.addClass(this.checked, "is-checked");
    if (typeof this.onChanged === "function")
      this.onChanged(this, event);
  }
  addClass(value, className) {
    if (value)
      this.classList.add(className);
    else
      this.classList.remove(className);
  }
  init() {
    if (!this.captionSpanElm) {
      this.wrapperElm = this.createElement("label", this);
      if (this.height)
        this.wrapperElm.style.height = this.height + "px";
      this.wrapperElm.classList.add("i-checkbox");
      this.inputSpanElm = this.createElement("span", this.wrapperElm);
      this.inputSpanElm.classList.add("i-checkbox_input");
      this.inputElm = this.createElement("input", this.inputSpanElm);
      this.inputElm.type = "checkbox";
      const disabled = this.getAttribute("enabled") === false;
      this.inputElm.disabled = disabled;
      this.readOnly = this.getAttribute("readOnly", true, DEFAULT_VALUES.readOnly);
      this.checkmarklElm = this.createElement("span");
      this.checkmarklElm.classList.add("checkmark");
      this.inputSpanElm.appendChild(this.checkmarklElm);
      this.inputElm.addEventListener("input", this._handleChange.bind(this));
      this.captionSpanElm = this.createElement("span", this.wrapperElm);
      this.captionSpanElm.classList.add("i-checkbox_label");
      this.captionWidth = this.getAttribute("captionWidth", true);
      this.caption = this.getAttribute("caption", true);
      this.value = this.caption;
      this.checked = this.getAttribute("checked", true, DEFAULT_VALUES.checked);
      this.indeterminate = this.getAttribute("indeterminate", true);
      this.onChanged = this.getAttribute("onChanged", true) || this.onChanged;
      super.init();
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Checkbox = __decorateClass([
  customElements2("i-checkbox", {
    icon: "check-square",
    group: GroupType.FIELDS,
    className: "Checkbox",
    props: {
      checked: {
        type: "boolean",
        default: DEFAULT_VALUES.checked
      },
      indeterminate: {
        type: "boolean",
        default: DEFAULT_VALUES.indeterminate
      },
      caption: {
        type: "string",
        default: DEFAULT_VALUES.caption
      },
      captionWidth: {
        type: "number",
        default: DEFAULT_VALUES.captionWidth
      },
      readOnly: {
        type: "boolean",
        default: DEFAULT_VALUES.readOnly
      }
    },
    events: {
      onChanged: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "Event" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        checked: {
          type: "boolean",
          default: DEFAULT_VALUES.checked
        },
        indeterminate: {
          type: "boolean",
          default: DEFAULT_VALUES.indeterminate
        },
        caption: {
          type: "string"
        },
        readOnly: {
          type: "boolean",
          default: DEFAULT_VALUES.readOnly
        }
      }
    }
  })
], Checkbox);

// packages/application/src/globalEvent.ts
function getControl(target) {
  if (target instanceof Control) {
    return target;
  }
  if ((target instanceof HTMLElement || target instanceof SVGElement) && target.parentElement)
    return getControl(target.parentElement);
  return null;
}
var GlobalEvents = class {
  constructor() {
    this._initialTouchPos = false;
    this._handleMouseDown = this._handleMouseDown.bind(this);
    this._handleMouseMove = this._handleMouseMove.bind(this);
    this._handleMouseUp = this._handleMouseUp.bind(this);
    this.bindEvents();
  }
  abortEvent(event) {
    event.stopPropagation();
  }
  _handleClick(event) {
    let control = getControl(event.target);
    if (control && !(control instanceof Checkbox)) {
      if (control.enabled) {
        if (control._handleClick(event)) {
          event.stopPropagation();
        }
        ;
      }
      ;
    }
    ;
  }
  _handleMouseDown(event) {
    const target = event.target;
    let control = getControl(target);
    if (control == null ? void 0 : control.enabled) {
      this._initialTouchPos = true;
      if (control._handleMouseDown(event)) {
        event.stopPropagation();
      }
      if (window.PointerEvent) {
        document.addEventListener("pointermove", this._handleMouseMove, true);
        document.addEventListener("pointerup", this._handleMouseUp, true);
      } else {
        document.addEventListener("mousemove", control._handleMouseMove, true);
        document.addEventListener("mouseup", control._handleMouseUp, true);
      }
    }
  }
  _handleMouseMove(event) {
    let control = getControl(event.target);
    if (control == null ? void 0 : control.enabled) {
      if (!this._initialTouchPos) {
        return;
      }
      if (control._handleMouseMove(event)) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }
  _handleMouseUp(event) {
    const target = event.target;
    let control = getControl(target);
    if (control == null ? void 0 : control.enabled) {
      if (window.PointerEvent) {
        document.removeEventListener("pointermove", this._handleMouseMove, true);
        document.removeEventListener("pointerup", this._handleMouseUp, true);
      } else {
        document.removeEventListener("mousemove", control._handleMouseMove, true);
        document.removeEventListener("mouseup", control._handleMouseUp, true);
      }
      this._initialTouchPos = false;
      if (control._handleMouseUp(event)) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }
  _handleDblClick(event) {
    let control = getControl(event.target);
    if (control) {
      if (control.enabled) {
        if (control._handleDblClick(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    }
  }
  _handleKeyDown(event) {
    let control = getControl(event.target);
    if (control) {
      if (control.enabled) {
        if (control._handleKeyDown(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    }
  }
  _handleKeyUp(event) {
    let control = getControl(event.target);
    if (control) {
      if (control.enabled) {
        if (control._handleKeyUp(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    }
  }
  _handleContextMenu(event) {
    let control = getControl(event.target);
    if (control) {
      event.stopPropagation();
      if (control.enabled)
        control._handleContextMenu(event);
    }
  }
  _handleChange(event) {
  }
  _handleMouseWheel(event) {
    let control = getControl(event.target);
    if (control) {
      event.stopPropagation();
      if (control.enabled && control._handleMouseWheel)
        control._handleMouseWheel(event);
    }
  }
  _handleFocus(event) {
    let control = getControl(event.target);
    if (control) {
      if (control.enabled && control._handleFocus)
        control._handleFocus(event);
    }
  }
  _handleBlur(event) {
    let control = getControl(event.target);
    if (control) {
      if (control.enabled && control._handleBlur)
        control._handleBlur(event);
    }
  }
  bindEvents() {
    document.addEventListener("click", this._handleClick.bind(this));
    window.addEventListener("dblclick", this._handleDblClick.bind(this));
    window.oncontextmenu = this._handleContextMenu.bind(this);
    window.addEventListener("keydown", this._handleKeyDown);
    window.addEventListener("keyup", this._handleKeyUp);
    window.addEventListener("change", this._handleChange);
    window.addEventListener("wheel", this._handleMouseWheel, { passive: false });
    window.addEventListener("focus", this._handleFocus, true);
    window.addEventListener("blur", this._handleBlur, true);
    document.addEventListener("touchstart", this._handleMouseDown, { passive: false });
    document.addEventListener("touchmove", this._handleMouseMove, { passive: false });
    if (window.PointerEvent) {
      document.addEventListener("pointerdown", this._handleMouseDown, true);
    } else {
      document.addEventListener("mousedown", this._handleMouseDown, true);
    }
  }
};

// packages/application/src/styles/index.css.ts
var Theme3 = theme_exports.ThemeVars;
var applicationStyle = style({
  height: "100%",
  $nest: {
    "body": {
      height: "100%"
    }
  }
});

// packages/ipfs/src/index.ts
var src_exports2 = {};
__export(src_exports2, {
  CidCode: () => CidCode,
  FileManager: () => FileManager,
  FileManagerHttpTransport: () => FileManagerHttpTransport,
  FileNode: () => FileNode,
  cidToHash: () => cidToHash,
  cidToSri: () => cidToSri,
  hashContent: () => hashContent,
  hashFile: () => hashFile,
  hashFiles: () => hashFiles,
  hashItems: () => hashItems,
  parse: () => parse
});

// packages/ipfs/src/utils.ts
var import_ipfs_utils = __toModule(require("@ijstech/ipfs-utils"));

// packages/ipfs/src/types.ts
var CidCode;
(function(CidCode2) {
  CidCode2[CidCode2["DAG_PB"] = 112] = "DAG_PB";
  CidCode2[CidCode2["RAW"] = 85] = "RAW";
})(CidCode || (CidCode = {}));

// packages/ipfs/src/utils.ts
function parse(cid, bytes) {
  let result = import_ipfs_utils.default.parse(cid, bytes);
  let links = [];
  if (result.links) {
    for (let i = 0; i < result.links.length; i++) {
      let link = result.links[i];
      links.push({
        cid: link.Hash.toString(),
        name: link.Name,
        size: link.Tsize
      });
    }
  }
  ;
  return {
    cid,
    size: result.size,
    code: result.code,
    type: result.type == "directory" ? "dir" : result.type == "file" ? "file" : result.code == CidCode.RAW ? "file" : void 0,
    multihash: result.multihash,
    links,
    bytes: result.bytes
  };
}
async function hashItems(items, version) {
  return await import_ipfs_utils.default.hashItems(items || [], version);
}
async function hashContent(content, version) {
  if (version == void 0)
    version = 1;
  if (content.length == 0) {
    return {
      cid: version == 1 ? "bafkreihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku" : "QmbFMke1KXqnYyBBWxB74N4c5SBnJMVAiMNRcGu6x1AwQH",
      type: "file",
      code: version == 1 ? 85 : 112,
      size: 0
    };
  }
  return import_ipfs_utils.default.hashContent(content, version);
}
async function hashFile(file, version) {
  if (version == void 0)
    version = 1;
  if (file instanceof File) {
    if (file.size == 0)
      return await import_ipfs_utils.default.hashContent("", version);
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsArrayBuffer(file);
      reader.addEventListener("error", (event) => {
        reject("Error occurred reading file");
      });
      reader.addEventListener("load", async (event) => {
        const data = new Uint8Array(event.target.result);
        let result = await import_ipfs_utils.default.hashContent(data, version);
        resolve(result);
      });
    });
  } else
    return import_ipfs_utils.default.hashContent(file, version);
}
function cidToHash(cid) {
  return import_ipfs_utils.default.cidToHash(cid);
}

// packages/ipfs/src/fileManager.ts
var FileManagerHttpTransport = class {
  constructor(options) {
    this.updated = {};
    this.options = options || {};
    this.options.endpoint = this.options.endpoint || "";
  }
  async applyUpdate(node) {
    var _a, _b, _c;
    let cidInfo = node.cidInfo;
    if (cidInfo && !this.updated[cidInfo.cid]) {
      let result = await this.getUploadUrl(cidInfo, node.isRoot);
      let endpoints = result == null ? void 0 : result.data;
      if (await node.isFolder()) {
        let url = endpoints == null ? void 0 : endpoints[cidInfo.cid];
        if (!(url == null ? void 0 : url.exists) && cidInfo.bytes && (url == null ? void 0 : url.url)) {
          let method = (url == null ? void 0 : url.method) || "PUT";
          let headers = (url == null ? void 0 : url.headers) || {};
          headers["Content-Type"] = headers["Content-Type"] || "application/octet-stream";
          headers["Content-Length"] = cidInfo.bytes.length.toString();
          let res = await fetch(url.url, {
            method,
            headers,
            body: cidInfo.bytes
          });
          if (!res.ok)
            throw new Error(res.statusText);
        }
        ;
      } else if (((_a = cidInfo.links) == null ? void 0 : _a.length) && ((_b = cidInfo.links) == null ? void 0 : _b.length) > 0) {
        let offset = 0;
        for (let link of cidInfo.links) {
          let url = endpoints == null ? void 0 : endpoints[link.cid];
          if ((url == null ? void 0 : url.url) && !(url == null ? void 0 : url.exists)) {
            let method = (url == null ? void 0 : url.method) || "PUT";
            let headers = (url == null ? void 0 : url.headers) || {};
            headers["Content-Type"] = headers["Content-Type"] || "application/octet-stream";
            headers["Content-Length"] = link.size.toString();
            let body;
            if (node.fileContent)
              body = (_c = node.fileContent) == null ? void 0 : _c.slice(offset, offset + link.size);
            else if (node.file) {
              let chunk = node.file.slice(offset, offset + link.size);
              body = chunk;
            }
            ;
            offset += link.size;
            let res = await fetch(url.url, {
              method,
              headers,
              body
            });
            if (!res.ok)
              throw new Error(res.statusText);
          }
          ;
        }
        ;
        if (cidInfo.bytes) {
          let url = endpoints == null ? void 0 : endpoints[cidInfo.cid];
          if ((url == null ? void 0 : url.url) && !(url == null ? void 0 : url.exists)) {
            let method = (url == null ? void 0 : url.method) || "PUT";
            let headers = (url == null ? void 0 : url.headers) || {};
            headers["Content-Type"] = headers["Content-Type"] || "application/octet-stream";
            headers["Content-Length"] = cidInfo.bytes.length.toString();
            let res = await fetch(url.url, {
              method,
              headers,
              body: cidInfo.bytes
            });
            if (!res.ok)
              throw new Error(res.statusText);
          }
          ;
        }
        ;
      } else if (endpoints == null ? void 0 : endpoints[cidInfo.cid]) {
        let url = endpoints[cidInfo.cid];
        if (!(url == null ? void 0 : url.exists)) {
          let method = (url == null ? void 0 : url.method) || "PUT";
          let headers = (url == null ? void 0 : url.headers) || {};
          headers["Content-Type"] = headers["Content-Type"] || "application/octet-stream";
          headers["Content-Length"] = cidInfo.size.toString();
          let body;
          if (node.fileContent)
            body = node.fileContent;
          else if (node.file) {
            body = node.file;
          }
          ;
          let res = await fetch(url.url, {
            method,
            headers,
            body
          });
          if (!res.ok)
            throw new Error(res.statusText);
        }
        ;
      }
      ;
      this.updated[cidInfo.cid] = true;
    }
    ;
    if (node.isRoot) {
      let signature;
      if (this.options.signer) {
        signature = await this.options.signer.sign({
          action: "UPDATE_ROOT",
          timestamp: new Date().getTime(),
          data: {
            cid: node.cid
          }
        }, {
          action: "string",
          timestamp: "number",
          data: "object"
        });
      }
      ;
      let result = await fetch(`${this.options.endpoint}/api/ipfs/v0`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          action: "UPDATE_ROOT",
          signature,
          data: {
            cid: node.cid
          }
        })
      });
      return await result.json();
    }
    ;
    return {
      success: true
    };
  }
  async getCidInfo(cid) {
    let cidInfo = parse(cid);
    if (cidInfo.code == CidCode.DAG_PB) {
      let data = await fetch(`${this.options.endpoint}/stat/${cid}`);
      if (data.status == 200) {
        return await data.json();
      }
    } else
      return cidInfo;
  }
  async getRoot() {
    let signature;
    if (this.options.signer)
      signature = await this.options.signer.sign({
        action: "GET_ROOT",
        timestamp: new Date().getTime()
      }, {
        action: "string",
        timestamp: "number"
      });
    let result = await fetch(`${this.options.endpoint}/api/ipfs/v0`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        action: "GET_ROOT",
        signature
      })
    });
    return await result.json();
  }
  async getUploadUrl(cidInfo, isRoot) {
    var _a;
    let req = {
      cid: cidInfo.cid,
      name: cidInfo.name,
      size: cidInfo.size,
      type: cidInfo.type,
      links: []
    };
    let signature;
    if (cidInfo.links) {
      for (let link of cidInfo.links) {
        (_a = req.links) == null ? void 0 : _a.push({
          cid: link.cid,
          name: link.name,
          size: link.size
        });
      }
      ;
    }
    ;
    if (this.options.signer) {
      let timestamp = new Date().getTime();
      signature = await this.options.signer.sign({
        action: "GET_UPLOAD_URL",
        timestamp,
        data: req
      }, {
        action: "string",
        timestamp: "number",
        data: "object"
      });
      let result = await fetch(`${this.options.endpoint}/api/ipfs/v0`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          action: "GET_UPLOAD_URL",
          signature,
          data: req
        })
      });
      return await result.json();
    } else {
      let result = await fetch(`${this.options.endpoint}/api/ipfs/v0`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          data: req
        })
      });
      return await result.json();
    }
  }
};
var FileNode = class {
  constructor(owner, name, parent, cidInfo) {
    var _a, _b;
    this._owner = owner;
    this._name = name;
    if (parent) {
      this._parent = parent;
      if (!cidInfo)
        this._parent.addItem(this);
    }
    ;
    this._items = [];
    this._cidInfo = cidInfo;
    this._isFile = (cidInfo == null ? void 0 : cidInfo.type) == "file" || false;
    this._isFolder = (cidInfo == null ? void 0 : cidInfo.type) == "dir" || true;
    if (((_a = this._cidInfo) == null ? void 0 : _a.type) == "dir") {
      (_b = this._cidInfo.links) == null ? void 0 : _b.forEach((link) => {
        this._items.push(new FileNode(this._owner, link.name || "", this, link));
      });
    }
    ;
  }
  get cid() {
    var _a;
    return ((_a = this._cidInfo) == null ? void 0 : _a.cid) || "";
  }
  async checkCid() {
    var _a;
    if (this._cidInfo && this._cidInfo.type == void 0) {
      this._cidInfo = await this._owner.getCidInfo(this._cidInfo.cid);
      if (((_a = this._cidInfo) == null ? void 0 : _a.type) == "dir") {
        this._isFolder = true;
        this._isFile = false;
        this._items = [];
        if (this._cidInfo.links) {
          for (let i = 0; i < this._cidInfo.links.length; i++) {
            let link = this._cidInfo.links[i];
            if (link == null ? void 0 : link.name) {
              let node = new FileNode(this._owner, link.name, this, link);
              this._items.push(node);
            }
            ;
          }
          ;
        }
        ;
      } else {
        this._isFolder = false;
        this._isFile = true;
      }
    }
    ;
  }
  get fullPath() {
    let path = this._name;
    let parent = this._parent;
    while (parent) {
      path = parent.name + "/" + path;
      parent = parent.parent;
    }
    ;
    return path;
  }
  get isModified() {
    return this._isModified;
  }
  modified(value) {
    if (value === false)
      return this._isModified = false;
    this._isModified = true;
    this._cidInfo = void 0;
    if (this._parent)
      this._parent.modified();
  }
  get name() {
    return this._name;
  }
  set name(value) {
    if (this._name != value) {
      this._name = value;
      this.modified();
    }
    ;
  }
  get parent() {
    return this._parent;
  }
  set parent(value) {
    if (this._parent != value) {
      if (this._parent) {
        let idx = this._parent._items.indexOf(this);
        if (idx >= 0) {
          this._parent._items.splice(idx, 1);
          this._parent.modified();
        }
        ;
      }
      ;
      this._parent = value;
      this._parent._items.push(this);
      this.modified();
    }
    ;
  }
  async itemCount() {
    await this.checkCid();
    return this._items.length;
  }
  async items(index) {
    await this.checkCid();
    let item = this._items[index];
    return item;
  }
  async addFile(name, file) {
    await this.checkCid();
    return this._owner.addFileTo(this, name, file);
  }
  async addFileContent(name, content) {
    await this.checkCid();
    if (typeof content == "string")
      content = new TextEncoder().encode(content);
    return this._owner.addFileTo(this, name, content);
  }
  async addItem(item) {
    if (this._items.indexOf(item) < 0) {
      this._items.push(item);
      this.modified();
    }
    ;
  }
  removeItem(item) {
    let idx = this._items.indexOf(item);
    if (idx >= 0) {
      this._items.splice(idx, 1);
      this.modified();
    }
    ;
  }
  async findItem(name) {
    let item = this._items.find((item2) => item2.name == name);
    return item;
  }
  get cidInfo() {
    return this._cidInfo;
  }
  async isFile() {
    await this.checkCid();
    return this._isFile;
  }
  async isFolder() {
    await this.checkCid();
    return this._isFolder;
  }
  get file() {
    return this._file;
  }
  set file(value) {
    this._isFile = true;
    this._isFolder = false;
    this._file = value;
    this._fileContent = void 0;
    this.modified();
  }
  get fileContent() {
    return this._fileContent;
  }
  set fileContent(value) {
    this._isFile = true;
    this._isFolder = false;
    this._file = void 0;
    this._fileContent = value;
    this.modified();
  }
  async hash() {
    if (!this._cidInfo) {
      if (this._isFile) {
        if (this._fileContent)
          this._cidInfo = await hashContent(this._fileContent);
        else if (this._file)
          this._cidInfo = await hashFile(this._file);
      } else if (this._isFolder) {
        let items = [];
        for (let i = 0; i < this._items.length; i++) {
          let item = this._items[i];
          let cidInfo = await item.hash();
          if (cidInfo) {
            cidInfo.name = item.name;
            items.push(cidInfo);
          }
        }
        ;
        this._cidInfo = await hashItems(items);
      }
      ;
    }
    ;
    return this._cidInfo;
  }
};
var FileManager = class {
  constructor(options) {
    var _a;
    this.options = options || {};
    if ((_a = this.options) == null ? void 0 : _a.transport)
      this.transporter = this.options.transport;
    else
      this.transporter = new FileManagerHttpTransport(this.options);
  }
  async addFileTo(folder, filePath, file) {
    if (filePath.startsWith("/"))
      filePath = filePath.substr(1);
    let paths = filePath.split("/");
    let node = folder;
    for (let path of paths) {
      let item = await folder.findItem(path);
      if (!item)
        item = new FileNode(this, path, node);
      else
        await item.checkCid();
      node = item;
    }
    ;
    if (file instanceof Uint8Array) {
      node.fileContent = file;
    } else {
      node.file = file;
    }
    ;
    return node;
  }
  async addFile(filePath, file) {
    if (!filePath.startsWith("/"))
      filePath = "/" + filePath;
    let fileNode = await this.getFileNode(filePath);
    if (fileNode) {
      fileNode.file = file;
      return fileNode;
    }
  }
  async addFileContent(filePath, content) {
    if (!filePath.startsWith("/"))
      filePath = "/" + filePath;
    let fileNode = await this.getFileNode(filePath);
    if (fileNode) {
      if (typeof content == "string")
        fileNode.fileContent = new TextEncoder().encode(content);
      else
        fileNode.fileContent = content;
      return fileNode;
    }
    ;
  }
  async getCidInfo(cid) {
    var _a;
    return await ((_a = this.transporter) == null ? void 0 : _a.getCidInfo(cid));
  }
  async updateNode(fileNode) {
    if (fileNode.isModified) {
      await fileNode.hash();
      if (await fileNode.isFolder()) {
        let count = await fileNode.itemCount();
        for (let i = 0; i < count; i++) {
          let item = await fileNode.items(i);
          await this.updateNode(item);
        }
        ;
      }
      ;
      await this.transporter.applyUpdate(fileNode);
      fileNode.modified(false);
    }
    ;
  }
  async applyUpdates() {
    if (this.rootNode) {
      await this.updateNode(this.rootNode);
      return this.rootNode;
    }
    ;
  }
  delete(fileNode) {
    if (fileNode.parent)
      fileNode.parent.removeItem(fileNode);
  }
  async addFolder(folder, name) {
    let node = folder;
    if (name.startsWith("/"))
      name = name.substr(1);
    let paths = name.split("/");
    for (let path of paths) {
      let item = await folder.findItem(path);
      if (!item) {
        item = new FileNode(this, path, node);
        item.modified(true);
        await this.updateNode(item);
      } else
        await item.checkCid();
      node = item;
    }
    ;
    node.modified(true);
    await this.updateNode(node);
    return node;
  }
  async updateFolderName(fileNode, newName) {
    fileNode.name = newName;
    fileNode.modified(true);
    await this.updateNode(fileNode);
  }
  async getFileNode(path) {
    if (!path.startsWith("/"))
      path = "/" + path;
    let paths = path.split("/");
    let node = await this.getRootNode();
    for (let i = 1; i < paths.length; i++) {
      let path2 = paths[i];
      if (node) {
        let item = await node.findItem(path2);
        if (!item) {
          item = new FileNode(this, path2, node);
          item.modified(true);
          await this.updateNode(item);
        } else
          await item.checkCid();
        node = item;
      } else
        break;
    }
    ;
    return node;
  }
  async getRootNode() {
    if (!this.rootNode) {
      if (this.options.rootCid)
        this.rootNode = await this.setRootCid(this.options.rootCid);
      else {
        let result = await this.transporter.getRoot();
        let data = result.data;
        if (data.cid)
          this.rootNode = await this.setRootCid(data.cid);
        else
          this.rootNode = new FileNode(this, "/", void 0);
        this.quota = data.quota;
        this.used = data.used;
      }
      ;
      if (this.rootNode)
        this.rootNode.isRoot = true;
    }
    ;
    return this.rootNode;
  }
  reset() {
    this.rootNode = void 0;
  }
  async setRootCid(cid) {
    this.options.rootCid = cid;
    try {
      let cidInfo = await this.transporter.getCidInfo(cid);
      if (cidInfo) {
        this.rootNode = new FileNode(this, "/", void 0, cidInfo);
        this.rootNode.isRoot = true;
        await this.rootNode.checkCid();
        return this.rootNode;
      } else
        this.options.rootCid = void 0;
    } catch (err) {
      this.options.rootCid = void 0;
    }
  }
  move(fileNode, newParent) {
    if (fileNode.parent)
      fileNode.parent.removeItem(fileNode);
    fileNode.parent = newParent;
  }
};

// packages/ipfs/src/index.ts
function convertToTree(items) {
  const root = {
    $idx: {},
    links: []
  };
  for (const item of items) {
    if (item.path && item.cid) {
      const paths = item.path.split("/");
      let node = root;
      for (const path of paths) {
        if (path) {
          if (!node.$idx[path]) {
            let item2 = {
              $idx: {},
              links: [],
              name: path,
              type: "dir"
            };
            node.$idx[path] = item2;
            node.links.push(item2);
          }
          ;
          node = node.$idx[path];
        }
        ;
      }
      ;
      delete node.links;
      delete node.$idx;
      node.type = "file";
      node.size = item.cid.size;
      node.cid = item.cid.cid;
    }
    ;
  }
  ;
  return root;
}
async function hashTree(tree) {
  delete tree.$idx;
  let items = tree.links;
  if (items) {
    for (const item of items) {
      delete item.$idx;
      if (item.type == "dir") {
        await hashTree(item);
      }
      ;
    }
    ;
    let cid = await hashItems(items);
    tree.type = "dir";
    tree.cid = cid.cid;
    tree.size = cid.size;
  }
  ;
  return tree;
}
async function hashFiles(files, version) {
  if (version == void 0)
    version = 1;
  return new Promise(async (resolve, reject) => {
    try {
      let tree = convertToTree(files);
      let cid = await hashTree(tree);
      resolve(cid);
    } catch (err) {
      reject(err);
    }
    ;
  });
}
async function cidToSri(cid) {
  return await cidToHash(cid);
}

// packages/image/src/style/image.css.ts
cssRule("i-image", {
  position: "relative",
  $nest: {
    "img": {
      maxHeight: "100%",
      maxWidth: "100%",
      height: "inherit",
      verticalAlign: "middle",
      objectFit: "contain",
      overflow: "hidden",
      width: "100%"
    }
  }
});

// packages/image/src/image.ts
var Image2 = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._rotate = 0;
    this._usedFallback = false;
  }
  get fallbackUrl() {
    return this._fallbackUrl;
  }
  set fallbackUrl(value) {
    this._fallbackUrl = value;
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(value) {
    if (value == void 0)
      return;
    value = parseInt(value);
    if (value != this._rotate) {
      if (this.imageElm) {
        if (this._rotate != 0)
          this.imageElm.classList.remove(rotate(this._rotate));
        this.imageElm.classList.add(rotate(value));
      }
      this._rotate = value;
    }
  }
  get url() {
    return this._url;
  }
  set url(value) {
    this._url = value;
    if (!this.imageElm)
      this.imageElm = this.createElement("img", this);
    this.imageElm.src = value != null ? value : "";
    this.imageElm.style.display = "none";
    const self = this;
    this.imageElm.onerror = function() {
      if (self._fallbackUrl && !self._usedFallback) {
        this.src = self._fallbackUrl;
        self._usedFallback = true;
      }
    };
    this.imageElm.onload = function() {
      self.imageElm.style.display = "";
    };
    if (this._borderValue) {
      this._border = new Border(this.imageElm, this._borderValue);
    }
    if (this._objectFit)
      this.imageElm.style.objectFit = this._objectFit;
  }
  get objectFit() {
    return this._objectFit;
  }
  set objectFit(value) {
    this._objectFit = value;
    if (this.imageElm) {
      this.imageElm.style.objectFit = value;
    }
  }
  get border() {
    return this._border;
  }
  set border(value) {
    this._borderValue = value;
    if (this.imageElm) {
      this._border = new Border(this.imageElm, value);
    }
  }
  init() {
    super.init();
    setAttributeToProperty(this, "fallbackUrl");
    setAttributeToProperty(this, "url");
    setAttributeToProperty(this, "objectFit", "contain");
    this.rotate = this.getAttribute("rotate", true);
    const border = this.getAttribute("border", true);
    if (border) {
      this._borderValue = border;
      if (this.imageElm) {
        this._border = new Border(this.imageElm, border);
        this.style.border = "none";
      }
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Image2 = __decorateClass([
  customElements2("i-image", {
    icon: "image",
    group: GroupType.BASIC,
    className: "Image",
    props: {
      rotate: {
        type: "number"
      },
      url: {
        type: "string",
        default: ""
      },
      fallbackUrl: {
        type: "string",
        default: ""
      },
      objectFit: {
        type: "string",
        default: "contain"
      }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        rotate: {
          type: "number"
        },
        url: {
          type: "string"
        },
        fallbackUrl: {
          type: "string"
        },
        objectFit: {
          type: "string",
          enum: ["contain", "cover", "fill", "none", "scale-down"],
          default: "contain"
        }
      }
    }
  })
], Image2);

// packages/icon/src/style/icon.css.ts
var Theme4 = theme_exports.ThemeVars;
var spinnerAnim2 = keyframes({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
cssRule("i-icon", {
  display: "inline-block",
  $nest: {
    "svg": {
      fill: Theme4.text.primary,
      verticalAlign: "top",
      width: "100%",
      height: "100%"
    },
    "&.is-spin": {
      animation: `${spinnerAnim2} 2s linear infinite`
    }
  }
});

// packages/icon/src/icon.ts
var _iconLoaded = false;
async function loadIconFile() {
  if (_iconLoaded)
    return;
  _iconLoaded = true;
  try {
    let res = await fetch(`${LibPath}assets/icon/solid.svg`);
    let text = await res.text();
    let span = document.createElement("span");
    span.innerHTML = text;
    document.body.appendChild(span);
  } catch (err) {
    _iconLoaded = false;
  }
  ;
}
var Icon = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    loadIconFile();
  }
  init() {
    if (!this.initialized) {
      super.init();
      let fill = this.getAttribute("fill", true);
      if (fill)
        this.fill = fill;
      this._size = this.getAttribute("size", true);
      this._name = this.getAttribute("name");
      this._updateIcon();
      const image = this.getAttribute("image", true);
      if (image && image.url) {
        image.height = image.height || this.height || "16px";
        image.width = image.width || this.width || "16px";
        this.image = new Image2(this, image);
      }
      this.spin = this.getAttribute("spin", true, false);
    }
  }
  get fill() {
    return this._fill;
  }
  set fill(color) {
    this._fill = color;
    let svg = this.querySelector("svg");
    if (svg)
      svg.style.fill = color;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
    this._updateIcon();
  }
  get image() {
    if (!this._image) {
      this._image = Image2.create({
        width: this.width || 16,
        height: this.height || 16
      });
    }
    return this._image;
  }
  set image(image) {
    if (this._image)
      this.removeChild(this._image);
    this._image = image;
    if (this._image)
      this.prepend(this._image);
  }
  get spin() {
    return this._spin;
  }
  set spin(value) {
    this._spin = value;
    if (value)
      this.classList.add("is-spin");
    else
      this.classList.remove("is-spin");
    this._parent && this._parent.refresh();
  }
  _updateIcon() {
    if (this._name)
      this.innerHTML = `<svg${this._fill ? ` style="fill: ${this._fill}"` : ""}><use xlink:href="#${this.name}"></use></svg>`;
    else
      this.innerHTML = "";
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Icon = __decorateClass([
  customElements2("i-icon", {
    icon: "icons",
    group: GroupType.BASIC,
    className: "Icon",
    props: {
      name: {
        type: "string",
        default: ""
      },
      fill: {
        type: "string",
        default: ""
      },
      image: {
        type: "object",
        default: {}
      },
      spin: {
        type: "boolean",
        default: false
      }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          title: "Name"
        },
        fill: {
          type: "string",
          format: "color"
        },
        image: {
          type: "object",
          properties: {
            url: {
              type: "string"
            }
          }
        },
        spin: {
          type: "boolean",
          default: false
        }
      }
    }
  })
], Icon);

// packages/link/src/style/link.css.ts
var Theme5 = theme_exports.ThemeVars;
cssRule("i-link", {
  display: "block",
  cursor: "pointer",
  textTransform: "inherit",
  $nest: {
    "&:hover *": {
      color: Theme5.colors.primary.dark
    },
    "> a": {
      display: "inline",
      transition: "all .3s",
      textDecoration: "underline",
      color: "inherit",
      fontSize: "inherit",
      fontWeight: "inherit",
      fontFamily: "inherit",
      textTransform: "inherit"
    }
  }
});

// packages/link/src/link.ts
var Link = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      target: "_blank"
    });
  }
  get href() {
    return this._href;
  }
  set href(value) {
    this._href = typeof value === "string" ? value : "";
    if (this._linkElm)
      this._linkElm.href = this._href;
  }
  get target() {
    return this._target;
  }
  set target(value) {
    this._target = value;
    if (this._linkElm)
      this._linkElm.target = value;
  }
  append(children) {
    if (!this._linkElm) {
      this._linkElm = this.createElement("a", this);
    }
    this._linkElm.appendChild(children);
  }
  _handleClick(event, stopPropagation) {
    event.preventDefault();
    if (this._designMode)
      return false;
    window.open(this._linkElm.href, this._linkElm.target);
    return super._handleClick(event);
  }
  addChildControl(control) {
    if (this._linkElm)
      this._linkElm.appendChild(control);
  }
  removeChildControl(control) {
    if (this._linkElm && this._linkElm.contains(control))
      this._linkElm.removeChild(control);
  }
  init() {
    if (!this.initialized) {
      super.init();
      if (!this._linkElm)
        this._linkElm = this.createElement("a", this);
      this.classList.add("i-link");
      const hrefAttr = this.getAttribute("href", true);
      hrefAttr && (this.href = hrefAttr);
      const targetAttr = this.getAttribute("target", true);
      targetAttr && (this._linkElm.target = targetAttr);
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Link = __decorateClass([
  customElements2("i-link")
], Link);

// packages/text/src/style/text.css.ts
var Theme6 = theme_exports.ThemeVars;
cssRule("i-text", {
  display: "inline-block",
  color: Theme6.text.primary,
  fontFamily: Theme6.typography.fontFamily,
  fontSize: Theme6.typography.fontSize
});

// packages/text/src/text.ts
var Text = class extends Control {
  constructor(parent, options) {
    super(parent, options);
  }
  get wordBreak() {
    return this.style.wordBreak;
  }
  set wordBreak(value) {
    this.style.wordBreak = value;
  }
  get overflowWrap() {
    return this.style.overflowWrap;
  }
  set overflowWrap(value) {
    this.style.overflowWrap = value;
  }
  get textOverflow() {
    return this.style.textOverflow;
  }
  set textOverflow(value) {
    if (!value)
      return;
    this.style.textOverflow = value;
    this.style.whiteSpace = "nowrap";
    this.overflow = "hidden";
  }
  get lineClamp() {
    return Number(this.style.webkitLineClamp);
  }
  set lineClamp(value) {
    this.style.webkitLineClamp = `${value}`;
    this.style.overflow = "hidden";
    this.style.webkitBoxOrient = "vertical";
    this.display = "-webkit-box";
    this.overflow = "hidden";
    this.style.whiteSpace = "";
  }
  get display() {
    return this._display;
  }
  set display(value) {
    const isNotNone = value !== "none";
    this._display = this.lineClamp && isNotNone ? "-webkit-box" : value;
    this.style.display = this._display;
  }
  init() {
    super.init();
    const wordBreak = this.getAttribute("wordBreak", true);
    if (wordBreak)
      this.wordBreak = wordBreak;
    const overflowWrap = this.getAttribute("overflowWrap", true);
    if (overflowWrap)
      this.overflowWrap = overflowWrap;
    const textOverflow = this.getAttribute("textOverflow", true);
    if (textOverflow)
      this.textOverflow = textOverflow;
    const lineClamp = this.getAttribute("lineClamp", true);
    if (lineClamp)
      this.lineClamp = lineClamp;
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Text = __decorateClass([
  customElements2("i-text")
], Text);

// packages/label/src/style/label.css.ts
var Theme7 = theme_exports.ThemeVars;
cssRule("i-label", {
  display: "inline-block",
  color: Theme7.text.primary,
  fontFamily: Theme7.typography.fontFamily,
  fontSize: Theme7.typography.fontSize
});

// packages/label/src/label.ts
var DEFAULT_VALUES2 = {
  target: "_blank",
  textDecoration: "none"
};
var Label = class extends Text {
  constructor(parent, options) {
    super(parent, options);
  }
  get caption() {
    var _a;
    return ((_a = this.captionSpan) == null ? void 0 : _a.innerHTML) || "";
  }
  set caption(value) {
    if (this.captionSpan)
      this.captionSpan.innerHTML = value || "";
  }
  get link() {
    if (!this._link) {
      this._link = new Link(this, {
        href: "#",
        target: "_blank",
        font: this.font,
        designMode: this._designMode
      });
      this._link.append(this.captionSpan);
      this.appendChild(this._link);
    }
    return this._link;
  }
  set link(value) {
    if (this._link) {
      this._link.prepend(this.captionSpan);
      this._link.remove();
    }
    this._link = value;
    if (this._link) {
      this._link.append(this.captionSpan);
      this.appendChild(this._link);
    } else {
      this.appendChild(this.captionSpan);
    }
  }
  set height(value) {
    this.setPosition("height", value);
    if (this.captionSpan)
      this.captionSpan.style.height = value + "px";
  }
  set width(value) {
    this.setPosition("width", value);
    if (this.captionSpan)
      this.captionSpan.style.width = value + "px";
  }
  get textDecoration() {
    return this.style.textDecoration;
  }
  set textDecoration(value) {
    this.style.textDecoration = value;
  }
  init() {
    if (!this.captionSpan) {
      let childNodes = [];
      for (let i = 0; i < this.childNodes.length; i++) {
        childNodes.push(this.childNodes[i]);
      }
      this.captionSpan = this.createElement("span", this);
      this.caption = this.getAttribute("caption", true) || "";
      if (childNodes && childNodes.length) {
        for (let i = 0; i < childNodes.length; i++) {
          this.captionSpan.appendChild(childNodes[i]);
        }
      }
      const linkAttr = this.getAttribute("link", true);
      const designMode = this.getAttribute("designMode", true);
      if (linkAttr == null ? void 0 : linkAttr.href) {
        const link = new Link(this, {
          ...linkAttr,
          font: this.font,
          designMode
        });
        this.link = link;
      }
      const textDecoration = this.getAttribute("textDecoration", true);
      if (textDecoration)
        this.textDecoration = textDecoration;
      super.init();
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Label = __decorateClass([
  customElements2("i-label", {
    icon: "heading",
    group: GroupType.BASIC,
    className: "Label",
    props: {
      caption: {
        type: "string",
        default: ""
      },
      textDecoration: {
        type: "string",
        default: DEFAULT_VALUES2.textDecoration
      },
      link: {
        type: "object",
        default: {
          target: DEFAULT_VALUES2.target
        }
      }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        caption: {
          type: "string",
          required: true
        },
        textDecoration: {
          type: "string",
          enum: ["none", "underline", "overline", "line-through"],
          default: DEFAULT_VALUES2.textDecoration
        },
        link: {
          type: "object",
          properties: {
            href: {
              type: "string"
            },
            target: {
              type: "string",
              enum: ["_blank", "_self", "_parent", "_top"],
              default: DEFAULT_VALUES2.target
            }
          }
        }
      }
    }
  })
], Label);

// packages/layout/src/style/panel.css.ts
var panelStyle = style({
  display: "block",
  clear: "both",
  position: "relative"
});
var overflowStyle = style({
  overflow: "hidden"
});
var vStackStyle = style({
  display: "flex",
  flexDirection: "column"
});
var hStackStyle = style({
  display: "flex",
  flexDirection: "row"
});
var gridStyle = style({
  display: "grid"
});
var getStackDirectionStyleClass = (direction, reverse) => {
  const flexDirection = direction == "vertical" ? "column" : "row";
  return style({
    display: "flex",
    flexDirection: reverse ? `${flexDirection}-reverse` : flexDirection
  });
};
var getStackMediaQueriesStyleClass = (mediaQueries, currentDirection) => {
  let styleObj = getControlMediaQueriesStyle(mediaQueries);
  for (let mediaQuery of mediaQueries) {
    let mediaQueryRule = getMediaQueryRule(mediaQuery);
    if (mediaQueryRule) {
      styleObj["$nest"][mediaQueryRule] = styleObj["$nest"][mediaQueryRule] || {};
      const {
        direction,
        justifyContent,
        alignItems,
        alignSelf,
        gap,
        reverse
      } = mediaQuery.properties || {};
      if (direction) {
        styleObj["$nest"][mediaQueryRule]["flexDirection"] = `${direction == "vertical" ? "column" : "row"} !important`;
      }
      if (justifyContent) {
        styleObj["$nest"][mediaQueryRule]["justifyContent"] = `${justifyContent} !important`;
      }
      if (alignItems) {
        styleObj["$nest"][mediaQueryRule]["alignItems"] = `${alignItems} !important`;
      }
      if (alignSelf) {
        styleObj["$nest"][mediaQueryRule]["alignSelf"] = `${alignSelf} !important`;
      }
      if (gap !== void 0 && gap !== null) {
        styleObj["$nest"][mediaQueryRule]["gap"] = `${getSpacingValue(gap)} !important`;
      }
      if (reverse !== void 0 && reverse !== null) {
        const direct = direction || currentDirection || "horizontal";
        styleObj["$nest"][mediaQueryRule]["flexDirection"] = `${direct === "vertical" ? "column" : "row"}${reverse ? "-reverse" : ""} !important`;
      }
    }
  }
  return style(styleObj);
};
var justifyContentStartStyle = style({
  justifyContent: "flex-start"
});
var justifyContentCenterStyle = style({
  justifyContent: "center"
});
var justifyContentEndStyle = style({
  justifyContent: "flex-end"
});
var justifyContentSpaceBetweenStyle = style({
  justifyContent: "space-between"
});
var justifyContentSpaceAroundStyle = style({
  justifyContent: "space-around"
});
var justifyContentSpaceEvenlyStyle = style({
  justifyContent: "space-evenly"
});
var alignItemsStretchStyle = style({
  alignItems: "stretch"
});
var alignItemsBaselineStyle = style({
  alignItems: "baseline"
});
var alignItemsStartStyle = style({
  alignItems: "flex-start"
});
var alignItemsCenterStyle = style({
  alignItems: "center"
});
var alignItemsEndStyle = style({
  alignItems: "flex-end"
});
var alignSelfAutoStyle = style({
  alignSelf: "auto"
});
var alignSelfStretchStyle = style({
  alignSelf: "stretch"
});
var alignSelfStartStyle = style({
  alignSelf: "flex-start"
});
var alignSelfCenterStyle = style({
  alignSelf: "center"
});
var alignSelfEndStyle = style({
  alignSelf: "flex-end"
});
var alignContentSpaceBetweenStyle = style({
  alignContent: "space-between"
});
var alignContentSpaceAroundStyle = style({
  alignContent: "space-around"
});
var alignContentStretchStyle = style({
  alignContent: "stretch"
});
var alignContentStartStyle = style({
  alignContent: "flex-start"
});
var alignContentCenterStyle = style({
  alignContent: "center"
});
var alignContentEndStyle = style({
  alignContent: "flex-end"
});
var getTemplateColumnsStyleClass = (columns) => {
  return style({
    gridTemplateColumns: columns.join(" ")
  });
};
var getTemplateRowsStyleClass = (rows) => {
  return style({
    gridTemplateRows: rows.join(" ")
  });
};
var getTemplateAreasStyleClass = (templateAreas) => {
  let templateAreasStr = "";
  for (let i = 0; i < templateAreas.length; i++) {
    templateAreasStr += '"' + templateAreas[i].join(" ") + '" ';
  }
  return style({
    gridTemplateAreas: templateAreasStr
  });
};
var getGridLayoutMediaQueriesStyleClass = (mediaQueries) => {
  let styleObj = getControlMediaQueriesStyle(mediaQueries, { display: "grid" });
  for (let mediaQuery of mediaQueries) {
    let mediaQueryRule = getMediaQueryRule(mediaQuery);
    if (mediaQueryRule) {
      styleObj["$nest"][mediaQueryRule] = styleObj["$nest"][mediaQueryRule] || {};
      const {
        templateColumns,
        templateRows,
        templateAreas,
        gap
      } = mediaQuery.properties || {};
      if (templateColumns) {
        const templateColumnsStr = templateColumns.join(" ");
        styleObj["$nest"][mediaQueryRule]["gridTemplateColumns"] = `${templateColumnsStr} !important`;
      }
      if (templateRows) {
        const templateRowsStr = templateRows.join(" ");
        styleObj["$nest"][mediaQueryRule]["gridTemplateRows"] = `${templateRowsStr} !important`;
      }
      if (templateAreas) {
        let templateAreasStr = "";
        for (let i = 0; i < templateAreas.length; i++) {
          templateAreasStr += '"' + templateAreas[i].join(" ") + '" ';
        }
        styleObj["$nest"][mediaQueryRule]["gridTemplateAreas"] = `${templateAreasStr} !important`;
      }
      if (gap !== void 0 && gap !== null) {
        if (gap.row) {
          styleObj["$nest"][mediaQueryRule]["rowGap"] = `${getSpacingValue(gap.row)}!important`;
        }
        if (gap.column) {
          styleObj["$nest"][mediaQueryRule]["columnGap"] = `${getSpacingValue(gap.column)}!important`;
        }
      }
    }
  }
  return style(styleObj);
};
var getHoverStyleClass = (hover) => {
  return style({
    $nest: {
      "&:hover": {
        backgroundColor: hover.backgroundColor,
        color: hover.fontColor,
        opacity: hover.opacity
      }
    }
  });
};

// packages/layout/src/stack.ts
var DEFAULT_VALUES3 = {
  wrap: "nowrap",
  direction: "horizontal",
  justifyContent: "start",
  alignItems: "stretch",
  alignSelf: "start",
  alignContent: "start",
  reverse: false
};
var StackLayout = class extends Container {
  constructor(parent, options) {
    super(parent, options);
    this._reverse = false;
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  get direction() {
    return this._direction;
  }
  set direction(value) {
    this._direction = value;
    if (value) {
      let style2 = getStackDirectionStyleClass(value, this.reverse);
      this.setStyle("direction", style2);
    }
  }
  get reverse() {
    var _a;
    return (_a = this._reverse) != null ? _a : false;
  }
  set reverse(value) {
    this._reverse = value != null ? value : false;
    let style2 = getStackDirectionStyleClass(this.direction, this.reverse);
    this.setStyle("direction", style2);
  }
  get justifyContent() {
    return this._justifyContent;
  }
  set justifyContent(value) {
    this._justifyContent = value || "start";
    switch (this._justifyContent) {
      case "start":
        this.setStyle("justifyContent", justifyContentStartStyle);
        break;
      case "center":
        this.setStyle("justifyContent", justifyContentCenterStyle);
        break;
      case "end":
        this.setStyle("justifyContent", justifyContentEndStyle);
        break;
      case "space-between":
        this.setStyle("justifyContent", justifyContentSpaceBetweenStyle);
        break;
      case "space-around":
        this.setStyle("justifyContent", justifyContentSpaceAroundStyle);
        break;
      case "space-evenly":
        this.setStyle("justifyContent", justifyContentSpaceEvenlyStyle);
        break;
    }
  }
  get alignItems() {
    return this._alignItems;
  }
  set alignItems(value) {
    this._alignItems = value || "stretch";
    switch (this._alignItems) {
      case "stretch":
        this.setStyle("alignItems", alignItemsStretchStyle);
        break;
      case "baseline":
        this.setStyle("alignItems", alignItemsBaselineStyle);
        break;
      case "start":
        this.setStyle("alignItems", alignItemsStartStyle);
        break;
      case "center":
        this.setStyle("alignItems", alignItemsCenterStyle);
        break;
      case "end":
        this.setStyle("alignItems", alignItemsEndStyle);
        break;
    }
  }
  get alignSelf() {
    return this._alignSelf;
  }
  set alignSelf(value) {
    this._alignSelf = value || "auto";
    switch (this._alignSelf) {
      case "auto":
        this.setStyle("alignSelf", alignSelfAutoStyle);
        break;
      case "stretch":
        this.setStyle("alignSelf", alignSelfStretchStyle);
        break;
      case "start":
        this.setStyle("alignSelf", alignSelfStartStyle);
        break;
      case "center":
        this.setStyle("alignSelf", alignSelfCenterStyle);
        break;
      case "end":
        this.setStyle("alignSelf", alignSelfEndStyle);
        break;
    }
  }
  get alignContent() {
    return this._alignContent;
  }
  set alignContent(value) {
    this._alignContent = value || "auto";
    switch (this._alignContent) {
      case "space-between":
        this.setStyle("alignContent", alignContentSpaceBetweenStyle);
        break;
      case "space-around":
        this.setStyle("alignContent", alignContentSpaceAroundStyle);
        break;
      case "stretch":
        this.setStyle("alignContent", alignContentStretchStyle);
        break;
      case "start":
        this.setStyle("alignContent", alignContentStartStyle);
        break;
      case "center":
        this.setStyle("alignContent", alignContentCenterStyle);
        break;
      case "end":
        this.setStyle("alignContent", alignContentEndStyle);
        break;
    }
  }
  get gap() {
    return this._gap;
  }
  set gap(value) {
    this._gap = value || "initial";
    const num = +this._gap;
    if (!isNaN(num)) {
      this.style.gap = this._gap + "px";
    } else {
      this.style.gap = `${this._gap}`;
    }
  }
  get wrap() {
    return this._wrap;
  }
  set wrap(value) {
    if (!value)
      return;
    this._wrap = value;
    this.style.flexWrap = this._wrap;
  }
  get mediaQueries() {
    return this._mediaQueries;
  }
  set mediaQueries(value) {
    this._mediaQueries = value;
    let style2 = getStackMediaQueriesStyleClass(this._mediaQueries, this.direction);
    this._mediaStyle && this.classList.remove(this._mediaStyle);
    this._mediaStyle = style2;
    this.classList.add(style2);
  }
  get hover() {
    return this._hover;
  }
  set hover(value) {
    this._hover = value;
    if (this._hover) {
      const hoverStyle = getHoverStyleClass(this._hover);
      this.setStyle("hover", hoverStyle);
    } else {
      this.removeStyle("hover");
    }
  }
  removeStyle(propertyName) {
    let style2 = this.propertyClassMap[propertyName];
    if (style2)
      this.classList.remove(style2);
  }
  setStyle(propertyName, value) {
    this.removeStyle(propertyName);
    if (value) {
      this.propertyClassMap[propertyName] = value;
      this.classList.add(value);
    }
  }
  init() {
    super.init();
    setAttributeToProperty(this, "reverse");
    setAttributeToProperty(this, "direction", "horizontal");
    setAttributeToProperty(this, "justifyContent");
    setAttributeToProperty(this, "alignItems");
    setAttributeToProperty(this, "alignSelf");
    setAttributeToProperty(this, "alignContent");
    setAttributeToProperty(this, "gap");
    setAttributeToProperty(this, "wrap");
    setAttributeToProperty(this, "mediaQueries");
    setAttributeToProperty(this, "hover");
  }
};
StackLayout = __decorateClass([
  customElements2("i-stack", {
    icon: "layer-group",
    group: GroupType.LAYOUT,
    className: "StackLayout",
    props: {
      gap: { type: "number" },
      wrap: { type: "string", default: DEFAULT_VALUES3.wrap },
      direction: { type: "string", default: DEFAULT_VALUES3.direction },
      justifyContent: { type: "string", default: DEFAULT_VALUES3.justifyContent },
      alignItems: { type: "string", default: DEFAULT_VALUES3.alignItems },
      alignSelf: { type: "string", default: DEFAULT_VALUES3.alignSelf },
      alignContent: { type: "string", default: DEFAULT_VALUES3.alignContent },
      reverse: { type: "boolean", default: DEFAULT_VALUES3.reverse }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        gap: {
          type: "number"
        }
      }
    }
  })
], StackLayout);
var HStack = class extends StackLayout {
  constructor(parent, options) {
    super(parent, options);
  }
  get horizontalAlignment() {
    return this._horizontalAlignment;
  }
  set horizontalAlignment(value) {
    this._horizontalAlignment = value || "start";
    this.justifyContent = value;
  }
  get verticalAlignment() {
    return this._verticalAlignment;
  }
  set verticalAlignment(value) {
    this._verticalAlignment = value || "stretch";
    this.alignItems = value;
  }
  init() {
    super.init();
    this.direction = "horizontal";
    setAttributeToProperty(this, "horizontalAlignment");
    setAttributeToProperty(this, "verticalAlignment");
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
HStack = __decorateClass([
  customElements2("i-hstack", {
    icon: "square",
    group: GroupType.LAYOUT,
    className: "HStack",
    props: {
      gap: { type: "number" },
      wrap: { type: "string", default: DEFAULT_VALUES3.wrap },
      justifyContent: { type: "string", default: DEFAULT_VALUES3.justifyContent },
      alignItems: { type: "string", default: DEFAULT_VALUES3.alignItems },
      alignSelf: { type: "string", default: DEFAULT_VALUES3.alignSelf },
      alignContent: { type: "string", default: DEFAULT_VALUES3.alignContent },
      reverse: { type: "boolean", default: DEFAULT_VALUES3.reverse }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        gap: {
          type: "number"
        }
      }
    }
  })
], HStack);
var VStack = class extends StackLayout {
  constructor(parent, options) {
    super(parent, options);
  }
  get horizontalAlignment() {
    return this._horizontalAlignment;
  }
  set horizontalAlignment(value) {
    this._horizontalAlignment = value || "stretch";
    this.alignItems = value;
  }
  get verticalAlignment() {
    return this._verticalAlignment;
  }
  set verticalAlignment(value) {
    this._verticalAlignment = value || "start";
    this.justifyContent = value;
  }
  init() {
    super.init();
    this.direction = "vertical";
    setAttributeToProperty(this, "horizontalAlignment");
    setAttributeToProperty(this, "verticalAlignment");
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
VStack = __decorateClass([
  customElements2("i-vstack", {
    icon: "square",
    group: GroupType.LAYOUT,
    className: "VStack",
    props: {
      gap: { type: "number" },
      wrap: { type: "string", default: DEFAULT_VALUES3.wrap },
      justifyContent: { type: "string", default: DEFAULT_VALUES3.justifyContent },
      alignItems: { type: "string", default: DEFAULT_VALUES3.alignItems },
      alignSelf: { type: "string", default: DEFAULT_VALUES3.alignSelf },
      alignContent: { type: "string", default: DEFAULT_VALUES3.alignContent },
      reverse: { type: "boolean", default: DEFAULT_VALUES3.reverse }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        gap: {
          type: "number"
        }
      }
    }
  })
], VStack);

// packages/layout/src/panel.ts
var Panel = class extends Container {
  constructor(parent, options) {
    super(parent, options);
  }
  get hover() {
    return this._hover;
  }
  set hover(value) {
    this._hover = value;
    if (this._hover) {
      const hoverStyle = getHoverStyleClass(this._hover);
      this.setStyle("hover", hoverStyle);
    } else {
      this.removeStyle("hover");
    }
  }
  removeStyle(propertyName) {
    let style2 = this.propertyClassMap[propertyName];
    if (style2)
      this.classList.remove(style2);
  }
  setStyle(propertyName, value) {
    this.removeStyle(propertyName);
    if (value) {
      this.propertyClassMap[propertyName] = value;
      this.classList.add(value);
    }
  }
  init() {
    super.init();
    setAttributeToProperty(this, "hover");
    this.classList.add(panelStyle);
    if (this.dock) {
      this.classList.add(overflowStyle);
    }
  }
  connectedCallback() {
    if (this.connected) {
      return;
    }
    super.connectedCallback();
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Panel = __decorateClass([
  customElements2("i-panel", {
    icon: "stop",
    group: GroupType.LAYOUT,
    className: "Panel",
    props: {},
    events: {}
  })
], Panel);

// packages/layout/src/grid.ts
var DEFAULT_VALUES4 = {
  autoFillInHoles: false,
  columnsPerRow: 1,
  horizontalAlignment: "start",
  verticalAlignment: "start",
  gap: {}
};
var gridSchemaProps = {
  templateColumns: {
    type: "array",
    items: { type: "string" }
  },
  templateRows: {
    type: "array",
    items: { type: "string" }
  },
  templateAreas: {
    type: "array",
    items: { type: "string" }
  },
  autoColumnSize: {
    type: "string",
    default: ""
  },
  autoRowSize: {
    type: "string",
    default: ""
  },
  columnsPerRow: {
    type: "number",
    default: DEFAULT_VALUES4.columnsPerRow
  },
  gap: {
    type: "object",
    properties: {
      row: {
        type: "string",
        default: ""
      },
      column: {
        type: "string",
        default: ""
      }
    }
  },
  autoFillInHoles: {
    type: "boolean",
    default: DEFAULT_VALUES4.autoFillInHoles
  },
  horizontalAlignment: {
    type: "string",
    enum: ["stretch", "start", "end", "center"],
    default: DEFAULT_VALUES4.horizontalAlignment
  },
  verticalAlignment: {
    type: "string",
    enum: ["stretch", "start", "end", "center", "baseline"],
    default: DEFAULT_VALUES4.verticalAlignment
  }
};
var gridProps = {
  templateColumns: { type: "array" },
  templateRows: { type: "array" },
  templateAreas: { type: "array" },
  autoColumnSize: { type: "string", default: "" },
  autoRowSize: { type: "string", default: "" },
  columnsPerRow: { type: "number", default: DEFAULT_VALUES4.columnsPerRow },
  gap: { type: "object" },
  autoFillInHoles: { type: "boolean", default: DEFAULT_VALUES4.autoFillInHoles },
  horizontalAlignment: { type: "string", default: DEFAULT_VALUES4.horizontalAlignment },
  verticalAlignment: { type: "string", default: DEFAULT_VALUES4.verticalAlignment }
};
var GridLayout = class extends Container {
  constructor(parent, options) {
    super(parent, options);
    this._styleClassMap = {};
    this.removeStyleClass = this.removeStyleClass.bind(this);
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  get templateColumns() {
    return this._templateColumns;
  }
  set templateColumns(columns) {
    this._templateColumns = columns;
    this.removeStyleClass("columns");
    if (columns) {
      let style2 = getTemplateColumnsStyleClass(columns);
      this._styleClassMap["columns"] = style2;
      this.classList.add(style2);
    }
  }
  get templateRows() {
    return this._templateRows;
  }
  set templateRows(rows) {
    this._templateRows = rows;
    this.removeStyleClass("rows");
    if (rows) {
      let style2 = getTemplateRowsStyleClass(rows);
      this._styleClassMap["rows"] = style2;
      this.classList.add(style2);
    }
  }
  get templateAreas() {
    return this._templateAreas;
  }
  set templateAreas(value) {
    this._templateAreas = value;
    this.removeStyleClass("areas");
    if (value) {
      let style2 = getTemplateAreasStyleClass(value);
      this._styleClassMap["areas"] = style2;
      this.classList.add(style2);
    }
  }
  get autoColumnSize() {
    return this._autoColumnSize;
  }
  set autoColumnSize(value) {
    this._autoColumnSize = value;
    if (value) {
      this.style.gridAutoColumns = value;
    }
  }
  get autoRowSize() {
    return this._autoRowSize;
  }
  set autoRowSize(value) {
    this._autoRowSize = value;
    if (value) {
      this.style.gridAutoRows = value;
    }
  }
  get columnsPerRow() {
    return this._columnsPerRow;
  }
  set columnsPerRow(value) {
    this._columnsPerRow = value;
    this.style.gridTemplateColumns = `repeat(${this._columnsPerRow}, 1fr)`;
  }
  get gap() {
    return this._gap;
  }
  set gap(value) {
    this._gap = value;
    if (value) {
      if (value.row) {
        if (typeof value.row == "number") {
          this.style.rowGap = value.row + "px";
        } else {
          this.style.rowGap = value.row;
        }
      }
      if (value.column) {
        if (typeof value.column == "number") {
          this.style.columnGap = value.column + "px";
        } else {
          this.style.columnGap = value.column;
        }
      }
    }
  }
  get horizontalAlignment() {
    return this._horizontalAlignment;
  }
  set horizontalAlignment(value) {
    this._horizontalAlignment = value;
    this.style.justifyItems = value;
  }
  removeStyle(propertyName) {
    let style2 = this.propertyClassMap[propertyName];
    if (style2)
      this.classList.remove(style2);
  }
  setStyle(propertyName, value) {
    this.removeStyle(propertyName);
    if (value) {
      this.propertyClassMap[propertyName] = value;
      this.classList.add(value);
    }
  }
  get justifyContent() {
    return this._justifyContent;
  }
  set justifyContent(value) {
    this._justifyContent = value || "start";
    switch (this._justifyContent) {
      case "start":
        this.setStyle("justifyContent", justifyContentStartStyle);
        break;
      case "center":
        this.setStyle("justifyContent", justifyContentCenterStyle);
        break;
      case "end":
        this.setStyle("justifyContent", justifyContentEndStyle);
        break;
      case "space-between":
        this.setStyle("justifyContent", justifyContentSpaceBetweenStyle);
        break;
      case "space-around":
        this.setStyle("justifyContent", justifyContentSpaceAroundStyle);
        break;
      case "space-evenly":
        this.setStyle("justifyContent", justifyContentSpaceEvenlyStyle);
        break;
    }
  }
  get verticalAlignment() {
    return this._verticalAlignment;
  }
  set verticalAlignment(value) {
    this._verticalAlignment = value;
    this.style.alignItems = value;
  }
  get autoFillInHoles() {
    return this._autoFillInHoles;
  }
  set autoFillInHoles(value) {
    this._autoFillInHoles = value;
    this.style.gridAutoFlow = this._autoFillInHoles ? "dense" : "row";
  }
  get mediaQueries() {
    return this._mediaQueries;
  }
  set mediaQueries(value) {
    this._mediaQueries = value;
    let style2 = getGridLayoutMediaQueriesStyleClass(this._mediaQueries);
    this._mediaStyle && this.classList.remove(this._mediaStyle);
    this._mediaStyle = style2;
    this.classList.add(style2);
  }
  setAttributeToProperty(propertyName) {
    const prop = this.getAttribute(propertyName, true);
    if (prop)
      this[propertyName] = prop;
  }
  removeStyleClass(name) {
    if (this._styleClassMap && this._styleClassMap[name]) {
      this.classList.remove(this._styleClassMap[name]);
      delete this._styleClassMap[name];
    }
  }
  init() {
    super.init();
    this._styleClassMap = {};
    this.classList.add(gridStyle);
    this.setAttributeToProperty("templateColumns");
    this.setAttributeToProperty("templateRows");
    this.setAttributeToProperty("templateAreas");
    this.setAttributeToProperty("gap");
    this.setAttributeToProperty("horizontalAlignment");
    this.setAttributeToProperty("verticalAlignment");
    this.setAttributeToProperty("columnsPerRow");
    this.setAttributeToProperty("autoFillInHoles");
    this.setAttributeToProperty("autoColumnSize");
    this.setAttributeToProperty("autoRowSize");
    this.setAttributeToProperty("mediaQueries");
    this.setAttributeToProperty("justifyContent");
  }
};
GridLayout = __decorateClass([
  customElements2("i-grid-layout", {
    icon: "th",
    group: GroupType.LAYOUT,
    className: "GridLayout",
    props: {
      ...gridProps
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: { ...gridSchemaProps }
    }
  })
], GridLayout);

// packages/layout/src/card.ts
var CardLayout = class extends GridLayout {
  constructor(parent, options) {
    super(parent, options);
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  get cardMinWidth() {
    return this._cardMinWidth;
  }
  set cardMinWidth(value) {
    this._cardMinWidth = value;
    this.updateGridTemplateColumns();
  }
  get columnsPerRow() {
    return this._columnsPerRow;
  }
  set columnsPerRow(value) {
    this._columnsPerRow = value;
    this.updateGridTemplateColumns();
  }
  get cardHeight() {
    return this._cardHeight;
  }
  set cardHeight(value) {
    this._cardHeight = typeof value == "number" ? value + "px" : value;
    this.style.gridAutoRows = this._cardHeight;
  }
  updateGridTemplateColumns() {
    if (this.cardMinWidth && this.columnsPerRow) {
      let minmaxFirstParam = this.gap && this.gap.column ? `max(${this.cardMinWidth}, calc(100%/${this.columnsPerRow} - ${this.gap.column}))` : `max(${this.cardMinWidth}, 100%/${this.columnsPerRow})`;
      this.style.gridTemplateColumns = `repeat(auto-fill, minmax(${minmaxFirstParam}, 1fr))`;
    } else if (this.cardMinWidth) {
      this.style.gridTemplateColumns = `repeat(auto-fill, minmax(min(${this.cardMinWidth}, 100%), 1fr))`;
    } else if (this.columnsPerRow) {
      this.style.gridTemplateColumns = `repeat(${this.columnsPerRow}, 1fr)`;
    }
  }
  setAttributeToProperty(propertyName) {
    const prop = this.getAttribute(propertyName, true);
    if (prop)
      this[propertyName] = prop;
  }
  init() {
    super.init();
    this.autoRowSize = "1fr";
    this.setAttributeToProperty("cardMinWidth");
    this.setAttributeToProperty("cardHeight");
  }
};
CardLayout = __decorateClass([
  customElements2("i-card-layout", {
    icon: "th",
    group: GroupType.LAYOUT,
    className: "CardLayout",
    props: {
      ...gridProps,
      cardMinWidth: { type: "number" },
      cardHeight: { type: "number" }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        ...gridSchemaProps,
        cardMinWidth: {
          type: "number"
        },
        cardHeight: {
          type: "number"
        }
      }
    }
  })
], CardLayout);

// packages/upload/src/style/upload.css.ts
var Theme8 = theme_exports.ThemeVars;
cssRule("i-upload", {
  margin: "1rem 0",
  listStyle: "none",
  minHeight: 200,
  minWidth: 200,
  height: "100%",
  width: "100%",
  display: "flex",
  flexWrap: "wrap",
  $nest: {
    ".i-upload-wrapper": {
      position: "relative",
      border: `2px dashed ${Theme8.divider}`,
      width: "100%",
      display: "flex",
      flexDirection: "column",
      justifyContent: "center",
      alignItems: "center",
      marginBottom: "1rem"
    },
    "i-upload-drag": {
      position: "absolute",
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center"
    },
    ".i-upload-drag_area": {
      marginTop: "4rem"
    },
    ".i-upload-dragger_active": {
      border: `2px dashed ${Theme8.colors.primary.main}`,
      backgroundColor: Theme8.colors.info.light,
      opacity: "0.8"
    },
    'input[type="file"]': {
      display: "none"
    },
    ".i-upload_preview": {
      display: "none",
      minHeight: 200,
      position: "relative",
      overflow: "hidden",
      width: "100%",
      height: "100%"
    },
    ".i-upload_preview img": {
      maxHeight: "inherit",
      maxWidth: "100%"
    },
    ".i-upload_preview-img": {
      maxHeight: "inherit",
      maxWidth: "100%",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      height: "100%"
    },
    ".i-upload_preview-crop": {
      position: "absolute",
      border: `1px dashed ${Theme8.background.paper}`,
      width: 150,
      height: 150,
      left: "50%",
      top: "50%",
      transform: "translate(-50%, -50%)",
      boxSizing: "border-box",
      boxShadow: "0 0 0 9999em",
      color: "rgba(0, 0, 0, 0.5)",
      overflow: "hidden",
      cursor: "crosshair"
    },
    ".i-upload_preview-remove": {
      position: "absolute",
      top: 0,
      left: 0,
      visibility: "hidden",
      opacity: 0,
      width: "100%",
      height: "100%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      background: "rgba(0, 0, 0, 0.58)",
      cursor: "pointer",
      $nest: {
        "> span": {
          padding: "1rem",
          border: "2px solid #fff",
          borderRadius: "5px",
          color: "#fff",
          fontWeight: "bold"
        }
      }
    },
    ".i-upload_preview:hover .i-upload_preview-remove.active": {
      visibility: "visible",
      opacity: 1
    },
    ".i-upload_list": {
      margin: "1rem 0 2rem",
      display: "flex",
      gap: 7,
      width: "100%"
    },
    ".i-upload_list.i-upload_list-picture": {
      flexDirection: "row"
    },
    ".i-upload_list.i-upload_list-text": {
      flexDirection: "column",
      alignContent: "center"
    },
    ".i-upload_list.i-upload_list-text i-icon": {
      position: "unset"
    },
    ".i-upload_list-item": {
      display: "inline-flex",
      position: "relative",
      justifyContent: "space-between"
    },
    ".i-upload_list-item:hover i-icon": {
      display: "block"
    },
    ".i-upload_list.i-upload_list-text .i-upload_list-item:hover": {
      backgroundColor: Theme8.background.default
    },
    ".i-upload_list.i-upload_list-text .i-upload_list-item": {
      width: "100%",
      padding: ".25rem"
    },
    ".i-upload_list-item .i-upload_list-img": {
      width: 100,
      height: 50,
      objectFit: "cover"
    },
    ".i-upload_list-item i-icon": {
      cursor: "pointer",
      position: "absolute",
      right: -5,
      top: -5,
      display: "none"
    }
  }
});

// packages/upload/src/upload.ts
var Theme9 = theme_exports.ThemeVars;
var fileId = 1;
var genFileId = () => Date.now() + fileId++;
var UploadDrag = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this.counter = 0;
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    this._labelElm.textContent = this._caption || "";
    if (!value)
      this._labelElm.style.display = "none";
    else
      this._labelElm.style.display = "";
  }
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
  }
  handleOnDragEnter(source, event) {
    var _a;
    source.preventDefault();
    if (this.disabled)
      return;
    this.counter++;
    (_a = this.parentElement) == null ? void 0 : _a.classList.add("i-upload-dragger_active");
  }
  handleOnDragOver(source, event) {
    source.preventDefault();
  }
  handleOnDragLeave(source, event) {
    var _a;
    if (this.disabled)
      return;
    this.counter--;
    if (this.counter === 0) {
      (_a = this.parentElement) == null ? void 0 : _a.classList.remove("i-upload-dragger_active");
    }
  }
  async getAllFileEntries(dataTransferItemList) {
    let fileEntries = [];
    let queue = [];
    for (let i = 0; i < dataTransferItemList.length; i++) {
      queue.push(dataTransferItemList[i].webkitGetAsEntry());
    }
    while (queue.length > 0) {
      let entry = queue.shift();
      if (entry == null ? void 0 : entry.isFile) {
        fileEntries.push(entry);
      } else if (entry == null ? void 0 : entry.isDirectory) {
        let reader = entry.createReader();
        queue.push(...await this.readAllDirectoryEntries(reader));
      }
    }
    return Promise.all(fileEntries.map((entry) => this.readEntryContentAsync(entry)));
  }
  async readAllDirectoryEntries(directoryReader) {
    let entries = [];
    let readEntries = await this.readEntriesPromise(directoryReader);
    while (readEntries.length > 0) {
      entries.push(...readEntries);
      readEntries = await this.readEntriesPromise(directoryReader);
    }
    return entries;
  }
  async readEntriesPromise(directoryReader) {
    try {
      return await new Promise((resolve, reject) => {
        directoryReader.readEntries(resolve, reject);
      });
    } catch (err) {
      console.log(err);
    }
  }
  async readEntryContentAsync(entry) {
    return new Promise((resolve, reject) => {
      let reading = 0;
      const contents = [];
      reading++;
      entry.file(async (file) => {
        reading--;
        const rawFile = file;
        rawFile.path = entry.fullPath;
        rawFile.cid = await hashFile(file);
        contents.push(rawFile);
        if (reading === 0) {
          resolve(contents);
        }
      });
    });
  }
  async handleOnDrop(source, event) {
    var _a, _b;
    source.preventDefault();
    if (this.disabled)
      return;
    if (typeof this.onBeforeDrop === "function")
      this.onBeforeDrop(this);
    this.counter = 0;
    (_a = this.parentElement) == null ? void 0 : _a.classList.remove("i-upload-dragger_active");
    const accept = (_b = this.parentElement) == null ? void 0 : _b.getAttribute("accept");
    if (!accept) {
      if (this.onDrop) {
        const files = await this.getAllFileEntries(source.dataTransfer.items);
        const flattenFiles = files.reduce((acc, val) => acc.concat(val), []);
        console.log("beforeOnDrop: ", flattenFiles);
        this.onDrop(this, flattenFiles);
      }
      return;
    }
    const valids = [].slice.call(source.dataTransfer.files).filter((file) => {
      const { type, name } = file;
      const extension = name.indexOf(".") > -1 ? `.${name.split(".").pop()}` : "";
      const baseType = type.replace(/\/.*$/, "");
      return accept.split(",").map((type2) => type2.trim()).filter((type2) => type2).some((acceptedType) => {
        if (/\..+$/.test(acceptedType)) {
          return extension === acceptedType;
        }
        if (/\/\*$/.test(acceptedType)) {
          return baseType === acceptedType.replace(/\/\*$/, "");
        }
        if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
          return type === acceptedType;
        }
        return false;
      });
    });
    if (this.onDrop)
      this.onDrop(this, valids);
  }
  init() {
    if (!this._wrapperElm) {
      super.init();
      this.onBeforeDrop = this.getAttribute("onBeforeDrop", true) || this.onBeforeDrop;
      this.onDrop = this.getAttribute("onDrop", true) || this.onDrop;
      this._wrapperElm = this.createElement("div", this);
      this._wrapperElm.classList.add("i-upload-drag_area");
      this._labelElm = this.createElement("span", this._wrapperElm);
      this._labelElm.style.color = Theme9.text.primary;
      this.caption = this.getAttribute("caption", true);
      this.disabled = this.getAttribute("disabled", true);
      this.addEventListener("dragenter", this.handleOnDragEnter.bind(this));
      this.addEventListener("dragover", this.handleOnDragOver.bind(this));
      this.addEventListener("dragleave", this.handleOnDragLeave.bind(this));
      this.addEventListener("drop", this.handleOnDrop.bind(this));
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
UploadDrag = __decorateClass([
  customElements2("i-upload-drag")
], UploadDrag);
var DEFAULT_VALUES5 = {
  draggable: false,
  multiple: false,
  showFileList: false,
  fileList: []
};
var Upload = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      multiple: DEFAULT_VALUES5.multiple
    });
    this._dt = new DataTransfer();
    this._fileList = [];
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    if (this.lblCaption)
      this.lblCaption.caption = this.caption || (this.draggable ? "Drag a file or click to upload" : "Click to upload");
  }
  get accept() {
    return this._accept;
  }
  set accept(value) {
    this._accept = value;
    this._fileElm && value && this._fileElm.setAttribute("accept", `${value}`);
  }
  get draggable() {
    return this._draggable;
  }
  set draggable(value) {
    this._draggable = value;
    if (value)
      this.classList.add("el-upload-dragger");
    else
      this.classList.remove("el-upload-dragger");
  }
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = value;
    if (this._fileElm && value)
      this._fileElm.setAttribute("multiple", `${value}`);
  }
  get fileList() {
    return this._fileList;
  }
  set fileList(value) {
    this._fileList = value;
    if (value && value.length) {
      value.forEach((f) => {
        this._dt.items.add(f);
      });
      if (this._fileElm) {
        this._fileElm.files = this._dt.files;
        this.updateFileListUI(this._fileElm.files);
      }
    }
  }
  get enabled() {
    return super.enabled;
  }
  set enabled(value) {
    super.enabled = value;
    if (this._uploadDragElm)
      this._uploadDragElm.disabled = !value || !this.draggable || this._designMode;
    if (!this._previewRemoveElm)
      return;
    if (value)
      this._previewRemoveElm.classList.add("active");
    else
      this._previewRemoveElm.classList.remove("active");
  }
  addFile(file) {
    this._dt.items.add(file);
    this._fileList.push(file);
    if (typeof this.onAdded === "function")
      this.onAdded(this, file);
  }
  previewFile(files) {
    if (!files || !files.length)
      return;
    const imgUrl = URL.createObjectURL(files[files.length - 1]);
    this.preview(imgUrl);
  }
  async handleUpload(source, event) {
    const files = source.target.files;
    if (files) {
      const processedFiles = [];
      for (let i = 0; i < files.length; i++) {
        const rawFile = files[i];
        rawFile.path = `/${rawFile.name}`;
        rawFile.cid = await hashFile(rawFile);
        processedFiles.push(rawFile);
      }
      this.proccessFiles(processedFiles);
    }
  }
  async proccessFiles(files) {
    if (!files || !files.length)
      return;
    if (!this.fileList)
      this._dt = new DataTransfer();
    for (let i = 0; i < files.length; i++) {
      let file = files[i];
      file.uid = genFileId();
      if (!!this.onUploading)
        await this.checkBeforeUpload(file);
      else
        this.addFile(file);
    }
    this.updateFileListUI(this._dt.files);
    this.previewFile(this._dt.files);
    if (typeof this.onChanged === "function")
      this.onChanged(this, this.fileList);
  }
  async checkBeforeUpload(file) {
    const before = typeof this.onUploading === "function" && this.onUploading(this, file);
    if (before && before.then) {
      before.then((value) => {
        if (value)
          this.addFile(file);
      }, () => {
        if (typeof this.onRemoved === "function")
          this.onRemoved(this, file);
      });
    } else {
      if (typeof this.onRemoved === "function")
        this.onRemoved(this, file);
    }
  }
  updateFileListUI(files) {
    if (this._fileListElm) {
      this._fileListElm.innerHTML = "";
      for (let file of files) {
        const itemElm = this.createElement("div", this._fileListElm);
        itemElm.classList.add("i-upload_list-item");
        if (file.type.includes("image/")) {
          this._fileListElm.classList.add("i-upload_list-picture");
          const imgElm = new Image();
          imgElm.src = URL.createObjectURL(file);
          imgElm.classList.add("i-upload_list-img");
          imgElm.onload = function() {
            URL.revokeObjectURL(imgElm.src);
          };
          itemElm.appendChild(imgElm);
        } else {
          this._fileListElm.classList.add("i-upload_list-text");
          const spanElm = this.createElement("span", itemElm);
          spanElm.textContent = file.name;
        }
        const removeIcon = new Icon(void 0, {
          width: 12,
          height: 12,
          fill: Theme9.action.active,
          name: "trash"
        });
        itemElm.appendChild(removeIcon);
        removeIcon.addEventListener("click", () => this.handleRemove(file));
      }
      this._fileListElm.style.display = files.length ? "flex" : "none";
    }
  }
  renderPreview() {
    this._previewElm = this.createElement("div", this._wrapperElm);
    this._previewElm.classList.add("i-upload_preview");
    this._wrapImgElm = this.createElement("div", this._previewElm);
    this._wrapImgElm.classList.add("i-upload_preview-img");
    this._previewRemoveElm = this.createElement("div", this._previewElm);
    if (this.enabled) {
      this._previewRemoveElm.classList.add("active");
    } else {
      this._previewRemoveElm.classList.remove("active");
    }
    this._previewRemoveElm.classList.add("i-upload_preview-remove");
    this._previewRemoveElm.onclick = this.handleRemoveImagePreview.bind(this);
    const span = this.createElement("span", this._previewRemoveElm);
    span.style.fontFamily = Theme9.typography.fontFamily;
    span.innerHTML = "Click to remove";
  }
  handleRemoveImagePreview(event) {
    if (!this.isPreviewing || !this.enabled)
      return;
    event.stopPropagation();
    const file = this._dt.files.length ? this._dt.files[0] : void 0;
    this.clear();
    if (typeof this.onRemoved === "function")
      this.onRemoved(this, file);
  }
  handleRemove(file) {
    const rawFile = file;
    for (let i = 0; i < this._dt.items.length; i++) {
      if (rawFile.uid === this._dt.files[i].uid) {
        this._dt.items.remove(i);
        this.fileList = this._fileList.filter((f) => f.uid !== rawFile.uid);
        if (typeof this.onRemoved === "function")
          this.onRemoved(this, file);
        break;
      }
    }
    this._fileElm.files = this._dt.files;
    this.updateFileListUI(this._dt.files);
    if (!this._dt.items.length)
      this.clear();
  }
  toBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = (error) => reject(error);
    });
  }
  preview(uri) {
    if (!uri)
      return;
    this.isPreviewing = true;
    this._wrapImgElm.innerHTML = "";
    this._previewImgElm = new Image2(void 0, {
      width: "auto",
      height: "100%"
    });
    this._wrapImgElm.appendChild(this._previewImgElm);
    this._previewImgElm.url = uri;
    this._previewElm.style.display = "block";
    this._wrapperFileElm.style.display = "none";
    if (this._uploadDragElm)
      this._uploadDragElm.style.display = "none";
  }
  clear() {
    this._fileElm.value = "";
    this._wrapperFileElm.style.display = "block";
    if (this._uploadDragElm)
      this._uploadDragElm.style.display = this.draggable ? "flex" : "none";
    if (this._previewElm)
      this._previewElm.style.display = "none";
    this._wrapImgElm && (this._wrapImgElm.innerHTML = "");
    if (this._fileListElm)
      this._fileListElm.style.display = "none";
    this._dt = new DataTransfer();
    this.isPreviewing = false;
    this._fileList = [];
  }
  async upload() {
    var _a;
    const cidItems = await hashFiles(this._fileList);
    let uploadUrl = await application.getUploadUrl(cidItems);
    for (let i = 0; i < this._fileList.length; i++) {
      const file = this._fileList[i];
      if (((_a = file.cid) == null ? void 0 : _a.cid) && uploadUrl[file.cid.cid]) {
        let result = await application.upload(uploadUrl[file.cid.cid], file);
        console.log("upload result: ", result);
      }
    }
  }
  addFiles() {
  }
  addFolder() {
  }
  init() {
    if (!this.initialized) {
      super.init();
      this._wrapperElm = this.createElement("div", this);
      this._wrapperElm.classList.add("i-upload-wrapper");
      this._wrapperFileElm = this.createElement("div", this._wrapperElm);
      this._caption = this.getAttribute("caption", true, "");
      this.draggable = this.getAttribute("draggable", true, DEFAULT_VALUES5.draggable);
      this._uploadDragElm = new UploadDrag(this, {
        disabled: !this.enabled || !this.draggable || this._designMode,
        onBeforeDrop: (source) => {
          if (this.onBeforeDrop)
            this.onBeforeDrop(source);
        },
        onDrop: (source, value) => {
          value && this.proccessFiles(value);
        }
      });
      this._wrapperElm.appendChild(this._uploadDragElm);
      this._fileElm = this.createElement("input", this._wrapperFileElm);
      this._fileElm.type = "file";
      this.multiple = this.getAttribute("multiple", true, DEFAULT_VALUES5.multiple);
      this.accept = this.getAttribute("accept");
      this._fileElm.disabled = !this.enabled;
      this._fileElm.readOnly = this._designMode;
      const panel = new VStack(void 0, {
        alignItems: "center"
      });
      new Icon(panel, {
        name: "arrow-down",
        height: 32,
        width: 32,
        margin: {
          bottom: 20
        },
        fill: Theme9.divider
      });
      this.lblCaption = new Label(panel, {
        caption: this.caption || (this.draggable ? "Drag a file or click to upload" : "Click to upload"),
        font: {
          size: "18px"
        }
      });
      this._wrapperFileElm.appendChild(panel);
      const fileListAttr = this.getAttribute("showFileList", true, DEFAULT_VALUES5.showFileList);
      if (fileListAttr && !this._fileListElm) {
        this._fileListElm = this.createElement("div", this);
        this._fileListElm.classList.add("i-upload_list");
        this._fileListElm.style.display = "none";
      }
      this.renderPreview();
      const fileList = this.getAttribute("fileList", true);
      fileList && (this.fileList = fileList);
      this._wrapperElm.addEventListener("click", (event) => {
        event.stopPropagation();
        if (!this.enabled || this._designMode)
          return;
        if (!this.isPreviewing)
          this._fileElm.click();
      });
      this._fileElm.addEventListener("change", this.handleUpload.bind(this));
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Upload = __decorateClass([
  customElements2("i-upload", {
    icon: "file",
    group: GroupType.FIELDS,
    className: "Upload",
    props: {
      caption: { type: "string", default: "" },
      accept: { type: "string", default: "" },
      draggable: { type: "boolean", default: DEFAULT_VALUES5.draggable },
      multiple: { type: "boolean", default: DEFAULT_VALUES5.multiple },
      fileList: { type: "array", default: DEFAULT_VALUES5.fileList },
      showFileList: { type: "boolean", default: DEFAULT_VALUES5.showFileList }
    },
    events: {
      onBeforeDrop: [
        { name: "target", type: "Upload", isControl: true }
      ],
      onChanged: [
        { name: "target", type: "Upload", isControl: true },
        { name: "files", type: "UploadRawFile[]" }
      ],
      onRemoved: [
        { name: "target", type: "Upload", isControl: true },
        { name: "file", type: "File" }
      ],
      onAdded: [
        { name: "target", type: "Upload", isControl: true },
        { name: "file", type: "File" }
      ],
      onUploading: [
        { name: "target", type: "Upload", isControl: true },
        { name: "file", type: "File" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        caption: {
          type: "string"
        },
        accept: {
          type: "string"
        },
        draggable: {
          type: "boolean",
          default: DEFAULT_VALUES5.draggable
        },
        multiple: {
          type: "boolean",
          default: DEFAULT_VALUES5.multiple
        },
        showFileList: {
          type: "boolean",
          default: DEFAULT_VALUES5.showFileList
        }
      }
    }
  })
], Upload);

// packages/button/src/style/button.css.ts
var Theme10 = theme_exports.ThemeVars;
cssRule("i-button", {
  background: Theme10.colors.primary.main,
  boxShadow: Theme10.shadows[2],
  color: Theme10.text.primary,
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: 4,
  fontFamily: Theme10.typography.fontFamily,
  fontSize: Theme10.typography.fontSize,
  gap: 5,
  cursor: "pointer",
  userSelect: "none",
  $nest: {
    "&:not(.disabled):hover": {},
    "&.disabled": {
      color: Theme10.text.disabled,
      boxShadow: Theme10.shadows[0],
      background: Theme10.action.disabledBackground,
      cursor: "not-allowed"
    },
    "i-icon": {
      display: "inline-block",
      fill: Theme10.text.primary,
      verticalAlign: "middle"
    },
    ".caption": {
      paddingRight: ".5rem"
    },
    "&.is-spinning, &.is-spinning:not(.disabled):hover, &.is-spinning:not(.disabled):focus": {
      color: Theme10.text.disabled,
      boxShadow: Theme10.shadows[0],
      background: Theme10.action.disabledBackground,
      cursor: "default"
    }
  }
});

// packages/button/src/button.ts
var defaultIcon = {
  width: 16,
  height: 16,
  fill: theme_exports.ThemeVars.text.primary
};
var Button = class extends Control {
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  constructor(parent, options) {
    super(parent, options);
  }
  get caption() {
    var _a;
    return ((_a = this.captionElm) == null ? void 0 : _a.innerHTML) || "";
  }
  set caption(value) {
    if (!this.captionElm)
      return;
    this.captionElm.innerHTML = value;
    this.captionElm.style.display = value ? "" : "none";
  }
  get icon() {
    if (!this._icon) {
      this._icon = new Icon(this, defaultIcon);
      this.prependIcon(this._icon);
    }
    return this._icon;
  }
  set icon(value) {
    if (this._icon && this.contains(this._icon))
      this.removeChild(this._icon);
    this._icon = value;
    this.prependIcon(this._icon);
  }
  get rightIcon() {
    if (!this._rightIcon) {
      this._rightIcon = new Icon(this, {
        ...defaultIcon,
        name: "spinner"
      });
      this.appendIcon(this._rightIcon);
    }
    return this._rightIcon;
  }
  set rightIcon(value) {
    if (this._rightIcon && this.contains(this._rightIcon))
      this.removeChild(this._rightIcon);
    this._rightIcon = value;
    this.appendIcon(this._rightIcon);
  }
  get enabled() {
    return super.enabled;
  }
  set enabled(value) {
    var _a, _b, _c, _d;
    super.enabled = value;
    if (!value && this._background) {
      let bg = "";
      ((_a = this._background) == null ? void 0 : _a.image) && (bg += `url(${(_b = this._background) == null ? void 0 : _b.image})`);
      ((_c = this._background) == null ? void 0 : _c.color) && (bg += `${(_d = this._background) == null ? void 0 : _d.color}`);
      this.style.background = bg;
    }
  }
  get isSpinning() {
    return this._icon && this._icon.spin && this._icon.visible || this._rightIcon && this._rightIcon.spin && this._rightIcon.visible;
  }
  prependIcon(icon) {
    if (!icon)
      return;
    this.appendChild(icon);
    this.captionElm && this.insertBefore(icon, this.captionElm);
  }
  appendIcon(icon) {
    if (!icon)
      return;
    this.appendChild(icon);
    this.captionElm && this.insertBefore(this.captionElm, icon);
  }
  updateButton() {
    var _a, _b, _c, _d;
    if (this.isSpinning)
      this.classList.add("is-spinning");
    else
      this.classList.remove("is-spinning");
    if (!this.enabled && this._background) {
      let bg = "";
      ((_a = this._background) == null ? void 0 : _a.image) && (bg += `url(${(_b = this._background) == null ? void 0 : _b.image})`);
      ((_c = this._background) == null ? void 0 : _c.color) && (bg += `${(_d = this._background) == null ? void 0 : _d.color}`);
      this.style.background = bg;
    }
  }
  _handleClick(event) {
    if (this.isSpinning || !this.enabled || this._designMode)
      return false;
    return super._handleClick(event);
  }
  refresh() {
    super.refresh();
    this.updateButton();
  }
  init() {
    var _a, _b;
    if (!this.captionElm) {
      super.init();
      this.onClick = this.getAttribute("onClick", true) || this.onClick;
      this.captionElm = this.createElement("span", this);
      let caption = this.getAttribute("caption", true, "");
      this.caption = caption;
      let iconAttr = this.getAttribute("icon", true);
      if ((iconAttr == null ? void 0 : iconAttr.name) || ((_a = iconAttr == null ? void 0 : iconAttr.image) == null ? void 0 : _a.url)) {
        iconAttr = { ...defaultIcon, ...iconAttr };
        const icon = new Icon(this, iconAttr);
        this.icon = icon;
      }
      let rightIconAttr = this.getAttribute("rightIcon", true);
      if ((rightIconAttr == null ? void 0 : rightIconAttr.name) || ((_b = rightIconAttr == null ? void 0 : rightIconAttr.image) == null ? void 0 : _b.url)) {
        rightIconAttr = { ...defaultIcon, name: "spinner", ...rightIconAttr };
        const icon = new Icon(this, rightIconAttr);
        this.rightIcon = icon;
      }
    }
  }
};
Button = __decorateClass([
  customElements2("i-button", {
    icon: "closed-captioning",
    className: "Button",
    props: {
      caption: {
        type: "string",
        default: ""
      },
      icon: {
        type: "object",
        default: {}
      },
      rightIcon: {
        type: "object",
        default: {}
      }
    },
    events: {},
    dataSchema: {
      type: "object",
      required: ["caption"],
      properties: {
        caption: {
          required: true,
          type: "string",
          title: "Caption"
        },
        icon: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            fill: {
              type: "string",
              format: "color"
            },
            width: {
              type: "number"
            },
            height: {
              type: "number"
            },
            image: {
              type: "object",
              properties: {
                url: {
                  type: "string"
                }
              }
            }
          }
        },
        rightIcon: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            fill: {
              type: "string",
              format: "color"
            },
            width: {
              type: "number"
            },
            height: {
              type: "number"
            },
            image: {
              type: "object",
              properties: {
                url: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    },
    group: GroupType.BASIC
  })
], Button);

// packages/modal/src/style/modal.css.ts
var Theme11 = theme_exports.ThemeVars;
var getOverlayStyle = () => {
  return style({
    backgroundColor: "rgba(12, 18, 52, 0.7)",
    position: "fixed",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    opacity: 0,
    visibility: "hidden",
    zIndex: 1e3,
    transition: "visibility 0s linear .25s, opacity .25s",
    $nest: {
      "&.show": {
        opacity: "1",
        visibility: "visible",
        transition: "visibility 0s linear, opacity .25s"
      }
    }
  });
};
var getWrapperStyle = () => {
  return style({
    position: "fixed",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    opacity: 0,
    visibility: "hidden",
    transform: "scale(0.8)",
    transition: "visibility 0s linear .25s,opacity .25s 0s,transform .25s",
    zIndex: 1e3,
    overflow: "auto",
    $nest: {
      "&.show": {
        opacity: "1",
        visibility: "visible",
        transform: "scale(1)",
        transition: "visibility 0s linear 0s,opacity .25s 0s,transform .25s"
      }
    }
  });
};
var getNoBackdropStyle = () => {
  return style({
    position: "inherit",
    top: 0,
    left: 0,
    opacity: 0,
    visibility: "hidden",
    transform: "scale(0.8)",
    transition: "visibility 0s linear .25s,opacity .25s 0s,transform .25s",
    zIndex: 1e3,
    maxWidth: "inherit",
    $nest: {
      ".modal": {
        margin: "0"
      },
      "&.show": {
        opacity: "1",
        visibility: "visible",
        transform: "scale(1)",
        transition: "visibility 0s linear 0s,opacity .25s 0s,transform .25s"
      }
    }
  });
};
var getFixedWrapperStyle = (paddingLeft, paddingTop) => {
  return style({
    paddingLeft,
    paddingTop,
    width: "100%",
    height: "100%"
  });
};
var getAbsoluteWrapperStyle = (left, top) => {
  return style({
    left,
    top,
    width: "inherit",
    height: "inherit"
  });
};
var getModalStyle = (left, top) => {
  return style({
    left,
    top
  });
};
var modalStyle = style({
  fontFamily: "Helvetica",
  fontSize: "14px",
  padding: "10px 10px 5px 10px",
  backgroundColor: Theme11.background.modal,
  position: "relative",
  borderRadius: "2px",
  width: "inherit",
  maxWidth: "100%"
});
var getBodyStyle = style({
  height: "100%",
  overflow: "hidden"
});
var titleStyle = style({
  fontSize: "18px",
  display: "flex",
  justifyContent: "space-between",
  alignItems: "center",
  $nest: {
    "span": {
      color: Theme11.colors.primary.main
    },
    "i-icon": {
      display: "inline-block",
      cursor: "pointer"
    }
  }
});
var getModalMediaQueriesStyleClass = (mediaQueries) => {
  let styleObj = getControlMediaQueriesStyle(mediaQueries);
  for (let mediaQuery of mediaQueries) {
    let mediaQueryRule = getMediaQueryRule(mediaQuery);
    if (mediaQueryRule) {
      const nestObj = styleObj["$nest"][mediaQueryRule]["$nest"] || {};
      const ruleObj = styleObj["$nest"][mediaQueryRule];
      styleObj["$nest"][mediaQueryRule] = {
        ...ruleObj,
        $nest: {
          ...nestObj,
          "&.show > .modal-overlay": {},
          ".modal-wrapper": {},
          ".modal": {}
        }
      };
      const {
        showBackdrop,
        padding,
        position,
        maxWidth: maxWidthValue,
        maxHeight: maxHeightValue,
        minWidth: minWidthValue,
        width: widthValue,
        height: heightValue,
        popupPlacement,
        overflow,
        border
      } = mediaQuery.properties || {};
      if (showBackdrop) {
        if (showBackdrop) {
          styleObj["$nest"][mediaQueryRule]["$nest"]["&.show > .modal-overlay"]["visibility"] = "visible !important";
          styleObj["$nest"][mediaQueryRule]["$nest"]["&.show > .modal-overlay"]["opacity"] = "1 !important";
        } else {
          styleObj["$nest"][mediaQueryRule]["$nest"]["&.show > .modal-overlay"]["visibility"] = "hidden !important";
          styleObj["$nest"][mediaQueryRule]["$nest"]["&.show > .modal-overlay"]["opacity"] = "0 !important";
        }
      }
      if (position) {
        styleObj["$nest"][mediaQueryRule]["$nest"][".modal-wrapper"]["position"] = `${position} !important`;
      }
      if (maxWidthValue !== void 0 && maxWidthValue !== null) {
        const maxWidth = `${getSpacingValue(maxWidthValue)} !important`;
        styleObj["$nest"][mediaQueryRule]["maxWidth"] = maxWidth;
        styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["maxWidth"] = maxWidth;
      }
      if (maxHeightValue !== void 0 && maxHeightValue !== null) {
        const maxHeight = `${getSpacingValue(maxHeightValue)} !important`;
        styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["maxHeight"] = maxHeight;
      }
      if (heightValue !== void 0 && heightValue !== null) {
        const height = `${getSpacingValue(heightValue)} !important`;
        styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["height"] = height;
      }
      if (widthValue !== void 0 && widthValue !== null) {
        const width = `${getSpacingValue(widthValue)} !important`;
        styleObj["$nest"][mediaQueryRule]["width"] = width;
        styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["width"] = width;
      }
      if (minWidthValue !== void 0 && minWidthValue !== null) {
        const minWidth = `${getSpacingValue(minWidthValue)} !important`;
        styleObj["$nest"][mediaQueryRule]["minWidth"] = minWidth;
        styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["minWidth"] = minWidth;
      }
      if (popupPlacement) {
        const placement = popupPlacement;
        let positionObj = {
          top: "unset",
          left: "unset",
          right: "unset",
          bottom: "unset"
        };
        if (placement === "bottom") {
          positionObj.top = "auto !important";
          positionObj.left = "0 !important";
          positionObj.bottom = "0 !important";
        } else if (placement === "top") {
          positionObj.top = "0 !important";
          positionObj.left = "0 !important";
        } else if (placement === "center") {
          positionObj.top = "50% !important";
          positionObj.left = "50% !important";
        }
        for (let pos in positionObj) {
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal-wrapper"][pos] = positionObj[pos];
        }
      }
      if (border) {
        const { radius, width, style: style2, color, bottom, top, left, right } = border;
        if (width !== void 0 && width !== null)
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["border"] = `${width || ""} ${style2 || ""} ${color || ""}!important`;
        if (radius) {
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal-wrapper"]["borderRadius"] = "inherit";
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["borderRadius"] = `${getSpacingValue(radius)} !important`;
        }
        if (bottom)
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["borderBottom"] = `${getSpacingValue(bottom.width || "")} ${bottom.style || ""} ${bottom.color || ""}!important`;
        if (top)
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["borderTop"] = `${getSpacingValue(top.width || "") || ""} ${top.style || ""} ${top.color || ""}!important`;
        if (left)
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["borderLeft"] = `${getSpacingValue(left.width || "")} ${left.style || ""} ${left.color || ""}!important`;
        if (right)
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["borderRight"] = `${getSpacingValue(right.width || "")} ${right.style || ""} ${right.color || ""}!important`;
      }
      if (padding) {
        const { top = 0, right = 0, bottom = 0, left = 0 } = padding;
        styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["padding"] = `${getSpacingValue(top)} ${getSpacingValue(right)} ${getSpacingValue(bottom)} ${getSpacingValue(left)} !important`;
      }
      if (overflow) {
        if (typeof overflow === "string") {
          styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["overflow"] = `${overflow} !important`;
        } else {
          const { x, y } = overflow || {};
          if (x === y) {
            styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["overflow"] = `${x} !important`;
          } else {
            if (x)
              styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["overflowX"] = `${x} !important`;
            if (y)
              styleObj["$nest"][mediaQueryRule]["$nest"][".modal"]["overflowY"] = `${y} !important`;
          }
        }
      }
    }
  }
  return style(styleObj);
};

// packages/modal/src/modal.ts
var Theme12 = theme_exports.ThemeVars;
var showEvent = new Event("show");
var DEFAULT_VALUES6 = {
  showBackdrop: true,
  popupPlacement: "center",
  closeOnBackdropClick: true,
  isChildFixed: false,
  closeOnScrollChildFixed: false
};
var Modal = class extends Container {
  constructor(parent, options) {
    super(parent, options, {
      showBackdrop: true,
      closeOnBackdropClick: true,
      popupPlacement: "center"
    });
    this._visible = false;
    this.hasInitializedChildFixed = false;
    this.mapScrollTop = {};
    this.boundHandleModalMouseDown = this.handleModalMouseDown.bind(this);
    this.boundHandleModalMouseUp = this.handleModalMouseUp.bind(this);
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    var _a, _b;
    if (value) {
      this._visible = true;
      this.style.display = "block";
      this.wrapperDiv.classList.add("show");
      this.positionAtChildFixed(true);
      this.dispatchEvent(showEvent);
      if (this.showBackdrop) {
        this.overlayDiv.classList.add("show");
        document.body.style.overflow = "hidden";
        const parentModal = (_a = this.parentElement) == null ? void 0 : _a.closest("i-modal");
        if (parentModal) {
          parentModal.wrapperDiv.style.overflow = "hidden";
          parentModal.wrapperDiv.scrollTop = 0;
        }
        this.wrapperDiv.style.overflow = "hidden auto";
      }
      document.addEventListener("mousedown", this.boundHandleModalMouseDown);
      document.addEventListener("mouseup", this.boundHandleModalMouseUp);
    } else {
      this.positionAtChildFixed(false);
      this._visible = false;
      this.style.display = "none";
      this.wrapperDiv.classList.remove("show");
      this.overlayDiv.classList.remove("show");
      if (this.showBackdrop) {
        const parentModal = (_b = this.parentElement) == null ? void 0 : _b.closest("i-modal");
        if (parentModal) {
          parentModal.wrapperDiv.style.overflow = "hidden auto";
          document.body.style.overflow = "hidden";
        } else {
          document.body.style.overflow = "hidden auto";
        }
      }
      if (this.isChildFixed) {
        this.wrapperDiv.style.display = "none";
      }
      if (typeof this.onClose === "function")
        this.onClose(this);
      document.removeEventListener("mousedown", this.boundHandleModalMouseDown);
      document.removeEventListener("mouseup", this.boundHandleModalMouseUp);
    }
  }
  get onOpen() {
    return this._onOpen;
  }
  set onOpen(callback) {
    this._onOpen = callback;
  }
  get title() {
    const titleElm = this.titleSpan.querySelector("span");
    return (titleElm == null ? void 0 : titleElm.innerHTML) || "";
  }
  set title(value) {
    const titleElm = this.titleSpan.querySelector("span");
    titleElm && (titleElm.innerHTML = value || "");
  }
  get popupPlacement() {
    return this._placement;
  }
  set popupPlacement(value) {
    this._placement = value;
  }
  get closeIcon() {
    return this._closeIcon;
  }
  set closeIcon(elm) {
    if (this._closeIcon && this.titleSpan.contains(this._closeIcon))
      this.titleSpan.removeChild(this._closeIcon);
    this._closeIcon = elm;
    if (this._closeIcon) {
      this._closeIcon.classList.add("i-modal-close");
      this._closeIcon.onClick = () => this.visible = false;
      this.titleSpan.appendChild(this._closeIcon);
    }
  }
  get closeOnBackdropClick() {
    return this._closeOnBackdropClick;
  }
  set closeOnBackdropClick(value) {
    this._closeOnBackdropClick = typeof value === "boolean" ? value : true;
  }
  get showBackdrop() {
    return this._showBackdrop;
  }
  set showBackdrop(value) {
    this._showBackdrop = typeof value === "boolean" ? value : true;
    if (this._showBackdrop) {
      const wrapperStyle = getWrapperStyle();
      this.setTargetStyle(this.wrapperDiv, "showBackdrop", wrapperStyle);
      this.style.position = "unset";
    } else {
      this.updateNoBackdropMd();
      const noBackdropStyle = getNoBackdropStyle();
      this.setTargetStyle(this.wrapperDiv, "showBackdrop", noBackdropStyle);
    }
  }
  updateNoBackdropMd() {
    if (!this.showBackdrop) {
      this.style.position = "absolute";
      let left = "0px";
      let parent = this._parent || this.linkTo || this.parentElement || document.body;
      const isOutside = !(parent instanceof Range) && !(parent == null ? void 0 : parent.contains(this));
      let top = `${isOutside ? window.scrollY : 0}px`;
      this.setTargetStyle(this, "modal", getModalStyle(left, top));
    }
  }
  get item() {
    return this.modalDiv.children[0];
  }
  set item(value) {
    if (value instanceof Control) {
      this.modalDiv.innerHTML = "";
      value && this.modalDiv.appendChild(value);
    }
  }
  get body() {
    return this.modalDiv.children[0];
  }
  set body(value) {
    if (value instanceof Control) {
      this.bodyDiv.innerHTML = "";
      value && this.bodyDiv.appendChild(value);
    }
  }
  get position() {
    return this._wrapperPositionAt;
  }
  set position(value) {
    this._wrapperPositionAt = value;
  }
  get isChildFixed() {
    return this._isChildFixed;
  }
  set isChildFixed(value) {
    this._isChildFixed = value;
    if (value) {
      this.setChildFixed();
    } else {
      this.style.position = "unset";
    }
  }
  get closeOnScrollChildFixed() {
    return this._closeOnScrollChildFixed;
  }
  set closeOnScrollChildFixed(value) {
    this._closeOnScrollChildFixed = value;
  }
  get mediaQueries() {
    return this._mediaQueries;
  }
  set mediaQueries(value) {
    this._mediaQueries = value;
    let style2 = getModalMediaQueriesStyleClass(this._mediaQueries);
    this._mediaStyle && this.classList.remove(this._mediaStyle);
    this._mediaStyle = style2;
    this.classList.add(style2);
  }
  setChildFixed() {
    this.style.position = "fixed";
    this.zIndex = 9999;
    this.mapScrollTop = {};
    const getScrollY = (elm) => {
      let scrollID = elm.getAttribute("scroll-id");
      if (!scrollID) {
        scrollID = IdUtils.generateUUID();
        elm.setAttribute("scroll-id", scrollID);
      }
      this.mapScrollTop[scrollID] = elm.scrollTop;
    };
    const onParentScroll = (e) => {
      if (this.visible && this.closeOnScrollChildFixed) {
        this.visible = false;
      }
      if (e && !e.target.offsetParent && e.target.getAttribute) {
        getScrollY(e.target);
      }
      if (this.visible && !this.closeOnScrollChildFixed) {
        this.positionAtChildFixed(true);
      }
    };
    let parentElement = this.parentNode;
    while (parentElement) {
      this.hasInitializedChildFixed = true;
      parentElement.addEventListener("scroll", (e) => onParentScroll(e));
      parentElement = parentElement.parentNode;
      if (parentElement === document.body) {
        document.addEventListener("scroll", (e) => onParentScroll(e));
        break;
      } else if (parentElement && !parentElement.offsetParent && parentElement.scrollTop && typeof parentElement.getAttribute === "function") {
        getScrollY(parentElement);
      }
    }
  }
  positionAtChildFixed(value) {
    if (this.isChildFixed) {
      if (!this.hasInitializedChildFixed) {
        this.setChildFixed();
      }
      if (this.wrapperDiv) {
        this.wrapperDiv.style.position = !value ? "unset" : "relative";
        this.wrapperDiv.style.display = !value ? "none" : "block";
      }
      if (value && this.parentElement) {
        const { x, y, height } = this.parentElement.getBoundingClientRect();
        const mdClientRect = this.getBoundingClientRect();
        const { innerHeight, innerWidth } = window;
        const elmHeight = mdClientRect.height + (height || 20);
        const elmWidth = mdClientRect.width;
        let totalScrollY = 0;
        for (const key2 in this.mapScrollTop) {
          totalScrollY += this.mapScrollTop[key2];
        }
        const parent = this.getWrapperParent(this.parentElement);
        const newY = parent ? 0 : y;
        let left = "";
        let top = "";
        if (y + elmHeight > innerHeight) {
          const elmTop = newY - elmHeight + totalScrollY;
          top = `${elmTop < 0 ? 0 : elmTop}px`;
        } else {
          top = `${newY + totalScrollY}px`;
        }
        if (x + elmWidth > innerWidth) {
          left = `${innerWidth - elmWidth}px`;
        } else {
          left = `${x}px`;
        }
        this.setTargetStyle(this, "modal", getModalStyle(left, top));
      }
    }
  }
  getWrapperParent(rootParent) {
    if (!this.linkTo)
      return null;
    let parent = null;
    for (let child2 of rootParent.children) {
      if (child2.contains(this.linkTo)) {
        parent = child2;
        break;
      }
    }
    return parent;
  }
  positionAt(placement) {
    if (this.showBackdrop) {
      this.positionAtFix(placement);
    } else {
      this.updateNoBackdropMd();
      this.positionAtAbsolute(placement);
    }
  }
  positionAtFix(placement) {
    let parent = document.body;
    let coords = this.getWrapperFixCoords(parent, placement);
    const wrapperPositionStyle = getFixedWrapperStyle(coords.left + "px", coords.top + "px");
    this.setTargetStyle(this.wrapperDiv, "wrapperPosition", wrapperPositionStyle);
  }
  positionAtAbsolute(placement) {
    let parent = this._parent || this.linkTo || this.parentElement || document.body;
    let coords;
    if (this.position === "fixed") {
      coords = this.getWrapperFixCoords(parent, placement);
    } else {
      coords = this.getWrapperAbsoluteCoords(parent, placement);
    }
    const wrapperPositionStyle = getAbsoluteWrapperStyle(coords.left + "px", coords.top + "px");
    this.setTargetStyle(this.wrapperDiv, "wrapperPosition", wrapperPositionStyle);
  }
  getWrapperFixCoords(parent, placement) {
    const parentCoords = parent.getBoundingClientRect();
    let left = 0;
    let top = 0;
    const parentHeight = this.showBackdrop ? (parentCoords.height || window.innerHeight) - 1 : parent.offsetHeight || parentCoords.height;
    const { wrapperLeft, wrapperTop } = this.getWrapperOffsets(parent);
    let parentTop = Math.max(parent.offsetTop || 0, parentCoords.top) + wrapperTop;
    let parentLeft = parentCoords.left + wrapperLeft;
    let parentWidth = parent.offsetWidth || parentCoords.width;
    let parentRight = parentLeft + parentWidth;
    const viewportWidth = document.documentElement.clientWidth;
    const viewportHeight = document.documentElement.clientHeight;
    switch (placement) {
      case "center":
        top = parentHeight / 2 - this.modalDiv.offsetHeight / 2;
        left = parentCoords.width / 2 - this.modalDiv.offsetWidth / 2 - 1;
        break;
      case "top":
        top = this.showBackdrop ? 0 : parentTop - parentHeight - this.modalDiv.offsetHeight / 2;
        left = parentLeft + (parentWidth - this.modalDiv.offsetWidth) / 2 - 1;
        break;
      case "topLeft":
        top = this.showBackdrop ? 0 : parentTop - parentHeight - this.modalDiv.offsetHeight / 2;
        left = parentLeft;
        break;
      case "topRight":
        top = this.showBackdrop ? 0 : parentTop - parentHeight - this.modalDiv.offsetHeight / 2;
        left = parentLeft + parentWidth - this.modalDiv.offsetWidth - 1;
        break;
      case "bottom":
        top = parentTop + parentHeight;
        if (this.showBackdrop)
          top = top - this.modalDiv.offsetHeight - 1;
        left = parentLeft + (parentWidth - this.modalDiv.offsetWidth) / 2 - 1;
        break;
      case "bottomLeft":
        top = parentTop + parentHeight;
        if (this.showBackdrop)
          top = top - this.modalDiv.offsetHeight;
        left = parentLeft;
        break;
      case "bottomRight":
        top = parentTop + parentHeight;
        if (this.showBackdrop)
          top = top - this.modalDiv.offsetHeight;
        left = parentLeft + parentWidth - this.modalDiv.offsetWidth - 1;
        break;
      case "rightTop":
        top = parentTop;
        left = this.showBackdrop ? parentCoords.right : parentRight;
        if (left + this.modalDiv.offsetWidth > viewportWidth) {
          left = viewportWidth - this.modalDiv.offsetWidth;
        }
        if (top + this.modalDiv.offsetHeight > viewportHeight) {
          top = viewportHeight - this.modalDiv.offsetHeight;
        }
        break;
      case "left":
        left = this.showBackdrop ? 0 : parentLeft - this.modalDiv.offsetWidth;
        top = this.showBackdrop ? 0 : parentTop - parentHeight - this.modalDiv.offsetHeight / 2;
        break;
      case "right":
        top = (this.showBackdrop ? 0 : parentTop) + parentHeight / 2 - this.modalDiv.offsetHeight / 2;
        left = this.showBackdrop ? parentLeft + parentWidth - this.modalDiv.offsetWidth : parentLeft + parentWidth + this.modalDiv.offsetWidth / 2;
        if (left + this.modalDiv.offsetWidth > viewportWidth) {
          left = viewportWidth - this.modalDiv.offsetWidth;
        }
        if (top + this.modalDiv.offsetHeight > viewportHeight) {
          top = viewportHeight - this.modalDiv.offsetHeight;
        }
        break;
    }
    left = left < 0 ? parentLeft : left;
    top = top < 0 ? parentTop : top;
    return { top, left };
  }
  getWrapperOffsets(parent) {
    let wrapperTop = 0;
    let wrapperLeft = 0;
    if (this.isChildFixed) {
      if (parent.nodeName === "I-MODAL") {
        const wrapper = parent.querySelector(".modal-wrapper");
        if (wrapper) {
          wrapperTop = wrapper.offsetTop;
          wrapperLeft = wrapper.offsetLeft;
        }
      }
    }
    return { wrapperTop, wrapperLeft };
  }
  getWrapperAbsoluteCoords(parent, placement) {
    const parentCoords = parent.getBoundingClientRect();
    const viewportWidth = document.documentElement.clientWidth;
    const viewportHeight = document.documentElement.clientHeight;
    const isOutside = !(parent == null ? void 0 : parent.contains(this));
    let left = 0;
    let top = 0;
    const constrainToViewport = (value, dimension) => {
      const lowercasePlacement = placement.toLowerCase();
      if (dimension === "width") {
        if (isOutside) {
          if (value + this.modalDiv.offsetWidth > viewportWidth) {
            value = viewportWidth - this.modalDiv.offsetWidth;
          } else if (value < 0) {
            value = 0;
          }
        } else {
          if (lowercasePlacement.includes("right")) {
            if (lowercasePlacement === "righttop" || lowercasePlacement === "right") {
              if (parentCoords.right + this.wrapperDiv.offsetWidth > viewportWidth) {
                value = viewportWidth - parentCoords.left - this.wrapperDiv.offsetWidth;
              }
            } else {
              if (parentCoords.right - this.wrapperDiv.offsetWidth < 0) {
                value = -parentCoords.left;
              }
            }
          } else {
            if (lowercasePlacement === "left") {
              if (parentCoords.left - this.wrapperDiv.offsetWidth < 0) {
                value = 0;
              }
            } else {
              if (value + parentCoords.left < 0) {
                value = -parentCoords.left;
              }
            }
          }
          if (value + parentCoords.left + this.modalDiv.offsetWidth > viewportWidth) {
            value = Math.max(parentCoords.width - this.wrapperDiv.offsetWidth, window.innerWidth - parentCoords.left - this.wrapperDiv.offsetWidth);
          }
        }
      }
      if (dimension === "height") {
        if (isOutside) {
          if (value + this.modalDiv.offsetHeight > viewportHeight) {
            value = viewportHeight - this.modalDiv.offsetHeight;
          } else if (value < 0) {
            value = 0;
          }
        } else {
          if (lowercasePlacement.includes("bottom")) {
            if (parentCoords.bottom + this.wrapperDiv.offsetHeight > viewportHeight) {
              value = viewportHeight - parentCoords.top - this.wrapperDiv.offsetHeight;
            }
          } else {
            if (parentCoords.top - this.wrapperDiv.offsetHeight < 0) {
              value = 0;
            }
          }
        }
      }
      return value;
    };
    let parentLeft = isOutside ? parentCoords.left : 0;
    let parentTop = isOutside ? parentCoords.top : 0;
    let parentRight = isOutside ? parentCoords.right : parentCoords.width;
    switch (placement) {
      case "center":
        left = (parentCoords.width - this.wrapperDiv.offsetWidth) / 2 + parentLeft;
        top = (parentCoords.height - this.modalDiv.offsetHeight) / 2 + parentTop;
        break;
      case "top":
      case "topLeft":
      case "topRight":
        top = parentTop - this.modalDiv.offsetHeight;
        left = placement === "topRight" ? parentCoords.width - this.wrapperDiv.offsetWidth : parentLeft;
        if (placement === "top") {
          left += (parentCoords.width - this.wrapperDiv.offsetWidth) / 2;
        }
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        top = parentTop + parentCoords.height;
        left = placement === "bottomRight" ? parentRight - this.wrapperDiv.offsetWidth : parentLeft;
        if (placement === "bottom") {
          left += (parentCoords.width - this.wrapperDiv.offsetWidth) / 2;
        }
        break;
      case "rightTop":
        top = parentTop - this.modalDiv.offsetHeight;
        left = parentRight;
        break;
      case "right":
        top = parentTop + parentCoords.height / 2 - this.modalDiv.offsetHeight / 2;
        left = parentRight;
        break;
      case "left":
        top = parentTop + parentCoords.height / 2 - this.modalDiv.offsetHeight / 2;
        left = parentLeft - this.modalDiv.offsetWidth;
        break;
    }
    left = constrainToViewport(left, "width");
    top = constrainToViewport(top, "height");
    if (this.isChildFixed) {
      if (["bottomRight", "left"].indexOf(placement) === -1) {
        left = Math.max(left, parentCoords.left);
      }
      if (placement !== "left") {
        top = Math.max(top, parentCoords.top);
      }
    }
    return { top, left };
  }
  _handleOnShow(event) {
    if (this.popupPlacement && this.enabled)
      this.positionAt(this.popupPlacement);
    if (this.enabled && this._onOpen) {
      event.preventDefault();
      this._onOpen(this);
    }
  }
  handleModalMouseDown(event) {
    this.insideClick = true;
    this.setInsideClick(event);
  }
  handleModalMouseUp(event) {
    if (!this.closeOnBackdropClick && !this.showBackdrop) {
      this.setInsideClick(event);
    }
    if (!this.insideClick)
      this.visible = false;
  }
  setInsideClick(event) {
    const target = event.target;
    if (this.closeOnBackdropClick) {
      this.insideClick = this.showBackdrop ? target !== this.wrapperDiv : this.modalDiv.contains(target);
    } else if (!this.showBackdrop) {
      let parent = this._parent || this.linkTo || this.parentElement;
      if (parent instanceof Range) {
        const commonAncestor = parent.commonAncestorContainer;
        const wrapNode = (commonAncestor == null ? void 0 : commonAncestor.nodeType) === 3 ? commonAncestor.parentElement : commonAncestor;
        if (wrapNode)
          parent = wrapNode;
      }
      this.insideClick = this.modalDiv.contains(target) || (parent == null ? void 0 : parent.contains(target));
    }
  }
  updateModal(name, value) {
    if (!isNaN(Number(value)))
      this.modalDiv.style[name] = value + "px";
    else
      this.modalDiv.style[name] = value;
    this.style[name] = "";
  }
  refresh() {
    super.refresh(true);
    if (this.visible && this.popupPlacement) {
      this.positionAt(this.popupPlacement);
    }
  }
  get background() {
    return this._background;
  }
  set background(value) {
    if (!this._background) {
      this._background = new Background(this.modalDiv, value);
    } else {
      this._background.setBackgroundStyle(value);
    }
  }
  get width() {
    return !isNaN(this._width) ? this._width : this.offsetWidth;
  }
  set width(value) {
    this._width = value;
    this.updateModal("width", value);
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this.updateModal("height", value);
  }
  get border() {
    return this._border;
  }
  set border(value) {
    this._border = new Border(this.showBackdrop ? this.modalDiv : this.wrapperDiv, value);
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (!this._padding)
      this._padding = new SpaceValue(this.modalDiv, value, "padding");
    else
      this._padding.update(value);
  }
  get boxShadow() {
    return (this.showBackdrop ? this.modalDiv : this.wrapperDiv).style.boxShadow;
  }
  set boxShadow(value) {
    (this.showBackdrop ? this.modalDiv : this.wrapperDiv).style.boxShadow = value;
  }
  get overflow() {
    if (!this._overflow) {
      this._overflow = new Overflow(this.showBackdrop ? this.modalDiv : this.wrapperDiv);
    }
    return this._overflow;
  }
  set overflow(value) {
    if (!this._overflow) {
      this._overflow = new Overflow(this.showBackdrop ? this.modalDiv : this.wrapperDiv, value);
    } else {
      this._overflow.setOverflowStyle(value);
    }
  }
  removeTargetStyle(target, propertyName) {
    let style2 = this.propertyClassMap[propertyName];
    if (style2)
      target.classList.remove(style2);
  }
  setTargetStyle(target, propertyName, value) {
    this.removeTargetStyle(target, propertyName);
    if (value) {
      this.propertyClassMap[propertyName] = value;
      target.classList.add(value);
    }
  }
  init() {
    var _a;
    if (!this.wrapperDiv) {
      if ((_a = this.options) == null ? void 0 : _a.onClose)
        this.onClose = this.options.onClose;
      this.popupPlacement = this.getAttribute("popupPlacement", true, DEFAULT_VALUES6.popupPlacement);
      this.closeOnBackdropClick = this.getAttribute("closeOnBackdropClick", true, DEFAULT_VALUES6.closeOnBackdropClick);
      this.wrapperDiv = this.createElement("div", this);
      this.wrapperDiv.classList.add("modal-wrapper");
      this.showBackdrop = this.getAttribute("showBackdrop", true, DEFAULT_VALUES6.showBackdrop);
      this.modalDiv = this.createElement("div", this.wrapperDiv);
      this.titleSpan = this.createElement("div", this.modalDiv);
      this.titleSpan.classList.add(titleStyle, "i-modal_header");
      this.createElement("span", this.titleSpan);
      this.title = this.getAttribute("title", true);
      const closeIconAttr = this.getAttribute("closeIcon", true);
      if (closeIconAttr) {
        closeIconAttr.height = closeIconAttr.height || "16px";
        closeIconAttr.width = closeIconAttr.width || "16px";
        closeIconAttr.fill = closeIconAttr.fill || Theme12.colors.primary.main;
        this.closeIcon = new Icon(void 0, closeIconAttr);
      }
      this.bodyDiv = this.createElement("div", this.modalDiv);
      this.bodyDiv.classList.add("i-modal_body");
      while (this.childNodes.length > 1) {
        this.bodyDiv.appendChild(this.childNodes[0]);
      }
      this.overlayDiv = this.createElement("div", this);
      this.prepend(this.overlayDiv);
      const overlayStyle = getOverlayStyle();
      this.overlayDiv.classList.add(overlayStyle);
      this.overlayDiv.classList.add("modal-overlay");
      this.modalDiv.classList.add(modalStyle);
      this.modalDiv.classList.add("modal");
      this.addEventListener("show", this._handleOnShow.bind(this));
      window.addEventListener("keydown", (event) => {
        if (!this.visible)
          return;
        if (event.key === "Escape") {
          this.visible = false;
        }
      });
      const isChildFixed = this.getAttribute("isChildFixed", true);
      if (isChildFixed)
        this.isChildFixed = isChildFixed;
      const closeOnScrollChildFixed = this.getAttribute("closeOnScrollChildFixed", true);
      this.closeOnScrollChildFixed = closeOnScrollChildFixed;
      const itemAttr = this.getAttribute("item", true);
      if (itemAttr)
        this.item = itemAttr;
      super.init();
      const maxWidth = this.getAttribute("maxWidth", true);
      if (maxWidth !== void 0)
        this.updateModal("maxWidth", this.maxWidth);
      const minHeight = this.getAttribute("minHeight", true);
      if (minHeight !== void 0)
        this.updateModal("minHeight", this.minHeight);
      const minWidth = this.getAttribute("minWidth", true);
      if (minWidth !== void 0)
        this.updateModal("minWidth", this.minWidth);
      const height = this.getAttribute("height", true);
      if (height !== void 0)
        this.updateModal("height", this.height);
      const maxHeight = this.getAttribute("maxHeight", true);
      if (maxHeight !== void 0)
        this.updateModal("maxHeight", this.maxHeight);
      let border = this.getAttribute("border", true);
      if (border) {
        this._border = new Border(this.showBackdrop ? this.modalDiv : this.wrapperDiv, border);
        this.style.border = "none";
      }
      let padding = this.getAttribute("padding", true);
      if (padding) {
        this._padding = new SpaceValue(this.modalDiv, padding, "padding");
      }
      let boxShadow = this.getAttribute("boxShadow", true);
      if (boxShadow)
        this.boxShadow = boxShadow;
      let overflow = this.getAttribute("overflow", true);
      if (overflow) {
        this._overflow = new Overflow(this.showBackdrop ? this.modalDiv : this.wrapperDiv, overflow);
        if (overflow === "hidden")
          this.bodyDiv.classList.add(getBodyStyle);
      }
      this.mediaQueries = this.getAttribute("mediaQueries", true, []);
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Modal = __decorateClass([
  customElements2("i-modal", {
    icon: "stop",
    group: GroupType.BASIC,
    className: "Modal",
    props: {
      title: { type: "string" },
      showBackdrop: {
        type: "boolean",
        default: DEFAULT_VALUES6.showBackdrop
      },
      closeIcon: {
        type: "object",
        default: {}
      },
      popupPlacement: {
        type: "string",
        default: DEFAULT_VALUES6.popupPlacement
      },
      closeOnBackdropClick: {
        type: "boolean",
        default: DEFAULT_VALUES6.closeOnBackdropClick
      },
      isChildFixed: {
        type: "boolean",
        default: DEFAULT_VALUES6.isChildFixed
      },
      closeOnScrollChildFixed: {
        type: "boolean",
        default: DEFAULT_VALUES6.closeOnScrollChildFixed
      }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        title: {
          type: "string"
        },
        showBackdrop: {
          type: "boolean",
          default: DEFAULT_VALUES6.showBackdrop
        },
        closeIcon: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            fill: {
              type: "string",
              format: "color"
            },
            width: {
              type: "number"
            },
            height: {
              type: "number"
            },
            image: {
              type: "object",
              properties: {
                url: {
                  type: "string"
                }
              }
            }
          }
        },
        popupPlacement: {
          type: "string",
          enum: ["center", "bottom", "bottomLeft", "bottomRight", "top", "topLeft", "topRight", "rightTop", "left", "right"],
          default: DEFAULT_VALUES6.popupPlacement
        },
        closeOnBackdropClick: {
          type: "boolean",
          default: DEFAULT_VALUES6.closeOnBackdropClick
        },
        isChildFixed: {
          type: "boolean",
          default: DEFAULT_VALUES6.isChildFixed
        },
        closeOnScrollChildFixed: {
          type: "boolean",
          default: DEFAULT_VALUES6.closeOnScrollChildFixed
        }
      }
    }
  })
], Modal);

// packages/progress/src/style/progress.css.ts
var Theme13 = theme_exports.ThemeVars;
var loading = keyframes({
  "0%": {
    left: "-100%"
  },
  "100%": {
    left: "100%"
  }
});
cssRule("i-progress", {
  display: "block",
  maxWidth: "100%",
  verticalAlign: "baseline",
  fontFamily: Theme13.typography.fontFamily,
  fontSize: Theme13.typography.fontSize,
  color: Theme13.text.primary,
  position: "relative",
  $nest: {
    "&.is-loading .i-progress_overlay": {
      transform: "translateZ(0)",
      animation: `${loading} 3s infinite`
    },
    ".i-progress": {
      boxSizing: "border-box",
      margin: 0,
      minWidth: 0,
      width: "100%",
      display: "block"
    },
    ".i-progress--grid": {
      display: "grid",
      gap: 20,
      gridTemplateColumns: "auto 1fr 80px",
      alignItems: "center"
    },
    ".i-progress--exception": {
      $nest: {
        "> .i-progress_wrapbar > .i-progress_overlay": {
          backgroundColor: Theme13.colors.error.light
        },
        "> .i-progress_wrapbar > .i-progress_bar .i-progress_bar-item": {
          backgroundColor: Theme13.colors.error.light
        },
        ".i-progress_item.i-progress_item-start": {
          borderColor: Theme13.colors.error.light
        },
        ".i-progress_item.i-progress_item-end": {}
      }
    },
    ".i-progress--success": {
      $nest: {
        "> .i-progress_wrapbar > .i-progress_overlay": {
          backgroundColor: Theme13.colors.success.light
        },
        "> .i-progress_wrapbar > .i-progress_bar .i-progress_bar-item": {
          backgroundColor: Theme13.colors.success.light
        },
        ".i-progress_item.i-progress_item-start": {
          borderColor: Theme13.colors.success.light
        },
        ".i-progress_item.i-progress_item-end": {}
      }
    },
    ".i-progress--warning": {
      $nest: {
        "> .i-progress_wrapbar > .i-progress_overlay": {
          backgroundColor: Theme13.colors.warning.light
        },
        "> .i-progress_wrapbar > .i-progress_bar .i-progress_bar-item": {
          backgroundColor: Theme13.colors.warning.light
        },
        ".i-progress_item.i-progress_item-start": {
          borderColor: Theme13.colors.warning.light
        },
        ".i-progress_item.i-progress_item-end": {}
      }
    },
    ".i-progress--active": {
      $nest: {
        "> .i-progress_wrapbar > .i-progress_overlay": {
          backgroundColor: Theme13.colors.primary.light
        },
        "> .i-progress_wrapbar > .i-progress_bar .i-progress_bar-item": {
          backgroundColor: Theme13.colors.primary.light
        },
        ".i-progress_item.i-progress_item-start": {
          backgroundColor: "transparent",
          borderColor: Theme13.colors.primary.light
        }
      }
    },
    ".i-progress_wrapbar": {
      position: "relative",
      overflow: "hidden",
      boxSizing: "border-box",
      minWidth: 0,
      order: 2,
      minHeight: 2,
      borderRadius: "inherit",
      backgroundColor: Theme13.divider,
      $nest: {
        "&.has-steps": {
          backgroundColor: "transparent"
        },
        ".i-progress_bar": {
          boxSizing: "border-box",
          width: "100%",
          height: "100%",
          position: "absolute",
          display: "flex",
          alignItems: "center",
          gap: "1px",
          $nest: {
            "&.has-bg": {
              backgroundColor: Theme13.divider
            },
            ".i-progress_bar-item": {
              flex: "auto",
              backgroundColor: Theme13.divider
            }
          }
        },
        ".i-progress_overlay": {
          position: "absolute",
          minWidth: 0,
          height: "100%"
        }
      }
    },
    ".i-progress_item": {
      boxSizing: "border-box",
      margin: "0px -1.2px 0px 0px",
      minWidth: 0,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      position: "relative",
      $nest: {
        "&.i-progress_item-start": {
          borderWidth: 1,
          borderStyle: "solid",
          borderImage: "initial",
          borderRadius: 14,
          borderColor: Theme13.divider,
          padding: "4px 12px",
          order: 1
        },
        "&.i-progress_item-end": {
          boxSizing: "border-box",
          margin: 0,
          minWidth: 0,
          display: "flex",
          flexDirection: "column",
          cursor: "default",
          position: "relative",
          order: 3,
          alignItems: "flex-start"
        }
      }
    },
    "&.i-progress--stretch": {
      $nest: {
        "@media only screen and (max-width: 768px)": {
          $nest: {
            ".i-progress_wrapbar": {
              display: "none !important"
            },
            ".i-progress_item-end": {
              display: "none !important"
            },
            ".is-mobile": {
              display: "inline-block"
            },
            ".i-progress--grid": {
              gridTemplateColumns: "auto",
              justifyContent: "center"
            }
          }
        }
      }
    },
    ".i-progress--circle ~ .i-progress_text": {
      position: "absolute",
      top: "50%",
      left: 0,
      width: "100%",
      textAlign: "center",
      transform: "translateY(-50%)"
    },
    ".i-progress--line ~ .i-progress_text": {
      display: "inline-block",
      position: "absolute",
      left: "50%",
      transform: "translateX(-50%)"
    },
    ".i-progress--line": {
      borderRadius: "inherit"
    }
  }
});

// packages/progress/src/progress.ts
var Theme14 = theme_exports.ThemeVars;
var defaultVals = {
  percent: 0,
  height: 20,
  loading: false,
  steps: 1,
  type: "line",
  strokeWidth: 2
};
var Progress = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      ...defaultVals
    });
    if (options == null ? void 0 : options.onRenderStart)
      this.onRenderStart = options.onRenderStart;
    if (options == null ? void 0 : options.onRenderEnd)
      this.onRenderEnd = options.onRenderEnd;
  }
  get percent() {
    return this._percent;
  }
  set percent(value) {
    this._percent = +value < 0 ? 0 : +value > 100 ? 100 : +value;
    const overlayElm = this.querySelector(".i-progress_overlay");
    if (overlayElm) {
      overlayElm.style.width = `${this._percent}%`;
      overlayElm.style.backgroundColor = this.stroke;
    }
    if (this._percent > 0 && this._percent < 100)
      this._wrapperElm.classList.add("i-progress--active");
    else if (this._percent === 100)
      this._wrapperElm.classList.add("i-progress--success");
    if (typeof this.format === "function") {
      if (!this._textElm) {
        this._textElm = this.createElement("span", this);
        this._textElm.classList.add("i-progress_text");
        this._textElm.style.fontSize = this.progressTextSize + "px";
        this._textElm.style.color = this.strokeColor;
      }
      this._textElm.innerHTML = this.format(this._percent);
    }
    if (this.type === "circle") {
      this.updateCircleInner();
    }
  }
  get strokeColor() {
    return this._strokeColor || Theme14.colors.primary.main;
  }
  set strokeColor(value) {
    this._strokeColor = value;
    if (this.type === "circle") {
      this.renderCircleInner();
    } else if (this.type === "line") {
      const overlayElm = this.querySelector(".i-progress_overlay");
      if (overlayElm)
        overlayElm.style.backgroundColor = this.stroke;
    }
  }
  get loading() {
    return this._loading;
  }
  set loading(value) {
    this._loading = value;
    if (value)
      this.classList.add("is-loading");
    else
      this.classList.remove("is-loading");
  }
  get steps() {
    return this._steps;
  }
  set steps(value) {
    this._steps = +value;
    if (this.type === "circle")
      return;
    const wrapbarElm = this.querySelector(".i-progress_bar");
    const overlayElm = this.querySelector(".i-progress_overlay");
    const wrapperElm = this.querySelector(".i-progress_wrapbar");
    if (wrapperElm)
      wrapperElm.classList.toggle("has-steps", this._steps > 1);
    wrapbarElm.innerHTML = "";
    if (this._steps > 1) {
      const unitStep = 100 / this._steps;
      const percentStep = Math.ceil(this.percent / unitStep);
      const remainder = this.percent % unitStep;
      const initialH = Math.max(1, Math.floor(this.strokeWidth / 2));
      for (let i = 0; i < this._steps; i++) {
        const barItem = this.createElement("div");
        barItem.style.width = unitStep + "%";
        barItem.style.height = `${i + initialH}px`;
        if (i === percentStep - 1 && remainder !== 0) {
          const childElm = this.createElement("div");
          childElm.classList.add("i-progress_bar-item");
          childElm.style.width = remainder * 100 / unitStep + "%";
          childElm.style.height = `${i + initialH}px`;
          childElm.style.backgroundColor = this.stroke;
          barItem.appendChild(childElm);
        } else if (i < percentStep) {
          barItem.classList.add("i-progress_bar-item");
          barItem.style.backgroundColor = this.stroke;
        }
        wrapbarElm.appendChild(barItem);
      }
      wrapbarElm.classList.remove("has-bg");
      overlayElm && (overlayElm.style.display = "none");
    } else {
      wrapbarElm.classList.add("has-bg");
      overlayElm && (overlayElm.style.display = "block");
    }
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
    if (value === "circle") {
      this.renderCircle();
    } else {
      this.renderLine();
    }
  }
  get strokeWidth() {
    return this._strokeWidth;
  }
  set strokeWidth(value) {
    this._strokeWidth = value || 2;
    const overlayElm = this.querySelector(".i-progress_wrapbar");
    if (overlayElm)
      overlayElm.style.height = `${this._strokeWidth}px`;
  }
  get font() {
    return {
      color: this._textElm.style.color,
      name: this._textElm.style.fontFamily,
      size: this._textElm.style.fontSize,
      bold: this._textElm.style.fontStyle.indexOf("bold") >= 0,
      style: this._textElm.style.fontStyle,
      transform: this._textElm.style.textTransform,
      weight: this._textElm.style.fontWeight,
      shadow: this._textElm.style.textShadow
    };
  }
  set font(value) {
    if (this._textElm) {
      this._textElm.style.color = value.color || "";
      this._textElm.style.fontSize = value.size || "";
      this._textElm.style.fontWeight = value.bold ? "bold" : "";
      this._textElm.style.fontFamily = value.name || "";
      this._textElm.style.fontStyle = value.style || "";
      this._textElm.style.textTransform = value.transform || "none";
      this._textElm.style.fontWeight = value.bold ? "bold" : `${value.weight}` || "";
      this._textElm.style.textShadow = value.shadow || "none";
    }
  }
  get relativeStrokeWidth() {
    return (this.strokeWidth / +this.width * 100).toFixed(1);
  }
  get radius() {
    if (this.type === "circle") {
      const value = 50 - parseFloat(this.relativeStrokeWidth) / 2;
      return parseInt(value.toFixed(1), 10);
    } else {
      return 0;
    }
  }
  get trackPath() {
    const radius = this.radius;
    return `
          M 50 50
          m 0 -${radius}
          a ${radius} ${radius} 0 1 1 0 ${radius * 2}
          a ${radius} ${radius} 0 1 1 0 -${radius * 2}
          `;
  }
  get perimeter() {
    return 2 * Math.PI * this.radius;
  }
  get rate() {
    return 1;
  }
  get strokeDashoffset() {
    const offset = -1 * this.perimeter * (1 - this.rate) / 2;
    return `${offset}px`;
  }
  get trailPathStyle() {
    const strokeDasharray = `${this.perimeter * this.rate}px, ${this.perimeter}px`;
    const strokeDashoffset = this.strokeDashoffset;
    return `stroke-dasharray: ${strokeDasharray}; stroke-dashoffset: ${strokeDashoffset};`;
  }
  get circlePathStyle() {
    const strokeDasharray = `${this.perimeter * this.rate * (this.percent / 100)}px, ${this.perimeter}px`;
    const strokeDashoffset = this.strokeDashoffset;
    const transition = "stroke-dasharray 0.6s ease 0s, stroke 0.6s ease";
    return `stroke-dasharray: ${strokeDasharray}; stroke-dashoffset: ${strokeDashoffset}; transition: ${transition};`;
  }
  get stroke() {
    let ret = this.strokeColor;
    if (this.percent === 100)
      ret = Theme14.colors.success.main;
    return ret;
  }
  get trackColor() {
    return Theme14.divider;
  }
  get progressTextSize() {
    return this.type === "line" ? 12 + this.strokeWidth * 0.4 : +this.width * 0.111111 + 2;
  }
  renderLine() {
    this.height = "auto";
    this._wrapperElm.innerHTML = "";
    this._wrapperElm.classList.add("i-progress--line");
    this._barElm = this.createElement("div", this._wrapperElm);
    this._barElm.classList.add("i-progress_wrapbar");
    this._barElm.innerHTML = `<div class="i-progress_bar"></div><div class="i-progress_overlay" style="background-color:${this.stroke}"></div>`;
  }
  renderCircle() {
    this._wrapperElm.classList.add("i-progress--circle");
    if (this.width)
      this.height = this.width;
    this.renderCircleInner();
  }
  renderCircleInner() {
    const templateHtml = `<svg viewBox="0 0 100 100">
            <path class="i-progress-circle__track"
            d="${this.trackPath}"
            stroke="${this.trackColor}"
            stroke-width="${this.relativeStrokeWidth}"
            fill="none"
            style="${this.trailPathStyle}"></path>
            <path
            class="i-progress-circle__path"
            d="${this.trackPath}"
            stroke="${this.stroke}"
            fill="none"
            stroke-linecap="round"
            stroke-width="${this.percent ? this.relativeStrokeWidth : 0}"
            style="${this.circlePathStyle}"></path>
        </svg>`;
    this._wrapperElm.innerHTML = "";
    this._wrapperElm.innerHTML = templateHtml;
  }
  updateCircleInner() {
    const svgPath = this._wrapperElm.querySelector(".i-progress-circle__path");
    if (svgPath) {
      svgPath.style.strokeDasharray = `${this.perimeter * this.rate * (this.percent / 100)}px, ${this.perimeter}px`;
      svgPath.setAttribute("stroke-width", `${this.percent ? this.relativeStrokeWidth : 0}`);
    }
  }
  init() {
    var _a, _b;
    if (!this.initialized) {
      super.init();
      if ((_a = this.options) == null ? void 0 : _a.onRenderStart)
        this.onRenderStart = this.options.onRenderStart;
      if ((_b = this.options) == null ? void 0 : _b.onRenderEnd)
        this.onRenderEnd = this.options.onRenderEnd;
      this.loading = this.getAttribute("loading", true);
      this._strokeColor = this.getAttribute("strokeColor", true);
      this._wrapperElm = this.createElement("div", this);
      this._wrapperElm.classList.add("i-progress");
      this.type = this.getAttribute("type", true);
      this.percent = this.getAttribute("percent", true);
      this.strokeWidth = this.getAttribute("strokeWidth", true);
      if (this.type === "line") {
        this.steps = this.getAttribute("steps", true);
        if (typeof this.onRenderStart === "function") {
          this._wrapperElm.classList.add("i-progress--grid");
          this._startElm = this.createElement("div", this._wrapperElm);
          this._startElm.classList.add("i-progress_item", "i-progress_item-start");
          this.onRenderStart(this._startElm);
        }
        if (typeof this.onRenderEnd === "function") {
          this._wrapperElm.classList.add("i-progress--grid");
          this._endElm = this.createElement("div", this._wrapperElm);
          this._endElm.classList.add("i-progress_item", "i-progress_item-end");
          this.onRenderEnd(this._endElm);
        }
      }
      if (this.type === "circle")
        this.renderCircleInner();
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Progress = __decorateClass([
  customElements2("i-progress", {
    icon: "spinner",
    group: GroupType.BASIC,
    className: "Progress",
    props: {
      percent: {
        type: "number",
        default: defaultVals.percent
      },
      strokeWidth: {
        type: "number",
        default: defaultVals.strokeWidth
      },
      strokeColor: {
        type: "string",
        default: ""
      },
      loading: {
        type: "boolean",
        default: defaultVals.loading
      },
      steps: {
        type: "number",
        default: defaultVals.steps
      },
      type: {
        type: "string",
        default: defaultVals.type
      }
    },
    events: {
      format: [
        { name: "percent", type: "number" }
      ],
      onRenderStart: [
        { name: "target", type: "Progress", isControl: true }
      ],
      onRenderEnd: [
        { name: "target", type: "Progress", isControl: true }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: ["line", "circle"],
          default: defaultVals.type
        },
        percent: {
          type: "number",
          default: defaultVals.percent
        },
        strokeWidth: {
          type: "number",
          default: defaultVals.strokeWidth
        },
        strokeColor: {
          type: "string",
          format: "color"
        },
        loading: {
          type: "boolean",
          default: defaultVals.loading
        },
        steps: {
          type: "number",
          default: defaultVals.steps
        }
      }
    }
  })
], Progress);

// packages/upload/src/style/upload-modal.css.ts
var Theme15 = theme_exports.ThemeVars;
cssRule("i-upload-modal", {
  $nest: {
    "i-modal": {
      position: "fixed!important",
      zIndex: 1e3
    },
    ".file-uploader-dropzone": {
      $nest: {
        "i-upload": {
          position: "absolute",
          top: 0,
          opacity: 0,
          minHeight: "auto",
          minWidth: "auto",
          margin: 0,
          zIndex: 1,
          $nest: {
            ".i-upload_preview-img": {
              display: "none!important"
            }
          }
        },
        ".filelist": {
          $nest: {
            "@media screen and (max-width: 767px)": {
              flex: "1",
              overflowY: "auto"
            },
            ".file": {
              border: `1px solid ${Theme15.divider}`,
              borderRadius: "0.5rem",
              $nest: {
                "&:hover": {
                  border: `1px solid ${Theme15.colors.primary.main}`
                }
              }
            }
          }
        }
      }
    }
  }
});

// packages/upload/src/upload-modal.ts
var Theme16 = theme_exports.ThemeVars;
var FILE_STATUS;
(function(FILE_STATUS2) {
  FILE_STATUS2[FILE_STATUS2["LISTED"] = 0] = "LISTED";
  FILE_STATUS2[FILE_STATUS2["SUCCESS"] = 1] = "SUCCESS";
  FILE_STATUS2[FILE_STATUS2["FAILED"] = 2] = "FAILED";
  FILE_STATUS2[FILE_STATUS2["UPLOADING"] = 3] = "UPLOADING";
})(FILE_STATUS || (FILE_STATUS = {}));
var ITEMS_PER_PAGE = 5;
var UploadModal = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this.isForcedCancelled = false;
    this.currentPage = 1;
    this.currentFilterStatus = 0;
    this.files = [];
    this.fileListData = [];
  }
  get rootCid() {
    return this._rootCid;
  }
  set rootCid(value) {
    console.log("set rootCid: ", value);
    this._rootCid = value;
  }
  get parentDir() {
    return this._parentDir;
  }
  set parentDir(value) {
    console.log("set parentDir: ", value);
    this._parentDir = value;
  }
  async show() {
    await this.init();
    if (!this.parentElement)
      document.body.appendChild(this);
    this.updateBtnCaption();
    this._uploadModalElm.visible = true;
    this._uploadModalElm.refresh();
  }
  updateUI() {
  }
  hide() {
    this._uploadModalElm.visible = false;
    this.reset();
  }
  onBeforeDrop(target) {
    console.log("onBeforeDrop: ", target);
    this._fileUploader.enabled = false;
    this._fileIcon.url = `${LibPath}assets/img/loading-icon.svg`;
    this._dragLabelElm.caption = "Processing your files...";
  }
  onBeforeUpload(target, file) {
    return new Promise((resolve, reject) => {
      resolve(true);
    });
  }
  filteredFileListData() {
    return this.currentFilterStatus === 0 ? this.fileListData : this.fileListData.filter((i) => i.status === this.currentFilterStatus);
  }
  numPages() {
    return Math.ceil(this.filteredFileListData().length / ITEMS_PER_PAGE);
  }
  setCurrentPage(page) {
    if (page >= 1 && page <= this.numPages())
      this.currentPage = page;
    this.renderFileList();
    this.renderPagination();
  }
  get isSmallWidth() {
    return !!window.matchMedia("(max-width: 767px)").matches;
  }
  async renderFilterBar() {
    this._filterBarElm.clearInnerHTML();
    const isListed = this.currentFilterStatus === 0;
    const listedBtnElm = new Button(this._filterBarElm, {
      caption: `All (${this.fileListData.length})`,
      boxShadow: "none",
      background: { color: "transparent" },
      font: { color: isListed ? Theme16.colors.primary.dark : Theme16.text.secondary, size: "0.875rem", weight: isListed ? "bold" : "normal" }
    });
    listedBtnElm.onClick = () => this.onChangeCurrentFilterStatus(0);
    const isSuccess = this.currentFilterStatus === 1;
    const successBtnElm = new Button(this._filterBarElm, {
      caption: `Success (${this.fileListData.filter((i) => i.status === 1).length})`,
      boxShadow: "none",
      background: { color: "transparent" },
      font: { color: isSuccess ? Theme16.colors.primary.dark : Theme16.text.secondary, size: "0.875rem", weight: isSuccess ? "bold" : "normal" }
    });
    successBtnElm.onClick = () => this.onChangeCurrentFilterStatus(1);
    const isFailed = this.currentFilterStatus === 2;
    const failedBtnElm = new Button(this._filterBarElm, {
      caption: `Fail (${this.fileListData.filter((i) => i.status === 2).length})`,
      boxShadow: "none",
      background: { color: "transparent" },
      font: { color: isFailed ? Theme16.colors.primary.dark : Theme16.text.secondary, size: "0.875rem", weight: isFailed ? "bold" : "normal" }
    });
    failedBtnElm.onClick = () => this.onChangeCurrentFilterStatus(2);
    const isUploading = this.currentFilterStatus === 3;
    const uploadingBtnElm = new Button(this._filterBarElm, {
      caption: `Uploading (${this.fileListData.filter((i) => i.status === 3).length})`,
      boxShadow: "none",
      background: { color: "transparent" },
      font: { color: isUploading ? Theme16.colors.primary.dark : Theme16.text.secondary, size: "0.875rem", weight: isUploading ? "bold" : "normal" }
    });
    uploadingBtnElm.onClick = () => this.onChangeCurrentFilterStatus(3);
    this._filterActionsElm.clearInnerHTML();
    if (this.currentFilterStatus === 3) {
      const cancelBtnElm = new Button(this._filterActionsElm, {
        caption: "Cancel",
        boxShadow: "none",
        background: { color: Theme16.colors.primary.light },
        font: { color: Theme16.colors.primary.contrastText, size: "0.875rem" },
        padding: { top: "0.313rem", left: "0.675rem", right: "0.675rem", bottom: "0.313rem" }
      });
      cancelBtnElm.onClick = () => this.onCancel();
    } else {
      const clearBtnElm = new Button(this._filterActionsElm, {
        caption: "Clear",
        boxShadow: "none",
        background: { color: Theme16.colors.primary.light },
        font: { color: Theme16.colors.primary.contrastText, size: "0.875rem" },
        padding: { top: "0.313rem", left: "0.675rem", right: "0.675rem", bottom: "0.313rem" }
      });
      clearBtnElm.onClick = () => this.onClear();
    }
  }
  async renderFileList() {
    this._fileListElm.clearInnerHTML();
    const filteredFileListData = this.filteredFileListData();
    const paginatedFilteredFileListData = this.isSmallWidth ? this.fileListData : [...filteredFileListData].slice((this.currentPage - 1) * ITEMS_PER_PAGE, ITEMS_PER_PAGE * this.currentPage);
    for (let i = 0; i < paginatedFilteredFileListData.length; i++) {
      const fileData = paginatedFilteredFileListData[i];
      const fileElm = new HStack(this._fileListElm, {
        class: `file file-${i} status-${fileData.status}`,
        overflow: "hidden",
        gap: "1rem",
        padding: {
          left: "0.75rem",
          right: "0.75rem",
          top: "0.5rem",
          bottom: "0.5rem"
        },
        stack: { shrink: "0", grow: "1" }
      });
      const fileIcon = new Icon(fileElm, {
        border: { radius: "0.5rem", width: "1px", color: Theme16.divider, style: "solid" },
        padding: {
          left: "0.35rem",
          right: "0.35rem",
          top: "0.35rem",
          bottom: "0.35rem"
        },
        name: "file",
        width: "1.75rem",
        height: "1.75rem",
        fill: Theme16.colors.primary.main,
        stack: { shrink: "0" }
      });
      const wrapper = new VStack(fileElm, {
        gap: "0.25rem",
        stack: { shrink: "1", grow: "1" },
        maxWidth: "100%",
        overflow: "hidden"
      });
      const row1 = new HStack(wrapper, {
        gap: "1rem",
        horizontalAlignment: "space-between",
        verticalAlignment: "center"
      });
      const fileNameElm = new Label(row1, {
        caption: fileData.file.path || fileData.file.name,
        font: { weight: 600, size: "0.875rem" },
        maxWidth: "100%",
        textOverflow: "ellipsis"
      });
      const removeBtnElm = new Icon(row1, {
        name: "times",
        width: "0.875rem",
        height: "0.875rem",
        fill: Theme16.text.primary,
        cursor: "pointer"
      });
      removeBtnElm.onClick = () => this.onRemoveFile(i);
      const row2 = new HStack(wrapper, {
        gap: "0.5rem",
        verticalAlignment: "center"
      });
      const sizeElm = new Label(row2, {
        caption: this.formatBytes(fileData.file.size || 0),
        font: { size: "0.75rem" },
        maxWidth: "100%",
        textOverflow: "ellipsis",
        opacity: 0.75
      });
      const statusElm = this.getStatus(fileData.status, row2);
      const row3 = new HStack(wrapper, {
        gap: "0.75rem",
        verticalAlignment: "center"
      });
      const progressElm = new Progress(row3, {
        percent: fileData.percentage,
        stack: { grow: "1", shrink: "1", basis: "60%" },
        height: "auto",
        border: { radius: "0.5rem" },
        strokeWidth: 10
      });
      const percentageElm = new Label(row3, {
        caption: `${fileData.percentage}%`,
        stack: { grow: "1", shrink: "0" },
        font: { size: "0.75rem" }
      });
    }
  }
  formatBytes(bytes, decimals = 2) {
    if (bytes === 0)
      return "0 Bytes";
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i];
  }
  getStatus(status, parent) {
    const iconEl = new Icon(parent, {
      name: "times",
      width: "0.875rem",
      height: "0.875rem",
      padding: { top: "0.125rem", bottom: "0.125rem", left: "0.125rem", right: "0.125rem" },
      border: { radius: "50%" },
      background: { color: Theme16.text.primary },
      fill: Theme16.colors.primary.contrastText,
      visible: false
    });
    const statusElm = new Label(parent, {
      caption: ""
    });
    switch (status) {
      case 1:
        iconEl.name = "check";
        iconEl.background.color = Theme16.colors.success.main;
        iconEl.visible = true;
        statusElm.caption = "Completed";
        break;
      case 2:
        iconEl.name = "times";
        iconEl.background.color = Theme16.colors.error.main;
        iconEl.visible = true;
        statusElm.caption = "Failed";
      case 3:
        statusElm.caption = "Uploading";
    }
    return statusElm;
  }
  getPagination(currentIndex, totalPages) {
    let current = currentIndex, last = totalPages, delta = 2, left = current - delta, right = current + delta + 1, range = [], rangeWithDots = [], l;
    for (let i = 1; i <= last; i++) {
      if (i == 1 || i == last || i >= left && i < right) {
        range.push(i);
      }
    }
    for (let i of range) {
      if (l) {
        if (i - l === 2) {
          rangeWithDots.push(l + 1);
        } else if (i - l !== 1) {
          rangeWithDots.push("...");
        }
      }
      rangeWithDots.push(i);
      l = i;
    }
    return rangeWithDots;
  }
  async renderPagination() {
    const numPages = this.numPages();
    const rangeWithDots = this.getPagination(this.currentPage, numPages);
    if (numPages >= 1) {
      if (this.currentPage > numPages) {
        this.setCurrentPage(numPages);
      } else {
        this._paginationElm.clearInnerHTML();
        const prevBtn = new Button(this._paginationElm, {
          icon: { name: "chevron-left", fill: Theme16.colors.primary.dark, width: "0.75rem", height: "0.675rem" },
          width: "1.5rem",
          height: "1.5rem",
          border: { radius: "50%", width: "1px", style: "solid", color: Theme16.colors.primary.dark },
          font: { size: "0.688rem", weight: 700, color: Theme16.colors.primary.dark },
          background: { color: "transparent" },
          boxShadow: "none"
        });
        prevBtn.onClick = () => {
          this.setCurrentPage(this.currentPage - 1);
        };
        for (let i = 0; i < rangeWithDots.length; i++) {
          const isActived = this.currentPage === rangeWithDots[i];
          const pageBtn = new Button(this._paginationElm, {
            caption: rangeWithDots[i].toString(),
            width: "1.5rem",
            height: "1.5rem",
            border: { radius: "50%", width: "1px", style: "solid", color: Theme16.colors.primary.dark },
            font: { size: "0.688rem", weight: 700, color: isActived ? Theme16.colors.primary.contrastText : Theme16.colors.primary.dark },
            background: { color: isActived ? Theme16.colors.primary.dark : "transparent" },
            boxShadow: "none"
          });
          if (rangeWithDots[i] === "...") {
            pageBtn.border.color = "transparent";
          } else {
            pageBtn.onClick = () => {
              this.setCurrentPage(rangeWithDots[i]);
            };
          }
        }
        const nexBtn = new Button(this._paginationElm, {
          icon: { name: "chevron-right", fill: Theme16.colors.primary.dark, width: "0.75rem", height: "0.675rem" },
          width: "1.5rem",
          height: "1.5rem",
          border: { radius: "50%", width: "1px", style: "solid", color: Theme16.colors.primary.dark },
          font: { size: "0.688rem", weight: 700, color: Theme16.colors.primary.dark },
          background: { color: "transparent" },
          boxShadow: "none"
        });
        nexBtn.onClick = () => {
          this.setCurrentPage(this.currentPage + 1);
        };
      }
    } else {
      this._paginationElm.clearInnerHTML();
    }
  }
  onChangeCurrentFilterStatus(status) {
    this.currentFilterStatus = status;
    this.renderFilterBar();
    this.renderPagination();
    this.renderFileList();
  }
  onClear() {
    switch (this.currentFilterStatus) {
      case 0:
        this.fileListData = this.fileListData && this.fileListData.length ? this.fileListData.filter((fileData) => ![
          0,
          1,
          2
        ].includes(fileData.status)) : this.fileListData;
        break;
      case 1:
        this.fileListData = this.fileListData && this.fileListData.length ? this.fileListData.filter((fileData) => ![1].includes(fileData.status)) : this.fileListData;
        break;
      case 2:
        this.fileListData = this.fileListData && this.fileListData.length ? this.fileListData.filter((fileData) => ![2].includes(fileData.status)) : this.fileListData;
        break;
    }
    this.renderFilterBar();
    this.renderFileList();
    this.renderPagination();
  }
  onCancel() {
    this.currentRequest.abort();
    this.isForcedCancelled = true;
  }
  async onChangeFile(source, files) {
    console.log("onChangeFile: ", files);
    return new Promise(async (resolve, reject) => {
      if (!files.length)
        reject();
      this._fileUploader.enabled = true;
      this._fileIcon.url = `${LibPath}assets/img/file-icon.png`;
      this.updateBtnCaption();
      for (let i = 0; i < files.length; i++) {
        this.fileListData.push({ file: files[i], status: 0, percentage: 0 });
        this.files.push(files[i]);
      }
      this.renderFileList();
      this.renderFilterBar();
      this.renderPagination();
      this.toggle(true);
      this._fileUploader.clear();
    });
  }
  updateBtnCaption() {
    this._dragLabelElm.caption = this.isSmallWidth ? "Select Files" : "Drag and drop your files here";
  }
  onRemove(source, file) {
  }
  onRemoveFile(index) {
    this.fileListData.splice(index, 1);
    this.files.splice(index, 1);
    this.renderFileList();
    this.renderFilterBar();
    this.renderPagination();
    if (!this.fileListData.length) {
      this.toggle(false);
    }
  }
  getDirItems(cidItem, result) {
    var _a;
    result = result || [];
    if (cidItem.type == "dir") {
      let items = [];
      if (cidItem.links) {
        for (let i = 0; i < ((_a = cidItem.links) == null ? void 0 : _a.length); i++) {
          let item = cidItem.links[i];
          if (item.type == "dir")
            this.getDirItems(item, result);
          items.push({
            cid: item.cid,
            name: item.name,
            size: item.size,
            type: item.type
          });
        }
      }
      result.push({
        cid: cidItem.cid,
        name: cidItem.name,
        size: cidItem.size,
        type: "dir",
        links: items
      });
    }
    return result;
  }
  async onUpload() {
    return new Promise(async (resolve, reject) => {
      var _a, _b, _c, _d, _e, _f;
      if (!this.fileListData.length)
        reject();
      this._uploadBtnElm.caption = "Uploading files to IPFS...";
      this._uploadBtnElm.enabled = false;
      this.isForcedCancelled = false;
      const cidItems = await hashFiles(this.files);
      console.dir("### IPFS Upload ###");
      console.log("cidItems: ", cidItems);
      let dirItems = this.getDirItems(cidItems);
      console.log("dirItems: ", dirItems);
      if (this.parentDir && this.rootCid) {
        const oldParentDirCID = cidItems.cid;
        dirItems = dirItems.filter((dirItem) => dirItem.cid !== oldParentDirCID);
        const items = [];
        for (let i = 0; i < dirItems.length; i++) {
          let item = dirItems[i];
          items.push({ cid: item });
        }
        for (let i = 0; i < this.fileListData.length; i++) {
          const file = this.fileListData[i];
          const cidItem = (_a = cidItems.links) == null ? void 0 : _a.find((cidItem2) => {
            var _a2;
            return cidItem2.cid === ((_a2 = file.file.cid) == null ? void 0 : _a2.cid);
          });
          if (cidItem)
            items.push({ cid: cidItem, data: file.file });
        }
        try {
          const uploadResult = await application.uploadTo(this.parentDir.cid, items);
          console.log("uploadToResult: ", uploadResult);
          if (uploadResult && uploadResult.data) {
            uploadResult.data.name = this.parentDir.name;
            if (this.parentDir.cid !== this.rootCid) {
              const syncResult = await application.uploadTo(this.rootCid, [
                { cid: uploadResult.data }
              ]);
              console.log("syncResult: ", syncResult);
              if (syncResult && syncResult.data) {
                if (this.onBeforeUploaded)
                  this.onBeforeUploaded(this, syncResult.data);
              }
            } else {
              if (this.onBeforeUploaded)
                this.onBeforeUploaded(this, uploadResult.data);
            }
            for (let i = 0; i < this.fileListData.length; i++) {
              const file = this.fileListData[i];
              if (this.onUploaded && file.file.cid)
                this.onUploaded(this, file.file, (_b = file.file.cid) == null ? void 0 : _b.cid);
              file.status = 1;
            }
            this.renderFilterBar();
            this.renderFileList();
          }
        } catch (err) {
          console.log("Error! ", err);
        }
      } else {
        if (this.onBeforeUploaded)
          this.onBeforeUploaded(this, cidItems);
        let uploadUrl = await application.getUploadUrl(cidItems);
        for (let i = 0; i < dirItems.length; i++) {
          let item = dirItems[i];
          if (uploadUrl[item.cid]) {
            await application.upload(uploadUrl[item.cid], JSON.stringify(item));
          }
        }
        for (let i = 0; i < this.fileListData.length; i++) {
          if (this.isForcedCancelled) {
            break;
          } else {
            const file = this.fileListData[i];
            file.url = `/ipfs/${cidItems.cid}${file.file.path || file.file.name}`;
            if ([1, 3].includes(file.status) || !((_c = file.file.cid) == null ? void 0 : _c.cid)) {
              continue;
            }
            this.fileListData[i].status = 3;
            this.renderFilterBar();
            if (uploadUrl[(_d = file.file.cid) == null ? void 0 : _d.cid]) {
              try {
                let result = await application.upload(uploadUrl[(_e = file.file.cid) == null ? void 0 : _e.cid], file.file);
                console.log("uploaded fileListData result: ", result);
                if (this.onUploaded)
                  this.onUploaded(this, file.file, (_f = file.file.cid) == null ? void 0 : _f.cid);
                this.fileListData[i].status = 1;
                this.renderFilterBar();
                this.renderFileList();
              } catch (err) {
                console.log("Error! ", err);
                this.fileListData[i].status = 2;
              }
            }
          }
        }
        this.renderFilterBar();
        this.renderFileList();
        this.renderPagination();
        this._uploadBtnElm.caption = "Upload file to IPFS";
        this._uploadBtnElm.enabled = true;
      }
    });
  }
  reset() {
    this._fileListElm.clearInnerHTML();
    this._paginationElm.clearInnerHTML();
    this._uploadBtnElm.caption = "Upload file to IPFS";
    this._uploadBtnElm.enabled = true;
    this.fileListData = [];
    this.files = [];
    this.toggle(false);
  }
  toggle(showFileList) {
    if (showFileList) {
      this._statusFilterElm.visible = true;
      this._uploadBtnElm.visible = true;
      this._notePnlElm.visible = false;
    } else {
      this._statusFilterElm.visible = false;
      this._uploadBtnElm.visible = false;
      this._notePnlElm.visible = true;
    }
  }
  async init() {
    if (!this.initialized) {
      super.init();
      this.rootCid = this.getAttribute("rootCid", true);
      this.parentDir = this.getAttribute("parentDir", true);
      this._uploadModalElm = await Modal.create({
        showBackdrop: true,
        closeOnBackdropClick: false,
        popupPlacement: "center",
        width: "800px",
        maxWidth: "100%",
        height: "auto",
        padding: { top: 0, right: 0, bottom: 0, left: 0 },
        border: { radius: "0.675rem" },
        boxShadow: "0 1px 5px 0 rgb(0 0 0 / 12%), 0 2px 10px 0 rgb(0 0 0 / 8%), 0 1px 20px 0 rgb(0 0 0 / 8%)",
        maxHeight: "90vh",
        overflow: { y: "auto" },
        zIndex: 1e3,
        mediaQueries: [
          {
            maxWidth: "767px",
            properties: {
              maxHeight: "100%",
              height: "100vh",
              width: "100vw"
            }
          }
        ],
        onClose: () => this.reset()
      });
      this.appendChild(this._uploadModalElm);
      this._uploadBoxElm = new Panel(this, {
        height: "100%",
        overflow: "hidden",
        border: { radius: "0.375rem" },
        padding: {
          top: "3.125rem",
          right: "8.5rem",
          bottom: "3.125rem",
          left: "8.125rem"
        },
        mediaQueries: [
          {
            maxWidth: "767px",
            properties: {
              padding: {
                top: "1.5rem",
                right: "1.5rem",
                bottom: "1.5rem",
                left: "1.5rem"
              }
            }
          }
        ]
      });
      this._closeBtnElm = new Button(this._uploadBoxElm, {
        icon: { name: "times" },
        position: "absolute",
        top: "1rem",
        right: "1rem",
        maxHeight: "10%",
        zIndex: 2,
        background: { color: "transparent" },
        boxShadow: "none",
        padding: { top: 0, right: 0, bottom: 0, left: 0 },
        onClick: () => this.hide()
      });
      const headingElm = new Label(this._uploadBoxElm, {
        caption: "Upload more files",
        font: { size: "clamp(1rem, 1rem + 0.625vw, 1.625rem)", color: Theme16.colors.primary.dark, weight: 700 },
        lineHeight: 1.5,
        display: "block",
        class: "text-center"
      });
      const labelElm = new Label(this._uploadBoxElm, {
        caption: "Choose file to upload to IPFS network",
        margin: { bottom: "0.5rem" },
        display: "block",
        class: "text-center"
      });
      const fileUploaderDropzone = new VStack(this._uploadBoxElm, {
        maxHeight: "calc(100% - 4.5rem)",
        margin: { top: "2rem", bottom: "2.5rem" },
        gap: "1.5rem"
      });
      fileUploaderDropzone.classList.add("file-uploader-dropzone");
      const droparea = new VStack(fileUploaderDropzone, {
        horizontalAlignment: "center",
        verticalAlignment: "center",
        padding: { top: "1.875rem", bottom: "1.875rem" },
        background: { color: "rgba(255,255,255,.1)" },
        border: { radius: "0.625rem", width: "2px", style: "dashed", color: Theme16.colors.primary.light },
        cursor: "pointer",
        gap: "1rem",
        position: "relative"
      });
      this._fileUploader = new Upload(droparea, {
        multiple: true,
        draggable: true
      });
      this._fileUploader.onBeforeDrop = (source) => this.onBeforeDrop(source);
      this._fileUploader.onUploading = this.onBeforeUpload;
      this._fileUploader.onChanged = (source, files) => this.onChangeFile(source, files);
      this._fileUploader.onRemoved = () => this.onRemove;
      this._fileIcon = new Image2(droparea, { width: 60, height: 60 });
      this._fileIcon.classList.add("icon");
      this._fileIcon.url = `${LibPath}assets/img/file-icon.png`;
      this._dragLabelElm = new Label(droparea, {
        caption: "Drag and drop your files here"
      });
      this._statusFilterElm = new HStack(fileUploaderDropzone, {
        horizontalAlignment: "space-between"
      });
      this._statusFilterElm.classList.add("status-filter");
      this._statusFilterElm.visible = false;
      this._filterBarElm = new HStack(this._statusFilterElm, {
        gap: "0.675rem",
        mediaQueries: [
          {
            maxWidth: "767px",
            properties: { visible: false }
          }
        ]
      });
      this._filterBarElm.classList.add("filter-bar");
      this._filterActionsElm = new Panel(this._statusFilterElm, {
        margin: { left: "auto" }
      });
      this._fileListElm = new VStack(fileUploaderDropzone, { gap: "0.5rem", margin: { bottom: "0.5rem" } });
      this._fileListElm.classList.add("filelist");
      this._paginationElm = new HStack(fileUploaderDropzone, {
        gap: "0.313rem",
        horizontalAlignment: "center",
        verticalAlignment: "center",
        mediaQueries: [
          {
            maxWidth: "767px",
            properties: { visible: false }
          }
        ]
      });
      this._paginationElm.classList.add("pagination");
      this._uploadBtnElm = new Button(fileUploaderDropzone, {
        caption: "Upload files to IPFS",
        class: "upload-btn",
        boxShadow: "none",
        background: { color: Theme16.colors.primary.main },
        font: { color: Theme16.colors.primary.contrastText },
        padding: { top: "0.5rem", bottom: "0.5rem", left: "0.5rem", right: "0.5rem" },
        visible: false
      });
      this._uploadBtnElm.onClick = () => this.onUpload();
      this._notePnlElm = new Panel(this._uploadBoxElm);
      const note1Elm = new VStack(this._notePnlElm, {
        class: "note",
        lineHeight: "1.4375rem",
        padding: { left: "1.25rem", right: "0.25rem" },
        gap: "1.5rem"
      });
      const head1Elm = new Label(note1Elm, {
        caption: "Public Data",
        class: "head",
        font: { weight: 700, size: "0.875rem" }
      });
      const desc1Elm = new Label(note1Elm, {
        caption: "All data uploaded to IPFS Explorer is available to anyone who requests it using the correct CID. Do not store any private or sensitive information in an unencrypted form using IPFS Explorer.",
        class: "desc",
        font: { size: "0.75rem", weight: 400, color: Theme16.text.secondary },
        letterSpacing: 0
      });
      const note2Elm = new VStack(this._notePnlElm, {
        class: "note",
        lineHeight: "1.4375rem",
        padding: { left: "1.25rem", right: "0.25rem" }
      });
      const head2Elm = new Label(note2Elm, {
        caption: "Permanent Data",
        class: "head",
        font: { weight: 700, size: "0.875rem" }
      });
      const des2cElm = new Label(note2Elm, {
        caption: "Deleting files from the IPFS Explorer site\u2019s Files page will remove them from the file listing for your account, but that doesn\u2019t prevent nodes on the decentralized storage network from retaining copies of the data indefinitely. Do not use IPFS Explorer for data that may need to be permanently deleted in the future.",
        class: "desc",
        font: { size: "0.75rem", weight: 400, color: Theme16.text.secondary },
        letterSpacing: 0
      });
      this._uploadModalElm.item = this._uploadBoxElm;
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
UploadModal = __decorateClass([
  customElements2("i-upload-modal")
], UploadModal);

// packages/tab/src/style/tab.css.ts
var Theme17 = theme_exports.ThemeVars;
cssRule("i-tabs", {
  display: "block",
  $nest: {
    "> .tabs-nav-wrap": {
      display: "flex",
      flex: "none",
      overflow: "hidden",
      $nest: {
        ".tabs-nav": {
          position: "relative",
          display: "flex",
          flex: "none",
          overflow: "hidden",
          whiteSpace: "nowrap",
          borderBottom: `1px solid #252525`,
          margin: 0
        },
        ".tabs-nav:not(.is-closable) span.close": {
          display: "none"
        },
        ".tabs-nav .has-icon span.close": {
          display: "none"
        },
        ".tabs-nav.is-closable i-tab:not(.disabled):hover span.close": {
          visibility: "visible",
          opacity: 1,
          display: "inline-block"
        },
        ".tabs-nav.is-closable i-tab:not(.disabled):hover .pnl-right i-icon": {
          display: "none"
        },
        ".tabs-nav.is-closable i-tab:not(.disabled).active span.close": {
          visibility: "visible",
          opacity: 1
        },
        "i-tab": {
          position: "relative",
          display: "inline-flex",
          overflow: "hidden",
          color: "rgba(255, 255, 255, 0.55)",
          marginBottom: "-1px",
          border: `1px solid #252525`,
          alignItems: "center",
          font: "inherit",
          textAlign: "center",
          minHeight: "36px",
          $nest: {
            "&:not(.disabled):hover": {
              cursor: "pointer",
              color: "#fff"
            },
            "&:not(.disabled).active.border": {
              borderColor: `${Theme17.divider} ${Theme17.divider} #fff`,
              borderBottomWidth: "1.5px"
            },
            ".tab-item": {
              position: "relative",
              display: "flex",
              alignItems: "center",
              cursor: "pointer",
              padding: "0.5rem 1rem",
              gap: "5px",
              $nest: {
                "i-image": {
                  display: "flex"
                }
              }
            }
          }
        },
        "i-tab:not(.disabled).active": {
          backgroundColor: "#1d1d1d",
          borderBottomColor: "transparent",
          color: "#fff"
        }
      }
    },
    "&:not(.vertical) > .tabs-nav-wrap": {
      $nest: {
        "&:hover": {
          overflowX: "auto",
          overflowY: "hidden"
        },
        "&::-webkit-scrollbar-thumb": {
          background: "#4b4b4b",
          borderRadius: "5px"
        },
        "&::-webkit-scrollbar": {
          height: "3px"
        }
      }
    },
    "&.vertical": {
      display: "flex",
      $nest: {
        "> .tabs-nav-wrap .tabs-nav": {
          display: "flex",
          flexDirection: "column"
        },
        "> .tabs-nav-wrap .tabs-nav:hover": {
          overflowY: "auto"
        },
        "> .tabs-nav-wrap .tabs-nav::-webkit-scrollbar-thumb": {
          background: "#4b4b4b",
          borderRadius: "5px"
        },
        "> .tabs-nav-wrap .tabs-nav::-webkit-scrollbar": {
          width: "3px"
        }
      }
    },
    "> .tabs-content": {
      position: "relative",
      overflow: "hidden",
      display: "flex",
      width: "100%",
      height: "100%",
      minHeight: "200px",
      $nest: {
        "&::after": {
          clear: "both"
        },
        "i-label .f1yauex0": {
          whiteSpace: "normal"
        },
        ".content-pane": {
          position: "relative",
          width: "100%",
          height: "100%",
          flex: "none"
        }
      }
    },
    "span.close": {
      width: "18px",
      height: "18px",
      borderRadius: "5px",
      lineHeight: "18px",
      fontSize: "18px",
      visibility: "hidden",
      opacity: 0,
      $nest: {
        "&:hover": {
          background: "rgba(78, 78, 78, 0.48)"
        }
      }
    },
    ".pnl-right": {
      display: "inline-flex",
      justifyContent: "end",
      width: 20,
      overflow: "hidden",
      marginLeft: 5,
      marginRight: -5
    }
  }
});
var getTabMediaQueriesStyleClass = (mediaQueries) => {
  let styleObj = getControlMediaQueriesStyle(mediaQueries, { display: "block" });
  for (let mediaQuery of mediaQueries) {
    let mediaQueryRule = getMediaQueryRule(mediaQuery);
    if (mediaQueryRule) {
      const nestObj = styleObj["$nest"][mediaQueryRule]["$nest"] || {};
      const ruleObj = styleObj["$nest"][mediaQueryRule];
      styleObj["$nest"][mediaQueryRule] = {
        ...ruleObj,
        $nest: {
          ...nestObj,
          "> .tabs-nav-wrap .tabs-nav": {}
        }
      };
      const {
        mode,
        visible
      } = mediaQuery.properties || {};
      if (mode) {
        styleObj["$nest"][mediaQueryRule]["display"] = mode === "vertical" ? "flex !important" : "block !important";
        if (mode === "horizontal") {
          styleObj["$nest"][mediaQueryRule]["$nest"]["> .tabs-nav-wrap .tabs-nav"]["flexDirection"] = "row !important";
          styleObj["$nest"][mediaQueryRule]["$nest"]["> .tabs-nav-wrap .tabs-nav"]["width"] = "100%";
          styleObj["$nest"][mediaQueryRule]["$nest"]["> .tabs-nav-wrap .tabs-nav"]["justifyContent"] = "center";
        } else {
          styleObj["$nest"][mediaQueryRule]["$nest"]["> .tabs-nav-wrap .tabs-nav"]["flexDirection"] = "column !important";
          styleObj["$nest"][mediaQueryRule]["$nest"]["> .tabs-nav-wrap .tabs-nav"]["width"] = "auto";
          styleObj["$nest"][mediaQueryRule]["$nest"]["> .tabs-nav-wrap .tabs-nav"]["justifyContent"] = "start";
        }
      }
    }
  }
  return style(styleObj);
};

// packages/tab/src/tab.ts
var DEFAULT_VALUES7 = {
  activeTabIndex: 0,
  closable: false,
  draggable: false,
  mode: "horizontal"
};
var Tabs = class extends Container {
  constructor(parent, options) {
    super(parent, options);
    this.accumTabIndex = 0;
    this.dragStartHandler = this.dragStartHandler.bind(this);
    this.dragOverHandler = this.dragOverHandler.bind(this);
    this.dropHandler = this.dropHandler.bind(this);
  }
  get activeTab() {
    return this._tabs[this.activeTabIndex];
  }
  get activeTabIndex() {
    return this._activeTabIndex;
  }
  set activeTabIndex(index) {
    var _a;
    if (index < 0 || this._activeTabIndex === index)
      return;
    const prevTab = this._tabs[this._activeTabIndex];
    if (prevTab) {
      prevTab.classList.remove("active");
      this.contentPanes[this._activeTabIndex].style.display = "none";
    }
    this._activeTabIndex = index;
    (_a = this.activeTab) == null ? void 0 : _a.classList.add("active");
    if (this.contentPanes[index]) {
      this.contentPanes[index].style.display = "";
      this.refreshControls();
    }
  }
  get items() {
    return this._tabs;
  }
  get closable() {
    return this._closable;
  }
  set closable(value) {
    this._closable = value;
    if (value) {
      this.tabsNavElm.classList.add("is-closable");
    } else {
      this.tabsNavElm.classList.remove("is-closable");
    }
  }
  get draggable() {
    return this._draggable;
  }
  set draggable(value) {
    if (this._draggable === value)
      return;
    this._draggable = value;
    if (this.draggable) {
      this.tabsNavElm.ondragover = this.dragOverHandler;
      this.tabsNavElm.ondrop = this.dropHandler;
    } else {
      this.tabsNavElm.ondragover = null;
      this.tabsNavElm.ondrop = null;
    }
    this.handleTagDrag(this._tabs);
  }
  get mode() {
    const isVertical = this.classList.contains("vertical");
    return isVertical ? "vertical" : "horizontal";
  }
  set mode(type) {
    if (type === "vertical") {
      this.classList.add("vertical");
    } else {
      this.classList.remove("vertical");
    }
  }
  get mediaQueries() {
    return this._mediaQueries;
  }
  set mediaQueries(value) {
    this._mediaQueries = value;
    let style2 = getTabMediaQueriesStyleClass(this._mediaQueries);
    this._mediaStyle && this.classList.remove(this._mediaStyle);
    this._mediaStyle = style2;
    this.classList.add(style2);
  }
  add(options) {
    const tab = new Tab(this, options);
    if (options == null ? void 0 : options.children) {
      tab.append(options == null ? void 0 : options.children);
    }
    if (this.draggable) {
      this.handleTagDrag([tab]);
    }
    this.appendTab(tab);
    this.activeTabIndex = tab.index;
    return tab;
  }
  delete(tab) {
    const index = this._tabs.findIndex((t) => t.id === tab.id);
    const activeIndex = this.activeTabIndex;
    if (index >= 0) {
      this._tabs.splice(index, 1);
      const pane = this.contentPanes[index];
      this.contentPanes.splice(index, 1);
      pane.remove();
      if (activeIndex >= index) {
        let newActiveIndex = activeIndex > index ? activeIndex - 1 : this._tabs[activeIndex] ? activeIndex : this._tabs.length - 1;
        this._activeTabIndex = newActiveIndex;
        if (this.activeTab) {
          this.activeTab.classList.add("active");
          this.contentPanes[newActiveIndex].style.display = "";
        }
      }
    }
    tab.ondragstart = null;
    tab.controls.forEach((c) => {
      c.parent = void 0;
      c.remove();
    });
    tab.remove();
  }
  appendTab(tab) {
    this.initTabsNav();
    tab._container = this.tabsContentElm;
    tab.parent = this;
    this._tabs.push(tab);
    if (!tab.id)
      tab.id = `tab-${this.accumTabIndex++}`;
    this.tabsNavElm.appendChild(tab);
    const contentPane = this.createElement("div", this.tabsContentElm);
    tab._contentElm = contentPane;
    contentPane.classList.add("content-pane");
    contentPane.style.display = "none";
    this.contentPanes.push(contentPane);
    const children = tab.children;
    for (let i = 0; i < children.length; i++) {
      if (children[i].classList.contains("tab-item"))
        continue;
      if (children[i] instanceof Control) {
        children[i].parent = tab;
      }
    }
    ;
  }
  handleTagDrag(tabs) {
    tabs.forEach((tab) => {
      if (this.draggable) {
        tab.setAttribute("draggable", "true");
        tab.ondragstart = this.dragStartHandler;
      } else {
        tab.removeAttribute("draggable");
        tab.ondragstart = null;
      }
    });
  }
  _handleClick(event) {
    if (this._designMode)
      return false;
    return super._handleClick(event, true);
  }
  dragStartHandler(event) {
    if (!(event.target instanceof Tab) || this._designMode)
      return;
    this.curDragTab = event.target;
  }
  dragOverHandler(event) {
    event.preventDefault();
  }
  dropHandler(event) {
    event.preventDefault();
    if (!this.curDragTab || this._designMode)
      return;
    const target = event.target;
    const dropTab = target instanceof Tab ? target : target.closest("i-tab");
    if (dropTab && !this.curDragTab.isSameNode(dropTab)) {
      const curActiveTab = this.activeTab;
      const dragIndex = this.curDragTab.index;
      const dropIndex = dropTab.index;
      const [dragTab] = this._tabs.splice(dragIndex, 1);
      this._tabs.splice(dropIndex, 0, dragTab);
      const [dragContent] = this.contentPanes.splice(dragIndex, 1);
      this.contentPanes.splice(dropIndex, 0, dragContent);
      if (dragIndex > dropIndex) {
        this.tabsNavElm.insertBefore(this.curDragTab, dropTab);
      } else {
        dropTab.after(this.curDragTab);
      }
      this.activeTabIndex = curActiveTab.index;
      if (typeof this.onChanged === "function")
        this.onChanged(this, this.activeTab);
    }
    this.curDragTab = null;
  }
  refresh() {
    if (this.dock) {
      super.refresh(true);
      const height = this.mode === "horizontal" ? this.clientHeight - this.tabsNavElm.clientHeight : this.clientHeight;
      this.tabsContentElm.style.height = height + "px";
      this.refreshControls();
    }
  }
  init() {
    super.init();
    this.initTabsNav();
  }
  initTabsNav() {
    if (!this.tabsNavElm) {
      this.contentPanes = [];
      this._tabs = [];
      const _tabs = [];
      this.childNodes.forEach((node) => {
        if (node instanceof Tab) {
          _tabs.push(node);
        } else {
          node.remove();
        }
      });
      const tabsNavWrapElm = this.createElement("div", this);
      tabsNavWrapElm.classList.add("tabs-nav-wrap");
      tabsNavWrapElm.addEventListener("wheel", (event) => {
        if (tabsNavWrapElm.scrollWidth > tabsNavWrapElm.clientWidth) {
          event.preventDefault();
          tabsNavWrapElm.scrollLeft += event.deltaY;
        }
      });
      this.tabsNavElm = this.createElement("div", tabsNavWrapElm);
      this.tabsNavElm.classList.add("tabs-nav");
      this.tabsContentElm = this.createElement("div", this);
      this.tabsContentElm.classList.add("tabs-content");
      this.closable = this.getAttribute("closable", true) || false;
      this.mode = this.getAttribute("mode", true) || "horizontal";
      for (const tab of _tabs) {
        this.appendTab(tab);
      }
      this.draggable = this.getAttribute("draggable", true) || false;
      const activeTabIndex = this.getAttribute("activeTabIndex", true);
      if (this._tabs.length)
        this.activeTabIndex = activeTabIndex || 0;
      this.mediaQueries = this.getAttribute("mediaQueries", true, []);
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Tabs = __decorateClass([
  customElements2("i-tabs", {
    icon: "window-minimize",
    className: "Tabs",
    group: GroupType.BASIC,
    props: {
      activeTabIndex: { type: "number" },
      closable: { type: "boolean", default: DEFAULT_VALUES7.closable },
      draggable: { type: "boolean", default: DEFAULT_VALUES7.draggable },
      mode: { type: "string", default: DEFAULT_VALUES7.mode }
    },
    events: {
      onChanged: [
        { name: "target", type: "Tabs", isControl: true },
        { name: "tab", type: "Tab", isControl: true }
      ],
      onCloseTab: [
        { name: "target", type: "Tabs", isControl: true },
        { name: "activeTab", type: "Tab", isControl: true }
      ],
      onBeforeClose: [
        { name: "target", type: "Tabs", isControl: true },
        { name: "activeTab", type: "Tab", isControl: true }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        activeTabIndex: {
          type: "number"
        },
        closable: {
          type: "boolean",
          default: DEFAULT_VALUES7.closable
        },
        draggable: {
          type: "boolean",
          default: DEFAULT_VALUES7.draggable
        },
        mode: {
          type: "string",
          enum: ["horizontal", "vertical"],
          default: DEFAULT_VALUES7.mode
        }
      }
    }
  })
], Tabs);
var Tab = class extends Container {
  active() {
    this._parent.activeTabIndex = this.index;
  }
  addChildControl(control) {
    if (this._contentElm)
      this._contentElm.appendChild(control);
  }
  removeChildControl(control) {
    if (this._contentElm && this._contentElm.contains(control))
      this._contentElm.removeChild(control);
  }
  get caption() {
    return this.captionElm.innerHTML;
  }
  set caption(value) {
    this.captionElm.innerHTML = value;
  }
  close() {
    this.handleDefaultClose();
  }
  get index() {
    return this._parent.items.findIndex((t) => t.id === this.id);
  }
  get icon() {
    if (!this._icon) {
      this._icon = Icon.create({
        width: 16,
        height: 16
      }, this);
    }
    ;
    return this._icon;
  }
  set icon(elm) {
    if (this._icon)
      this.tabContainer.removeChild(this._icon);
    this._icon = elm;
    if (this._icon)
      this.tabContainer.prepend(this._icon);
  }
  get rightIcon() {
    if (!this._rightIcon) {
      this._rightIcon = Icon.create({
        width: 16,
        height: 16
      }, this);
      this.rightElm.classList.add("has-icon");
    }
    ;
    return this._rightIcon;
  }
  set rightIcon(elm) {
    if (this._rightIcon && this.rightElm.contains(this._rightIcon))
      this.rightElm.removeChild(this._rightIcon);
    this._rightIcon = elm;
    if (this._rightIcon) {
      this.rightElm.prepend(this._rightIcon);
      this.rightElm.classList.add("has-icon");
    } else {
      this.rightElm.classList.remove("has-icon");
    }
  }
  get innerHTML() {
    return this._contentElm.innerHTML;
  }
  set innerHTML(value) {
    this._contentElm.innerHTML = value;
  }
  get font() {
    return {
      color: this.captionElm.style.color,
      name: this.captionElm.style.fontFamily,
      size: this.captionElm.style.fontSize,
      bold: this.captionElm.style.fontStyle.indexOf("bold") >= 0,
      style: this.captionElm.style.fontStyle,
      transform: this.captionElm.style.textTransform,
      weight: this.captionElm.style.fontWeight,
      shadow: this.captionElm.style.textShadow
    };
  }
  set font(value) {
    if (this.captionElm) {
      this.captionElm.style.color = value.color || "";
      this.captionElm.style.fontSize = value.size || "";
      this.captionElm.style.fontFamily = value.name || "";
      this.captionElm.style.fontStyle = value.style || "";
      this.captionElm.style.textTransform = value.transform || "none";
      this.captionElm.style.fontWeight = value.bold ? "bold" : `${value.weight}` || "";
      this.captionElm.style.textShadow = value.shadow || "none";
    }
  }
  _handleClick(event) {
    if (!this._parent || !this.enabled || this._parent.activeTab.isSameNode(this) || this._designMode)
      return false;
    if (this._parent) {
      if (this._parent.activeTab != this)
        this._parent.activeTabIndex = this.index;
      if (typeof this._parent.onChanged === "function")
        this._parent.onChanged(this._parent, this._parent.activeTab);
    }
    return super._handleClick(event);
  }
  handleCloseTab(event) {
    if (this._designMode)
      return;
    if (event) {
      event.stopPropagation();
      event.preventDefault();
    }
    if (!this._parent || !this.enabled || event && !this._parent.closable)
      return;
    if (typeof this._parent.onBeforeClose === "function") {
      this._parent.onBeforeClose(this._parent, this);
    } else {
      this.handleDefaultClose();
    }
  }
  handleDefaultClose() {
    const isActiveChange = this._parent.activeTab.isSameNode(this);
    if (typeof this._parent.onCloseTab === "function")
      this._parent.onCloseTab(this._parent, this);
    this._parent.delete(this);
    if (isActiveChange && typeof this._parent.onChanged === "function")
      this._parent.onChanged(this._parent, this._parent.activeTab);
  }
  init() {
    var _a, _b;
    if (!this.captionElm) {
      super.init();
      this.tabContainer = this.createElement("div", this);
      this.tabContainer.classList.add("tab-item");
      this.captionElm = this.createElement("div", this.tabContainer);
      this.caption = this.getAttribute("caption", true) || "";
      const font = this.getAttribute("font", true);
      if (font)
        this.font = font;
      const icon = this.getAttribute("icon", true);
      if ((icon == null ? void 0 : icon.name) || ((_a = icon == null ? void 0 : icon.image) == null ? void 0 : _a.url)) {
        icon.height = icon.height || "1rem";
        icon.width = icon.width || "1rem";
        this.icon = new Icon(void 0, icon);
      }
      ;
      this.rightElm = this.createElement("span", this.tabContainer);
      this.rightElm.classList.add("pnl-right");
      const rightIcon = this.getAttribute("rightIcon", true);
      if ((rightIcon == null ? void 0 : rightIcon.name) || ((_b = rightIcon == null ? void 0 : rightIcon.image) == null ? void 0 : _b.url)) {
        rightIcon.height = rightIcon.height || "1rem";
        rightIcon.width = rightIcon.width || "1rem";
        this.rightIcon = new Icon(void 0, rightIcon);
        this.rightElm.classList.add("has-icon");
      }
      ;
      this._closeBtn = this.createElement("span", this.rightElm);
      this._closeBtn.classList.add("close");
      this._closeBtn.innerHTML = "&times;";
      this._closeBtn.onclick = this.handleCloseTab.bind(this);
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Tab = __decorateClass([
  customElements2("i-tab", {
    icon: "window-minimize",
    group: GroupType.BASIC,
    className: "Tab",
    props: {
      caption: {
        type: "string"
      },
      icon: {
        type: "object",
        default: {}
      }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        caption: { type: "string" },
        icon: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            fill: {
              type: "string",
              format: "color"
            },
            image: {
              type: "object",
              properties: {
                url: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    }
  })
], Tab);

// packages/combo-box/src/style/combo-box.css.ts
var Theme18 = theme_exports.ThemeVars;
var ItemListStyle = style({
  display: "none",
  position: "absolute",
  margin: "0.05rem 0 0",
  backgroundColor: "#fff",
  border: "1px solid rgba(0,0,0,.15)",
  borderRadius: "0.25rem",
  zIndex: "99999",
  $nest: {
    "> ul": {
      maxHeight: "100px",
      overflowY: "scroll",
      overflowX: "hidden",
      listStyle: "none",
      margin: 0,
      padding: 0,
      borderRadius: "inherit"
    },
    "> ul > li": {
      display: "block",
      width: "100%",
      padding: "0.25rem 0.5rem",
      backgroundColor: "transparent",
      wordBreak: "break-word",
      cursor: "pointer",
      borderRadius: "inherit"
    },
    "> ul > li .highlight": {
      backgroundColor: Theme18.colors.warning.light
    },
    "> ul > li.matched": {
      backgroundColor: Theme18.colors.primary.light
    },
    "> ul > li:hover": {
      backgroundColor: Theme18.colors.primary.light
    },
    ".selection-item": {
      display: "grid",
      gridTemplateColumns: "25px 1fr",
      gap: 5,
      alignItems: "center",
      fontFamily: Theme18.typography.fontFamily
    },
    ".selection-icon": {
      height: 20,
      width: 20
    },
    ".selection-title": {
      display: "block",
      color: Theme18.combobox.fontColor,
      fontWeight: "bold"
    },
    ".selection-description": {
      display: "block",
      color: Theme18.combobox.fontColor,
      fontSize: Theme18.typography.fontSize
    }
  }
});
cssRule("i-combo-box", {
  position: "relative",
  display: "flex",
  fontFamily: Theme18.typography.fontFamily,
  fontSize: Theme18.typography.fontSize,
  color: Theme18.text.primary,
  alignItems: "center",
  $nest: {
    "&.i-combo-box-multi": {
      height: "auto !important"
    },
    "> .icon-btn": {
      display: "inline-flex",
      flexWrap: "nowrap",
      whiteSpace: "nowrap",
      background: "inherit",
      padding: "8px",
      marginLeft: "-1px",
      cursor: "pointer",
      height: "100%",
      alignItems: "center",
      position: "absolute",
      right: 0,
      border: `0.5px solid ${Theme18.divider}`,
      borderLeft: "none",
      borderRadius: "inherit",
      borderTopLeftRadius: "0px !important",
      borderBottomLeftRadius: "0px !important"
    },
    "> .icon-btn:hover": {
      backgroundColor: Theme18.action.hover
    },
    "> .icon-btn i-icon": {
      display: "inline-block",
      width: "12px",
      height: "12px"
    },
    ".selection": {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "wrap",
      maxWidth: "calc(100% - 32px)",
      height: "100%",
      border: `0.5px solid ${Theme18.divider}`,
      borderRight: "none !important",
      background: Theme18.combobox.background,
      borderRadius: "inherit",
      borderTopRightRadius: "0px !important",
      borderBottomRightRadius: "0px !important",
      padding: "2px 4px",
      transition: "all .3s cubic-bezier(.645,.045,.355,1)",
      gap: 5,
      flexGrow: 1,
      maxHeight: "100%",
      $nest: {
        ".selection-item": {
          border: `1px solid ${Theme18.divider}`,
          backgroundColor: "rgba(0, 0, 0, 0.12)",
          color: "#000",
          borderRadius: 3,
          display: "inline-flex",
          alignItems: "center",
          padding: "3px 5px",
          gap: 4,
          maxWidth: "clamp(100px, 50%, 200px)",
          userSelect: "none",
          $nest: {
            ".close-icon": {
              cursor: "pointer",
              opacity: "0.5"
            },
            ".close-icon:hover": {
              opacity: 1
            },
            "> span:first-child": {
              display: "inline-block",
              overflow: "hidden",
              whiteSpace: "pre",
              textOverflow: "ellipsis"
            }
          }
        },
        "input": {
          padding: "1px 0.5rem",
          border: "none",
          boxShadow: "none",
          outline: "none",
          width: "auto !important",
          maxWidth: "100%",
          flex: 1,
          background: Theme18.combobox.background,
          color: Theme18.combobox.fontColor,
          fontSize: "inherit"
        }
      }
    }
  }
});

// packages/combo-box/src/combo-box.ts
var DEFAULT_VALUES8 = {
  mode: "single",
  readOnly: false,
  icon: {
    width: 16,
    height: 16,
    fill: theme_exports.ThemeVars.text.primary,
    name: "angle-down"
  }
};
var ComboBox = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      mode: DEFAULT_VALUES8.mode
    });
    this.newItem = null;
    this.isListShown = false;
  }
  get value() {
    return this.selectedItem;
  }
  set value(value) {
  }
  get selectedItem() {
    return this._selectedItem;
  }
  set selectedItem(value) {
    if (value === void 0) {
      this._selectedItem = void 0;
      this.inputElm.value = "";
      return;
    }
    let isValueValid = false;
    let validValue;
    if (this.isMulti) {
      const formattedValue = Array.isArray(value) ? value : [value];
      validValue = formattedValue.filter((item) => this.isValueValid(item));
      isValueValid = !!validValue.length;
    } else {
      validValue = value;
      isValueValid = this.isValueValid(value);
    }
    if (isValueValid) {
      this._selectedItem = validValue;
      if (Array.isArray(this._selectedItem)) {
        this.inputElm.value = "";
        const selectionItems = Array.from(this.inputWrapElm.querySelectorAll(".selection-item"));
        selectionItems.forEach((elm) => this.inputWrapElm.removeChild(elm));
        this._selectedItem.forEach((item) => {
          const itemElm = this.createElement("div");
          itemElm.classList.add("selection-item");
          const content = this.createElement("span", itemElm);
          content.textContent = item.label;
          itemElm.appendChild(content);
          const closeButton = this.createElement("span", itemElm);
          closeButton.classList.add("close-icon");
          closeButton.innerHTML = "&times;";
          closeButton.addEventListener("click", (event) => this.handleRemove(event, item));
          this.inputWrapElm.appendChild(itemElm);
          this.inputWrapElm.insertBefore(itemElm, this.inputElm);
        });
      } else {
        this.inputElm.value = this._selectedItem.label;
      }
      if (this.callback)
        this.callback(value);
    } else if (this.isMulti) {
      this._selectedItem = validValue;
      this.inputElm.value = "";
      const selectionItems = Array.from(this.inputWrapElm.querySelectorAll(".selection-item"));
      selectionItems.forEach((elm) => this.inputWrapElm.removeChild(elm));
    }
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    this.labelElm.innerHTML = this._caption || "";
    if (!value)
      this.labelElm.style.display = "none";
    else
      this.labelElm.style.display = "";
  }
  get captionWidth() {
    return this._captionWidth;
  }
  set captionWidth(value) {
    this._captionWidth = value;
    this.setElementPosition(this.labelElm, "width", value);
  }
  get items() {
    return this._items;
  }
  set items(items) {
    this._items = items;
    if (this.listElm) {
      this.listElm.innerHTML = "";
      this.renderItems();
    }
  }
  get icon() {
    if (!this._icon) {
      this._icon = new Icon(void 0, DEFAULT_VALUES8.icon);
      if (this.iconElm)
        this.iconElm.appendChild(this._icon);
    }
    return this._icon;
  }
  set icon(value) {
    if (this.iconElm) {
      if (this._icon && this.iconElm.contains(this._icon))
        this.iconElm.removeChild(this._icon);
      this._icon = value;
      if (this._icon)
        this.iconElm.appendChild(this._icon);
    }
  }
  get searchStr() {
    return this._searchStr;
  }
  set searchStr(str) {
    if (str === null)
      str = "";
    this._searchStr = str;
  }
  get placeholder() {
    return this.inputElm.placeholder;
  }
  set placeholder(value) {
    this.inputElm.placeholder = value;
  }
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
    if (this.isMulti)
      this.classList.add("i-combo-box-multi");
    else
      this.classList.remove("i-combo-box-multi");
  }
  get isMulti() {
    return this.mode === "tags" || this.mode === "multiple";
  }
  set border(value) {
    super.border = value;
    const hasBorderSide = this.border.bottom || this.border.top || this.border.left || this.border.right;
    if (this.border.style || hasBorderSide) {
      this.inputWrapElm && (this.inputWrapElm.style.borderStyle = "none");
      this.iconElm && (this.iconElm.style.borderStyle = "none");
    }
  }
  get border() {
    return super.border;
  }
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(value) {
    this._readOnly = value;
    if (this.inputElm) {
      this.inputElm.readOnly = value;
    }
  }
  get background() {
    return this._background;
  }
  set background(value) {
    super.background = value;
    if (value && value.color !== void 0) {
      this.style.setProperty("--combobox-background", value.color);
    } else {
      this.style.removeProperty("--combobox-background");
    }
  }
  get font() {
    return this._font;
  }
  set font(value) {
    super.font = value;
    if (value && value.color !== void 0) {
      this.style.setProperty("--combobox-font_color", value.color);
    } else {
      this.style.removeProperty("--combobox-font_color");
    }
  }
  isValueValid(value) {
    if (!value)
      return false;
    const index = this.getItemIndex(this.items, value);
    return index >= 0;
  }
  getItemIndex(items, item) {
    const value = item == null ? void 0 : item.value.toString();
    if (!value && value !== "")
      return -1;
    const index = items.findIndex((_item) => {
      return _item.value.toString().toLowerCase() === value.toLowerCase();
    });
    return index;
  }
  openList() {
    this.isListShown = true;
    window.document.body.append(this.listElm);
    this.listElm.classList.add("show");
    this.listElm.style.display = "block";
    this.calculatePositon();
    if (!this.searchStr)
      this.renderItems();
  }
  calculatePositon() {
    let parentElement = this.linkTo || this;
    let rect = parentElement.getBoundingClientRect();
    const scrollTop = document.documentElement.scrollTop || window.pageYOffset;
    const scrollLeft = document.documentElement.scrollLeft || window.pageXOffset;
    const top = rect.top + scrollTop + rect.height;
    const left = rect.left + scrollLeft;
    const width = rect.right - rect.left;
    this.listElm.style.top = top + "px";
    this.listElm.style.left = left + "px";
    this.listElm.style.width = width + "px";
  }
  closeList() {
    var _a;
    this.isListShown = false;
    this.listElm.remove();
    this.listElm.style.display = "none";
    this.listElm.classList.remove("show");
    this.searchStr = "";
    if (this.isMulti || Array.isArray(this.selectedItem))
      return;
    const label = (_a = this.selectedItem) == null ? void 0 : _a.label;
    if (label && this.inputElm)
      this.inputElm.value = label;
  }
  toggleList() {
    this.isListShown ? this.closeList() : this.openList();
  }
  escapeRegExp(text) {
    return text ? text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : text;
  }
  renderItems() {
    if (this.mode === "tags" && this.newItem) {
      if (this.searchStr)
        this.newItem.label = this.searchStr;
      const liElm = this.listElm.querySelector(`li[data-key="${this.newItem.value}"]`);
      if (liElm) {
        if (this.searchStr) {
          liElm.textContent = this.searchStr;
          liElm.classList.add("matched");
          liElm.innerHTML = `<span class="highlight">${this.searchStr}</span>`;
        } else {
          liElm.remove();
          this.newItem = null;
        }
      } else {
        const ul = this.listElm.querySelector("ul");
        ul && this.add(this.newItem, ul);
      }
    }
    const regExp = new RegExp(this.escapeRegExp(this.searchStr), "g");
    this.listElm.innerHTML = "";
    if (this.searchStr)
      this.openList();
    const ulElm = this.createElement("ul", this.listElm);
    let creatingNew = false;
    for (let item of this.items) {
      const label = item.label || "";
      const isMatchedPart = this.searchStr && label.toLowerCase().includes(this.searchStr.toLowerCase());
      const isMatchedDone = this.searchStr && label.toLowerCase() === this.searchStr.toLowerCase();
      if (item.isNew && isMatchedPart && !isMatchedDone)
        creatingNew = true;
      if (!this.searchStr || isMatchedDone || isMatchedPart) {
        const liElm = this.createElement("li", ulElm);
        liElm.setAttribute("data-key", item.value);
        liElm.addEventListener("click", (event) => {
          event.stopPropagation();
          this.onItemClick(event, liElm, item);
        });
        if (Array.isArray(this.selectedItem)) {
          const index = this.getItemIndex(this.selectedItem, item);
          if (index >= 0)
            liElm.classList.add("matched");
        } else if (item === this.selectedItem) {
          liElm.classList.add("matched");
        }
        let displayItem = "";
        if (item.description) {
          displayItem = `<div class="selection-item">
                   <div class="selection-icon">
                       ${item.icon ? `<img src="${item.icon}" style="height: 18px; width: 18px;"/>` : ""}
                   </div>
                   <div>
                      <span class="selection-title">${this.searchStr ? label.replace(regExp, `<span class="highlight">${this.searchStr}</span>`) : label}</span>
                      <span class="selection-description">${this.searchStr ? item.description.replace(regExp, `<span class="highlight">${this.searchStr}</span>`) : item.description}</span>
                   </div>
               </div>`;
        } else {
          displayItem = this.searchStr ? label.replace(regExp, `<span class="highlight">${this.searchStr}</span>`) : label;
        }
        liElm.innerHTML = displayItem;
      }
    }
    if (!ulElm.innerHTML || creatingNew) {
      if (this.mode === "tags") {
        if (!this.newItem)
          this.newItem = {
            value: new Date().getTime().toString(),
            label: this.searchStr
          };
        const liElm = this.listElm.querySelector(`li[data-key="${this.newItem.label}"]`);
        if (!liElm)
          this.add(this.newItem, ulElm);
      } else if (!ulElm.innerHTML)
        ulElm.innerHTML = '<li style="text-align:center;">No data</li>';
    }
  }
  add(item, parent) {
    const liElm = this.createElement("li");
    liElm.setAttribute("data-key", item.value);
    liElm.addEventListener("click", (event) => {
      event.stopPropagation();
      this.onItemClick(event, liElm, item);
    });
    liElm.classList.add("matched");
    liElm.innerHTML = `<span class="highlight">${this.searchStr}</span>`;
    parent.prepend(liElm);
  }
  handleRemove(event, item) {
    event.stopPropagation();
    if (!this.enabled)
      return;
    const liElm = this.listElm.querySelector(`li[data-key="${item.value}"]`);
    if (liElm) {
      liElm.classList.remove("matched");
      if (this.mode === "tags" && item.isNew) {
        liElm.remove();
        this.items = this.items.filter((data) => data.value !== item.value);
      }
    }
    const selectedItem = this.selectedItem;
    const selectedIndex = this.getItemIndex(selectedItem, item);
    if (selectedIndex >= 0)
      selectedItem.splice(selectedIndex, 1);
    this.selectedItem = selectedItem;
    if (this.onChanged)
      this.onChanged(this, event);
  }
  onItemClick(event, liElm, item) {
    var _a;
    if (((_a = this.newItem) == null ? void 0 : _a.value) === item.value) {
      item = { ...this.newItem, value: this.newItem.label, isNew: true };
      this.items.push(item);
    }
    this.newItem = null;
    if (Array.isArray(this.selectedItem)) {
      const index = this.getItemIndex(this.selectedItem, item);
      const selectedItem = this.selectedItem;
      if (index >= 0) {
        selectedItem.splice(index, 1);
      } else {
        selectedItem.push(item);
      }
      this.selectedItem = selectedItem;
      liElm.classList.toggle("matched");
      this.closeList();
    } else {
      this.selectedItem = item;
      this.closeList();
    }
    if (this.onChanged)
      this.onChanged(this, event);
  }
  clear() {
    if (this.isMulti) {
      this._selectedItem = [];
    } else {
      this._selectedItem = void 0;
    }
    this.inputElm.value = "";
  }
  init() {
    var _a;
    if (!this.inputElm) {
      this.calculatePositon = this.calculatePositon.bind(this);
      this.callback = this.getAttribute("parentCallback", true);
      const placeholder = this.getAttribute("placeholder", true);
      this.mode = this.getAttribute("mode", true);
      this.items = this.getAttribute("items", true, []);
      this.captionSpanElm = this.createElement("span", this);
      this.labelElm = this.createElement("label", this.captionSpanElm);
      this.inputWrapElm = this.createElement("div", this);
      this.inputWrapElm.classList.add("selection");
      this.inputElm = this.createElement("input", this.inputWrapElm);
      const disabled = this.getAttribute("enabled") === false;
      this.inputElm.disabled = disabled;
      this.readOnly = this.getAttribute("readOnly", true, false);
      this.inputElm.addEventListener("click", (e) => {
        if (this._readOnly || this._designMode)
          return false;
        this.openList();
        if (this.onClick)
          this.onClick(this, e);
      });
      this.inputElm.addEventListener("keyup", () => {
        if (this._readOnly || this._designMode)
          return false;
        this.searchStr = this.inputElm.value;
        this.renderItems();
      });
      this.inputWrapElm.appendChild(this.inputElm);
      placeholder && (this.placeholder = placeholder);
      this.iconElm = this.createElement("span", this);
      this.iconElm.classList.add("icon-btn");
      this.iconElm.addEventListener("click", () => {
        if (!this._enabled || this._readOnly || this._designMode)
          return false;
        this.toggleList();
      });
      let iconAttr = this.getAttribute("icon", true, {});
      iconAttr = { ...DEFAULT_VALUES8.icon, ...iconAttr };
      if ((_a = iconAttr == null ? void 0 : iconAttr.image) == null ? void 0 : _a.url) {
        iconAttr.name = "";
      }
      const icon = new Icon(void 0, iconAttr);
      this.icon = icon;
      this.selectedItem = this.getAttribute("selectedItem", true);
      this.listElm = this.createElement("div");
      this.listElm.classList.add(ItemListStyle);
      this.listElm.classList.add("item-list");
      this.renderItems();
      document.addEventListener("click", (e) => {
        if (!this._enabled)
          return false;
        if (!this.contains(e.target))
          this.closeList();
      });
      super.init();
      window.addEventListener("resize", this.calculatePositon);
    }
  }
  disconnectedCallback() {
    window.removeEventListener("resize", this.calculatePositon);
    super.disconnectedCallback();
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
ComboBox = __decorateClass([
  customElements2("i-combo-box", {
    icon: "tasks",
    group: GroupType.FIELDS,
    className: "ComboBox",
    props: {
      selectedItem: { type: "object" },
      items: {
        type: "array",
        default: []
      },
      icon: {
        type: "object",
        default: { name: "angle-down" }
      },
      mode: {
        type: "string",
        default: DEFAULT_VALUES8.mode
      },
      readOnly: {
        type: "boolean",
        default: DEFAULT_VALUES8.readOnly
      },
      placeholder: {
        type: "string",
        default: ""
      }
    },
    events: {
      onChanged: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "Event" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        items: {
          type: "array",
          items: {
            type: "object",
            required: ["value", "label"],
            properties: {
              value: {
                type: "string"
              },
              label: {
                type: "string"
              }
            }
          }
        },
        placeholder: {
          type: "string"
        },
        readOnly: {
          type: "boolean",
          default: DEFAULT_VALUES8.readOnly
        },
        mode: {
          type: "string",
          enum: ["single", "multiple", "tags"],
          default: DEFAULT_VALUES8.mode
        },
        icon: {
          type: "object",
          properties: {
            name: {
              type: "string",
              default: "angle-down"
            },
            fill: {
              type: "string"
            },
            width: {
              type: "number"
            },
            height: {
              type: "number"
            },
            image: {
              type: "object",
              properties: {
                url: {
                  type: "string"
                }
              }
            }
          }
        }
      }
    }
  })
], ComboBox);

// packages/datepicker/src/style/datepicker.css.ts
var Theme19 = theme_exports.ThemeVars;
cssRule("i-datepicker", {
  display: "inline-block",
  fontFamily: Theme19.typography.fontFamily,
  fontSize: Theme19.typography.fontSize,
  "$nest": {
    "*": {
      boxSizing: "border-box"
    },
    "> span": {
      overflow: "hidden"
    },
    "> span > label": {
      boxSizing: "border-box",
      color: Theme19.text.primary,
      display: "inline-block",
      overflow: "hidden",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      textAlign: "right",
      paddingRight: 4,
      height: "100%"
    },
    "> input": {
      borderRadius: "inherit",
      padding: "1px 0.5rem",
      border: `0.5px solid ${Theme19.divider}`,
      boxSizing: "border-box",
      outline: "none",
      fontSize: "inherit",
      color: Theme19.input.fontColor,
      background: "transparent",
      verticalAlign: "top",
      borderTopRightRadius: "0px !important",
      borderBottomRightRadius: "0px !important",
      borderRight: "none !important",
      height: "100%"
    },
    "> input[type=text]:focus": {
      borderColor: Theme19.colors.info.main
    },
    "i-icon": {
      fill: Theme19.colors.primary.contrastText
    },
    ".datepicker-toggle": {
      display: "inline-flex",
      position: "relative",
      backgroundColor: "transparent",
      border: `0.5px solid ${Theme19.divider}`,
      padding: "7px",
      marginLeft: "-1px",
      cursor: "pointer",
      justifyContent: "center",
      alignItems: "center",
      verticalAlign: "top",
      borderRadius: "inherit",
      borderTopLeftRadius: "0px !important",
      borderBottomLeftRadius: "0px !important",
      height: "100%"
    },
    "> .datepicker-toggle:hover": {
      backgroundColor: "#545b62"
    },
    ".datepicker": {
      position: "absolute",
      left: 0,
      top: 0,
      width: "100%",
      height: "100%",
      border: 0,
      padding: 0,
      opacity: 0,
      cursor: "pointer"
    },
    ".datepicker::-webkit-calendar-picker-indicator": {
      position: "absolute",
      left: 0,
      top: 0,
      width: "100%",
      height: "100%",
      margin: 0,
      padding: 0,
      cursor: "pointer"
    }
  }
});

// packages/datepicker/src/datepicker.ts
var defaultCaptionWidth = 40;
var DEFAULT_VALUES9 = {
  type: "date",
  captionWidth: 0
};
var Datepicker = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      height: 25,
      width: 100
    });
    this._onDatePickerChange = (event) => {
      const pickerValue = this.datepickerElm.value;
      if (!pickerValue) {
        this.inputElm.placeholder = this._placeholder || "";
        this.inputElm.value = "";
        if (this.onChanged)
          this.onChanged(this, event);
        return;
      }
      RequireJS.require(["@moment"], (moment2) => {
        let _moment = this._type === "time" ? moment2(pickerValue, "HH:mm:ss") : moment2(pickerValue);
        this.updateValue(_moment);
        if (this.onChanged)
          this.onChanged(this, event);
      });
    };
    this._onBlur = (event) => {
      if (this.onBlur) {
        this.onBlur(this);
      }
      if (!this.inputElm.value) {
        const oldVal = this.value;
        this.clear();
        const isChanged = oldVal !== this.value;
        if (event && isChanged && this.onChanged)
          this.onChanged(this, event);
        return;
      }
      ;
      RequireJS.require(["@moment"], (moment2) => {
        const temp = moment2(this.inputElm.value, this.formatString, true).format(this.datepickerFormat);
        const _moment = moment2(temp, this.datepickerFormat, true);
        this.updateValue(_moment, event);
      });
    };
  }
  _handleClick(event) {
    return super._handleClick(event, true);
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    this.labelElm.textContent = this._caption || "";
    if (!value)
      this.labelElm.style.display = "none";
    else
      this.labelElm.style.display = "";
  }
  get captionWidth() {
    return this.labelElm.offsetWidth;
  }
  set captionWidth(value) {
    this._captionWidth = value;
    this.setElementPosition(this.labelElm, "width", value);
    const width = this.width - this.captionWidth - (this._iconWidth || 0);
    this.inputElm.style.width = `${width}px`;
  }
  get height() {
    return this.offsetHeight;
  }
  set height(value) {
    this.setPosition("height", value);
  }
  get width() {
    return this.offsetWidth;
  }
  set width(value) {
    this.setPosition("width", value);
    const width = typeof this._width === "string" ? this._width : `${this._width}px`;
    let captionWidth = typeof this._captionWidth === "string" ? this._captionWidth : `${this._captionWidth}px`;
    if (!this._caption)
      captionWidth = "0px";
    const iconWidth = `${this._iconWidth || 0}px`;
    this.inputElm.style.width = `calc(${width} - ${captionWidth} - ${iconWidth} - ${this.border.width || "0px"})`;
  }
  set border(value) {
    super.border = value;
    if (this.border.width !== void 0)
      this.width = this._width;
    const hasBorderSide = this.border.bottom || this.border.top || this.border.left || this.border.right;
    if (hasBorderSide || this.border.style) {
      this.toggleElm && (this.toggleElm.style.borderStyle = "none");
      this.inputElm && (this.inputElm.style.borderStyle = "none");
    }
  }
  get border() {
    return super.border;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (value)
      this.updateValue(value);
    else
      this.clear();
  }
  get defaultDateTimeFormat() {
    switch (this._type) {
      case "date":
        return "DD/MM/YYYY";
      case "dateTime":
        return "DD/MM/YYYY HH:mm";
      case "time":
        return "HH:mm";
    }
  }
  get dateTimeFormat() {
    var _a;
    return (_a = this._dateTimeFormat) != null ? _a : "";
  }
  set dateTimeFormat(format) {
    this._dateTimeFormat = format != null ? format : "";
  }
  get datepickerFormat() {
    switch (this._type) {
      case "date":
        return "YYYY-MM-DD";
      case "dateTime":
        return "YYYY-MM-DDTHH:mm:ss";
      case "time":
        return "HH:mm:ss";
    }
  }
  get maxLength() {
    switch (this._type) {
      case "date":
        return 10;
      case "dateTime":
        return 16;
      case "time":
        return 5;
    }
  }
  get enabled() {
    return super.enabled;
  }
  set enabled(value) {
    super.enabled = value;
    this.inputElm.disabled = !value;
    this.datepickerElm.disabled = !value;
  }
  get placeholder() {
    var _a;
    return (_a = this._placeholder) != null ? _a : "";
  }
  set placeholder(value) {
    this._placeholder = value != null ? value : "";
    if (this.inputElm)
      this.inputElm.placeholder = this._placeholder;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
    if (this.toggleIconElm) {
      this.toggleIconElm.name = this._type === "time" ? "clock" : "calendar";
    }
    if (this.datepickerElm) {
      const inputType = this._type === "dateTime" ? "datetime-local" : this._type;
      this.datepickerElm.setAttribute("type", inputType);
    }
  }
  set designMode(value) {
    this._designMode = value;
    if (this.inputElm) {
      this.inputElm.readOnly = value;
    }
    if (this.datepickerElm) {
      this.datepickerElm.readOnly = value;
    }
  }
  get formatString() {
    return this.dateTimeFormat || this.defaultDateTimeFormat;
  }
  updateValue(value, event) {
    this.inputElm.placeholder = this._placeholder || "";
    const oldVal = this.value;
    if (value.isValid()) {
      this._value = value;
      this.inputElm.value = value.format(this.formatString);
      this.datepickerElm.value = value.format(this.datepickerFormat);
      if (this.callback)
        this.callback(this.inputElm.value);
    } else if (this.value) {
      this.inputElm.value = this.value.format(this.formatString);
      this.datepickerElm.value = this.value.format(this.datepickerFormat);
    }
    const isChanged = oldVal && this.value && !oldVal.isSame(this.value) || (!oldVal || !this.value);
    if (event && isChanged && this.onChanged)
      this.onChanged(this, event);
  }
  clear() {
    this._value = void 0;
    this.inputElm.value = "";
    this.datepickerElm.value = "";
    this.callback && this.callback("");
  }
  init() {
    if (!this.captionSpanElm) {
      RequireJS.config({
        paths: {
          "@moment": `${LibPath}lib/moment/2.29.1/moment.js`
        }
      });
      this.callback = this.getAttribute("parentCallback", true);
      this.dateTimeFormat = this.getAttribute("dateTimeFormat", true);
      this._type = this.getAttribute("type", true, DEFAULT_VALUES9.type);
      const height = this.getAttribute("height", true);
      this._iconWidth = typeof height === "number" ? height : +height.replace("px", "");
      this.captionSpanElm = this.createElement("span", this);
      this.labelElm = this.createElement("label", this.captionSpanElm);
      this.inputElm = this.createElement("input", this);
      this.inputElm.setAttribute("type", "text");
      this.inputElm.setAttribute("autocomplete", "disabled");
      this.inputElm.pattern = this.formatString;
      this.placeholder = this.getAttribute("placeholder", true);
      this.toggleElm = this.createElement("span", this);
      this.toggleElm.classList.add("datepicker-toggle");
      this.toggleElm.style.width = this._iconWidth + "px";
      this.toggleIconElm = new Icon(this, {
        name: this._type === "time" ? "clock" : "calendar",
        width: 12,
        height: 12,
        fill: theme_exports.ThemeVars.text.primary
      });
      this.toggleElm.appendChild(this.toggleIconElm);
      this.datepickerElm = this.createElement("input");
      const inputType = this._type === "dateTime" ? "datetime-local" : this._type;
      this.datepickerElm.setAttribute("type", inputType);
      this.datepickerElm.classList.add("datepicker");
      this.datepickerElm.addEventListener("input", (event) => {
        event.stopPropagation();
        this._onDatePickerChange(event);
      });
      this.toggleElm.appendChild(this.datepickerElm);
      this.caption = this.getAttribute("caption", true);
      this.captionWidth = this.getAttribute("captionWidth", true, this._caption ? defaultCaptionWidth : 0);
      super.init();
    }
  }
  _handleBlur(event, stopPropagation) {
    event.stopPropagation();
    event.preventDefault();
    this._onBlur(event);
    return true;
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Datepicker = __decorateClass([
  customElements2("i-datepicker", {
    icon: "calendar",
    group: GroupType.FIELDS,
    className: "Datepicker",
    props: {
      caption: { type: "string", default: "" },
      captionWidth: { type: "number", default: DEFAULT_VALUES9.captionWidth },
      value: { type: "object" },
      placeholder: { type: "string", default: "" },
      type: { type: "string", default: DEFAULT_VALUES9.type },
      dateTimeFormat: { type: "string", default: "" }
    },
    events: {
      onChanged: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "Event" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: ["date", "dateTime", "time"],
          default: DEFAULT_VALUES9.type
        },
        placeholder: {
          type: "string"
        },
        caption: {
          type: "string"
        },
        dateTimeFormat: {
          type: "string"
        }
      }
    }
  })
], Datepicker);

// packages/range/src/style/range.css.ts
var Theme20 = theme_exports.ThemeVars;
cssRule("i-range", {
  position: "relative",
  display: "inline-block",
  fontFamily: Theme20.typography.fontFamily,
  fontSize: Theme20.typography.fontSize,
  "$nest": {
    "*": {
      boxSizing: "border-box"
    },
    "> span": {
      overflow: "hidden"
    },
    "> span > label": {
      boxSizing: "border-box",
      color: Theme20.text.primary,
      display: "inline-block",
      overflow: "hidden",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      textAlign: "right",
      paddingRight: 4,
      height: "100%"
    },
    ".slider": {
      position: "relative",
      display: "inline-block"
    },
    'input[type="range"]': {
      "-webkit-appearance": "none",
      appearance: "none",
      background: "#d3d3d3",
      backgroundImage: `linear-gradient(var(--track-color, ${Theme20.colors.info.main}), var(--track-color, ${Theme20.colors.info.main}))`,
      backgroundSize: "0% 100%",
      backgroundRepeat: "no-repeat !important",
      borderRadius: "0.5rem",
      opacity: 0.7,
      border: 0,
      margin: 0,
      width: "inherit",
      boxSizing: "border-box",
      outline: "none",
      verticalAlign: "middle"
    },
    'input[type="range"]:not(:disabled)': {
      cursor: "pointer"
    },
    'input[type="range"]:hover': {
      opacity: 1
    },
    'input[type="range"]:focus': {
      outline: "none"
    },
    'input[type="range"]::-webkit-slider-runnable-track': {
      "-webkit-appearance": "none",
      boxShadow: "none",
      border: "none",
      background: "transparent",
      borderRadius: "0.5rem",
      height: "0.3rem",
      marginLeft: "-6.5px",
      marginRight: "-6.5px"
    },
    'input[type="range"]::-webkit-slider-thumb': {
      "-webkit-appearance": "none",
      appearance: "none",
      marginTop: "-5px",
      backgroundColor: `var(--track-color, ${Theme20.colors.info.main})`,
      borderRadius: "0.5rem",
      height: "1rem",
      width: "1rem"
    },
    ".range-labels": {
      display: "flex",
      justifyContent: "space-between",
      height: "auto",
      overflow: "hidden",
      listStyle: "none"
    },
    ".range-labels li": {
      padding: "0 0.25rem"
    },
    '&.--step input[type="range"]': {
      opacity: 1,
      $nest: {
        "&::-webkit-slider-runnable-track": {
          zIndex: 2
        },
        "&::-webkit-slider-thumb": {
          zIndex: 2
        }
      }
    },
    ".slider-step": {
      position: "absolute",
      zIndex: 0,
      top: 2,
      left: 0,
      right: 0,
      bottom: 0,
      display: "flex",
      justifyContent: "space-between",
      alignItems: "center",
      background: "transparent"
    },
    ".step-dot": {
      position: "relative",
      zIndex: 1,
      display: "flex",
      justifyContent: "center",
      width: "3px",
      height: "10px",
      backgroundColor: "#a7a9ac"
    },
    ".tooltip": {
      visibility: "hidden",
      minWidth: 35,
      maxWidth: 70,
      overflowWrap: "break-word",
      backgroundColor: "rgba(0, 0, 0, 0.78)",
      color: "#fff",
      textAlign: "center",
      borderRadius: "6px",
      padding: "8px",
      position: "absolute",
      zIndex: 1,
      bottom: "150%",
      left: "0%",
      marginLeft: "-20px",
      opacity: 0,
      transition: "opacity 0.3s",
      $nest: {
        "&::after": {
          content: "''",
          position: "absolute",
          top: "100%",
          left: "50%",
          marginLeft: "-5px",
          borderWidth: "5px",
          borderStyle: "solid",
          borderColor: "rgba(0, 0, 0, 0.78) transparent transparent transparent"
        }
      }
    },
    'input[type="range"]:hover + .tooltip': {
      visibility: "visible",
      opacity: 1
    }
  }
});

// packages/range/src/range.ts
var DEFAULT_VALUES10 = {
  captionWidth: 40,
  value: 0,
  min: 0,
  max: 100,
  step: 1,
  stepDots: false,
  tooltipVisible: false
};
var Range2 = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      height: 25,
      width: 100
    });
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    this.labelElm.textContent = this._caption || "";
    if (!value)
      this.labelElm.style.display = "none";
    else
      this.labelElm.style.display = "";
  }
  get captionWidth() {
    return this.labelElm.offsetWidth;
  }
  set captionWidth(value) {
    this._captionWidth = value;
    this.setElementPosition(this.labelElm, "width", value);
    const captionWidth = this.caption ? this.captionWidth : 0;
    const width = this.width - captionWidth;
    this.inputContainerElm.style.width = `${width}px`;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    if (value === null)
      value = +this.inputElm.min;
    this._value = value;
    this.inputElm.value = value.toString();
    const min = Number(this.inputElm.min);
    const max = Number(this.inputElm.max);
    this.inputElm.style.backgroundSize = (this._value - min) * 100 / (max - min) + "% 100%";
    this.onUpdateTooltip(false);
    if (this.callback)
      this.callback(value);
  }
  get width() {
    return this.offsetWidth;
  }
  set width(value) {
    this.setPosition("width", value);
    const width = typeof value === "string" ? value : `${value}px`;
    let captionWidth = typeof this._captionWidth === "string" ? this._captionWidth : `${this._captionWidth}px`;
    if (!this.caption)
      captionWidth = "0px";
    this.inputContainerElm.style.width = `calc(${width} - ${captionWidth})`;
  }
  get enabled() {
    return super.enabled;
  }
  set enabled(value) {
    super.enabled = value;
    this.inputElm.disabled = !value;
  }
  set designMode(value) {
    this._designMode = value;
    if (this.inputElm) {
      this.inputElm.disabled = value || this.enabled === false;
    }
  }
  get tooltipVisible() {
    return this._tooltipVisible;
  }
  set tooltipVisible(value) {
    this._tooltipVisible = value;
    this.tooltipElm.style.display = value ? "block" : "none";
  }
  get trackColor() {
    return this._trackColor;
  }
  set trackColor(value) {
    this._trackColor = value;
    if (value)
      this.style.setProperty("--track-color", value);
    else
      this.style.removeProperty("--track-color");
  }
  onSliderChange(event) {
    if (this._designMode) {
      event.preventDefault();
      return false;
    }
    this.value = +this.inputElm.value;
    const min = Number(this.inputElm.min);
    const max = Number(this.inputElm.max);
    this.inputElm.style.backgroundSize = (this._value - min) * 100 / (max - min) + "% 100%";
    if (typeof this.onChanged === "function")
      this.onChanged(this, event);
    this.onUpdateTooltip(false);
  }
  onUpdateTooltip(init) {
    let inputValue = this._value;
    let formattedValue = this.tooltipFormatter ? this.tooltipFormatter(inputValue) : inputValue;
    const min = Number(this.inputElm.min);
    const max = Number(this.inputElm.max);
    if (init) {
      this.tooltipElm.style.marginLeft = `-${this.tooltipElm.clientWidth / 2}px`;
    }
    this.tooltipElm.innerHTML = formattedValue;
    this.tooltipElm.style.left = (this._value - min) * 100 / (max - min) + "%";
  }
  init() {
    if (!this.captionSpanElm) {
      this.callback = this.getAttribute("parentCallback", true);
      const min = this.getAttribute("min", true, DEFAULT_VALUES10.min);
      const max = this.getAttribute("max", true, DEFAULT_VALUES10.max);
      const step = this.getAttribute("step", true, DEFAULT_VALUES10.step);
      const stepDots = this.getAttribute("stepDots", true, DEFAULT_VALUES10.stepDots);
      const tooltipVisible = this.getAttribute("tooltipVisible", true, DEFAULT_VALUES10.tooltipVisible);
      const formatter = this.getAttribute("tooltipFormatter", true) || this.tooltipFormatter;
      this.tooltipFormatter = formatter;
      this.captionSpanElm = this.createElement("span", this);
      this.labelElm = this.createElement("label", this.captionSpanElm);
      this.inputContainerElm = this.createElement("div", this);
      this.inputContainerElm.classList.add("slider");
      this.inputElm = this.createElement("input", this.inputContainerElm);
      this.inputElm.setAttribute("autocomplete", "disabled");
      this.inputElm.type = "range";
      this.inputElm.min = min;
      this.inputElm.max = max;
      this.inputElm.disabled = this._designMode || this.enabled === false;
      if (step !== 0) {
        this.inputElm.step = step;
      }
      this.inputElm.addEventListener("input", this.onSliderChange.bind(this));
      if (this.onMouseUp)
        this.inputElm.addEventListener("mouseup", (e) => {
          if (this._designMode) {
            e.preventDefault();
            return false;
          }
          this.onMouseUp(this, e);
        });
      if (this.onKeyUp)
        this.inputElm.addEventListener("keyup", (e) => {
          if (this._designMode) {
            e.preventDefault();
            return false;
          }
          const keys = ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "PageUp", "PageDown"];
          if (keys.includes(e.key))
            this.onKeyUp(this, e);
        });
      this.tooltipElm = this.createElement("span", this.inputContainerElm);
      this.tooltipElm.classList.add("tooltip");
      this.tooltipVisible = tooltipVisible || this.tooltipFormatter || false;
      this.captionWidth = this.getAttribute("captionWidth", true, DEFAULT_VALUES10.captionWidth);
      this.caption = this.getAttribute("caption", true);
      if (stepDots) {
        this.classList.add("--step");
        const stepContainer = this.createElement("div", this);
        stepContainer.classList.add("slider-step");
        stepContainer.style.width = "100%";
        if (this.caption) {
          stepContainer.style.paddingLeft = this.captionWidth + "px";
        }
        const dotNums = typeof stepDots === "boolean" ? (max - min) / (step || 1) + 1 : stepDots;
        for (let i = 0; i < dotNums; i++) {
          const dotElm = this.createElement("span", stepContainer);
          dotElm.classList.add("step-dot");
        }
      }
      this.value = this.getAttribute("value", true, DEFAULT_VALUES10.value);
      if (this._value > 0) {
        this.inputElm.style.backgroundSize = (this._value - min) * 100 / (max - min) + "% 100%";
      }
      const trackColor = this.getAttribute("trackColor", true);
      if (trackColor !== void 0)
        this.trackColor = trackColor;
      this.onUpdateTooltip(true);
      super.init();
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
__decorateClass([
  observable("value")
], Range2.prototype, "_value", 2);
Range2 = __decorateClass([
  customElements2("i-range", {
    icon: "sliders-h",
    group: GroupType.FIELDS,
    className: "Range",
    props: {
      caption: { type: "string", default: "" },
      captionWidth: { type: "number", default: DEFAULT_VALUES10.captionWidth },
      value: { type: "number", default: DEFAULT_VALUES10.value },
      min: { type: "number", default: DEFAULT_VALUES10.min },
      max: { type: "number", default: DEFAULT_VALUES10.max },
      step: { type: "number", default: DEFAULT_VALUES10.step },
      stepDots: { type: "boolean", default: DEFAULT_VALUES10.stepDots },
      tooltipVisible: { type: "boolean", default: DEFAULT_VALUES10.tooltipVisible },
      trackColor: { type: "string", default: "" }
    },
    events: {
      onChanged: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "Event" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        caption: { type: "string" },
        value: { type: "number", default: DEFAULT_VALUES10.value },
        min: { type: "number", default: DEFAULT_VALUES10.min },
        max: { type: "number", default: DEFAULT_VALUES10.max },
        step: { type: "number", default: DEFAULT_VALUES10.step },
        stepDots: { type: "boolean", default: DEFAULT_VALUES10.stepDots },
        tooltipVisible: { type: "boolean", default: DEFAULT_VALUES10.tooltipVisible },
        trackColor: { type: "string", format: "color" }
      }
    }
  })
], Range2);

// packages/radio/src/radio.css.ts
var Theme21 = theme_exports.ThemeVars;
cssRule("i-radio-group", {
  display: "inline-flex",
  alignItems: "start",
  gap: "5px",
  "$nest": {
    ".radio-wrapper": {
      display: "inline-flex",
      alignItems: "baseline",
      cursor: "pointer"
    },
    'input[type="radio"]': {
      cursor: "pointer"
    }
  }
});
var captionStyle = style({
  fontFamily: Theme21.typography.fontFamily,
  fontSize: "inherit",
  "$nest": {
    "span": {
      color: Theme21.text.primary
    }
  }
});

// packages/radio/src/radio.ts
var Radio = class extends Control {
  constructor(parent, options) {
    super(parent, options);
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value || "";
    this.inputElm.value = value;
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    if (!value)
      this.captionSpanElm.style.display = "none";
    else
      this.captionSpanElm.style.display = "";
    this.captionSpanElm && (this.captionSpanElm.textContent = value);
  }
  get captionWidth() {
    return this._captionWidth;
  }
  set captionWidth(value) {
    this._captionWidth = value;
    this.setElementPosition(this.captionSpanElm, "width", value);
  }
  set font(value) {
    if (!this.captionSpanElm)
      return;
    this.captionSpanElm.style.color = value.color || "";
    this.captionSpanElm.style.fontSize = value.size || "";
    this.captionSpanElm.style.fontFamily = value.name || "";
    this.captionSpanElm.style.fontStyle = value.style || "";
    this.captionSpanElm.style.textTransform = value.transform || "none";
    this.captionSpanElm.style.fontWeight = value.bold ? "bold" : `${value.weight || ""}`;
    this.captionSpanElm.style.textShadow = value.shadow || "none";
  }
  get font() {
    if (!this.captionSpanElm)
      return {};
    return {
      color: this.captionSpanElm.style.color,
      name: this.captionSpanElm.style.fontFamily,
      size: this.captionSpanElm.style.fontSize,
      bold: this.captionSpanElm.style.fontStyle.indexOf("bold") >= 0,
      style: this.captionSpanElm.style.fontStyle,
      transform: this.captionSpanElm.style.textTransform,
      weight: this.captionSpanElm.style.fontWeight,
      shadow: this.captionSpanElm.style.textShadow
    };
  }
  _handleClick(event) {
    if (this._designMode) {
      event.preventDefault();
      return false;
    }
    if (event.target !== this.inputElm)
      return true;
    const checked = this.inputElm.checked || false;
    if (checked)
      this.classList.add("is-checked");
    else
      this.classList.remove("is-checked");
    return super._handleClick(event);
  }
  init() {
    if (!this.initialized) {
      super.init();
      this.classList.add(captionStyle);
      this.labelElm = this.createElement("label", this);
      this.labelElm.classList.add("radio-wrapper");
      this.inputElm = this.createElement("input", this.labelElm);
      this.inputElm.type = "radio";
      const disabled = this.getAttribute("enabled") === false;
      this.inputElm.disabled = disabled;
      this.value = this.getAttribute("value");
      this.captionSpanElm = this.createElement("span", this.labelElm);
      this.captionSpanElm.classList.add("i-radio_label");
      this.caption = this.getAttribute("caption", true, "");
      this.captionWidth = this.getAttribute("captionWidth", true);
      const font = this.getAttribute("font", true);
      if (font)
        this.font = font;
      else
        this.labelElm.style.color = theme_exports.ThemeVars.text.primary;
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
__decorateClass([
  observable("value")
], Radio.prototype, "_value", 2);
Radio = __decorateClass([
  customElements2("i-radio")
], Radio);
var RadioGroup = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._radioItems = [];
    this._group = [];
  }
  get selectedValue() {
    return this._selectedValue;
  }
  set selectedValue(value) {
    this._selectedValue = value;
    this._group.forEach((item) => {
      const inputElm = item.querySelector("input");
      if (inputElm)
        inputElm.checked = item.value === value;
      if (item.value === value) {
        item.classList.add("is-checked");
      } else {
        item.classList.remove("is-checked");
      }
    });
  }
  get radioItems() {
    return this._radioItems;
  }
  set radioItems(value) {
    this._radioItems = value;
    this.renderUI();
  }
  get layout() {
    return this._layout;
  }
  set layout(value) {
    this._layout = value || "vertical";
    if (value === "horizontal") {
      this.style.flexDirection = "row";
    } else {
      this.style.flexDirection = "column";
    }
  }
  renderUI() {
    this.clearInnerHTML();
    this._group = [];
    this.name = new Date().getTime().toString();
    this.radioItems.forEach((item) => {
      const elm = new Radio(this, item);
      this.appendItem(elm);
    });
  }
  appendItem(elm) {
    this.appendChild(elm);
    elm.onClick = this._handleChange.bind(this);
    const inputElm = elm.getElementsByTagName("input")[0];
    inputElm && inputElm.setAttribute("name", this.name);
    if (this.selectedValue && elm.value === this.selectedValue)
      inputElm.checked = true;
    this._group.push(elm);
  }
  _handleChange(source, event) {
    if (this._designMode) {
      event.preventDefault();
      return true;
    }
    event.stopPropagation();
    const selectedValue = this.selectedValue;
    const value = source.value;
    this._selectedValue = value;
    this._group.forEach((item) => item.classList.remove("is-checked"));
    source.classList.add("is-checked");
    if (typeof this.onChanged === "function" && selectedValue !== value)
      this.onChanged(this, event);
  }
  add(options) {
    const elm = new Radio(this, options);
    this.appendItem(elm);
    this._radioItems.push(options);
    return elm;
  }
  delete(index) {
    if (index >= 0) {
      const radio = this._group[index];
      if (radio) {
        this._group.splice(index, 1);
        this._radioItems.splice(index, 1);
        radio.remove();
      }
    }
  }
  init() {
    var _a;
    if (!this.initialized) {
      this.setAttribute("role", "radiogroup");
      if ((_a = this.options) == null ? void 0 : _a.onChanged)
        this.onChanged = this.options.onChanged;
      setAttributeToProperty(this, "radioItems");
      setAttributeToProperty(this, "selectedValue");
      setAttributeToProperty(this, "layout", "vertical");
      super.init();
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
__decorateClass([
  observable("selectedValue")
], RadioGroup.prototype, "_selectedValue", 2);
RadioGroup = __decorateClass([
  customElements2("i-radio-group", {
    icon: "check-circle",
    className: "RadioGroup",
    group: GroupType.FIELDS,
    props: {
      layout: {
        type: "string",
        default: "vertical"
      },
      selectedValue: { type: "string", default: "" },
      radioItems: { type: "array", default: [] }
    },
    events: {
      onChanged: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "Event" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        layout: {
          type: "string",
          enum: ["vertical", "horizontal"],
          default: "vertical"
        },
        radioItems: {
          type: "array",
          items: {
            type: "object",
            properties: {
              caption: { type: "string" },
              value: { type: "string" }
            }
          }
        }
      }
    }
  })
], RadioGroup);

// packages/color/src/utils.ts
function stringToArr(color, isRgb) {
  const formatted = isRgb ? color.replace(/^rgba?\(|\)$/g, "") : color.replace(/^hsla?\(|\)$/g, "");
  const separator = formatted.includes(",") ? "," : " ";
  let rgba = formatted.split(separator);
  if (rgba.includes("/"))
    rgba.splice(3, 1);
  if (!isRgb)
    return rgba;
  for (let R in rgba) {
    const r = rgba[R];
    if (r.includes("%")) {
      const p = +r.substr(0, r.length - 1) / 100;
      if (+R < 3) {
        rgba[R] = Math.round(p * 255).toString();
      } else {
        rgba[R] = p.toString();
      }
    }
  }
  return rgba;
}
function hslaToHex(h, s, l, a) {
  const { r, g, b } = hslaToRgba(h, s, l);
  return rgbToHex([
    r.toString(),
    g.toString(),
    b.toString(),
    a.toString()
  ]);
}
function rgbToHex(rgba) {
  let r = (+rgba[0]).toString(16);
  let g = (+rgba[1]).toString(16);
  let b = (+rgba[2]).toString(16);
  if (r.length === 1)
    r = "0" + r;
  if (g.length === 1)
    g = "0" + g;
  if (b.length === 1)
    b = "0" + b;
  let a = "";
  if (rgba[3]) {
    a = Math.round(+rgba[3] * 255).toString(16);
    if (a.length === 1)
      a = "0" + a;
  }
  return "#" + r + g + b + a;
}
function hslaToRgba(h, s, l) {
  h = h % 360;
  s = s / 100;
  l = l / 100;
  const chroma = (1 - Math.abs(2 * l - 1)) * s;
  const hueSegment = h / 60;
  const x = chroma * (1 - Math.abs(hueSegment % 2 - 1));
  let r, g, b;
  if (hueSegment >= 0 && hueSegment < 1) {
    r = chroma;
    g = x;
    b = 0;
  } else if (hueSegment >= 1 && hueSegment < 2) {
    r = x;
    g = chroma;
    b = 0;
  } else if (hueSegment >= 2 && hueSegment < 3) {
    r = 0;
    g = chroma;
    b = x;
  } else if (hueSegment >= 3 && hueSegment < 4) {
    r = 0;
    g = x;
    b = chroma;
  } else if (hueSegment >= 4 && hueSegment < 5) {
    r = x;
    g = 0;
    b = chroma;
  } else {
    r = chroma;
    g = 0;
    b = x;
  }
  const lightnessAdjustment = l - chroma / 2;
  r += lightnessAdjustment;
  g += lightnessAdjustment;
  b += lightnessAdjustment;
  r = Math.round(r * 255);
  g = Math.round(g * 255);
  b = Math.round(b * 255);
  return { r, g, b };
}
function rgbaToHsla(r, g, b) {
  r = r < 0 ? 0 : r > 255 ? 255 : r;
  g = g < 0 ? 0 : g > 255 ? 255 : g;
  b = b < 0 ? 0 : b > 255 ? 255 : b;
  r = r / 255;
  g = g / 255;
  b = b / 255;
  let min = Math.min(r, g, b);
  let max = Math.max(r, g, b);
  let delta = max - min;
  let h = 0;
  let s;
  let l;
  if (max == min) {
    h = 0;
  } else if (r == max) {
    h = (g - b) / delta;
  } else if (g == max) {
    h = 2 + (b - r) / delta;
  } else if (b == max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0)
    h += 360;
  l = (min + max) / 2;
  if (max == min)
    s = 0;
  else if (l <= 0.5)
    s = delta / (max + min);
  else
    s = delta / (2 - max - min);
  return {
    h: Math.round(h),
    s: Math.round(s * 100),
    l: Math.round(l * 100)
  };
}
function getUnitValues(h, s, l, a) {
  return {
    h,
    s,
    l,
    a,
    ...hslaToRgba(h, s, l),
    hex: hslaToHex(h, s, l, a),
    isValid: true
  };
}
function getRgba(h) {
  let r = 0;
  let g = 0;
  let b = 0;
  let a = 1;
  if (h.length === 4 || h.length === 5) {
    r = "0x" + h[1] + h[1];
    g = "0x" + h[2] + h[2];
    b = "0x" + h[3] + h[3];
    if (h.length === 5)
      a = "0x" + h[4] + h[4];
  } else if (h.length === 7 || h.length == 9) {
    r = "0x" + h[1] + h[2];
    g = "0x" + h[3] + h[4];
    b = "0x" + h[5] + h[6];
    if (h.length === 9)
      a = "0x" + h[7] + h[8];
  }
  if (a !== 1)
    a = +(a / 255).toFixed(3);
  return { r: +r, g: +g, b: +b, a };
}
function convertColor(color) {
  var _a, _b, _c;
  let result = {};
  if (/^rgb/.test(color)) {
    const rgb2 = stringToArr(color, true);
    const r = Number(rgb2[0]);
    const g = Number(rgb2[1]);
    const b = Number(rgb2[2]);
    const a = Number((_a = rgb2[3]) != null ? _a : 1);
    result = {
      r,
      g,
      b,
      a,
      hex: rgbToHex(rgb2),
      ...rgbaToHsla(r, g, b)
    };
  } else if (/^#/i.test(color)) {
    if (!isHexColorValid(color))
      return { isValid: false, hex: color };
    const { r, g, b, a } = getRgba(color);
    result = {
      hex: color,
      r,
      g,
      b,
      a,
      ...rgbaToHsla(r, g, b)
    };
  } else if (/^hsl/i.test(color)) {
    const hsla = stringToArr(color, false);
    const h = Number((_b = hsla[0]) != null ? _b : 0);
    const s = Number((hsla[1] || "").replace("%", ""));
    const l = Number((hsla[2] || "").replace("%", ""));
    const a = Number((_c = hsla[3]) != null ? _c : 1);
    result = {
      h,
      s,
      l,
      a,
      hex: hslaToHex(h, s, l, a),
      ...hslaToRgba(h, s, l)
    };
  }
  return { ...result, isValid: true };
}
function isHexColorValid(color) {
  const hexRegex = /^#([A-Fa-f0-9]{3,4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/i;
  return hexRegex.test(color);
}
function isRgbValid(value) {
  const regex = /^[0-9]{1,3}$/i;
  return regex.test(value) && +value >= 0 && +value <= 255;
}
function isHValid(value) {
  const regex = /^[0-9]{1,3}$/i;
  return regex.test(value) && +value >= 0 && +value <= 360;
}
function isPercentValid(value) {
  const regex = /^(\d\d?(\.\d+)?|\.\d+|100)%$/i;
  return regex.test(value);
}
function hsvToHsl(h, s, v) {
  const _h = h;
  const _s = s / 100;
  const _v = v / 100;
  const r = Math.max(_v, 0.01);
  let o;
  let _l = (2 - _s) * _v / 2;
  const lmin = (2 - _s) * r;
  o = _s * r;
  o /= lmin <= 1 ? lmin : 2 - lmin;
  o = o || 0;
  return {
    h: Math.round(_h),
    s: Math.round(o * 100),
    l: Math.round(_l * 100)
  };
}
function hslToHsv(h, s, l) {
  const _h = h;
  let _s = s / 100;
  let _l = l / 100;
  const r = Math.max(_l, 0.01);
  let smin = _s;
  _l *= 2;
  _s *= _l <= 1 ? _l : 2 - _l;
  smin *= r <= 1 ? r : 2 - r;
  return {
    h: Math.round(_h),
    s: Math.round((_l === 0 ? 2 * smin / (r + smin) : 2 * _s / (_l + _s)) * 100),
    v: Math.round((_l + _s) / 2 * 100)
  };
}

// packages/color/src/style/color.css.ts
var Theme22 = theme_exports.ThemeVars;
var gradient = "linear-gradient(to right, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)";
var opacity = `var(--opacity-color, linear-gradient(to right, rgba(0, 0, 0, 0) 0%, rgb(0, 0, 0) 100%))`;
cssRule("i-color", {
  $nest: {
    ".i-color": {
      minHeight: 25,
      height: "100%",
      position: "relative",
      display: "inline-flex",
      alignItems: "center"
    },
    ".input-span": {
      height: "100%",
      minWidth: 100,
      display: "inline-flex",
      alignItems: "center",
      border: `1px solid ${Theme22.divider}`,
      padding: 4,
      $nest: {
        "span": {
          background: "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=) #fff",
          height: "100%",
          width: "100%",
          minHeight: 12,
          display: "inline-block"
        }
      }
    },
    ".color-picker-modal": {
      $nest: {
        ".custom-range": {
          $nest: {
            'input[type="range"]::-webkit-slider-thumb': {
              backgroundColor: "rgb(248, 248, 248)",
              width: 12,
              height: 12,
              marginTop: -3,
              boxShadow: "rgba(0, 0, 0, 0.37) 0px 1px 4px 0px"
            },
            'input[type="range"]': {
              borderRadius: 2,
              opacity: 1,
              height: 7
            },
            'input[type="range"]::-webkit-slider-runnable-track': {
              borderRadius: 2,
              opacity: 1,
              height: 7,
              marginLeft: -7,
              marginRight: -7
            }
          }
        },
        ".color-palette": {
          $nest: {
            'input[type="range"]': {
              backgroundImage: gradient
            },
            'input[type="range"]::-webkit-slider-runnable-track': {
              background: gradient
            }
          }
        },
        ".color-slider": {
          $nest: {
            'input[type="range"]': {
              backgroundImage: opacity,
              background: `url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=") left center, ${opacity}`
            },
            'input[type="range"]::-webkit-slider-runnable-track': {
              background: `url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=") left center, var(--opacity-color)`
            }
          }
        },
        ".pnl-select": {
          "boxShadow": "rgba(0, 0, 0, 0.3) 0px 0px 2px, rgba(0, 0, 0, 0.3) 0px 4px 8px"
        },
        ".color-picker": {
          justifyContent: "center",
          alignItems: "center"
        },
        ".color-input-group": {
          width: 165,
          display: "flex",
          gap: "2px",
          flex: "1"
        },
        ".color-input": {
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          gap: 12,
          $nest: {
            "input": {
              fontSize: 11,
              width: "100%",
              borderRadius: 2,
              border: "none",
              boxShadow: "rgb(218, 218, 218) 0px 0px 0px 1px inset",
              height: 20,
              textAlign: "center",
              letterSpacing: 1.5
            },
            "span": {
              fontSize: 11
            }
          }
        },
        ".selected-color": {
          position: "relative",
          width: 24,
          height: 24,
          borderRadius: "50%",
          boxShadow: "rgba(0, 0, 0, 0.1) 0px 0px 0px 1px inset",
          background: `url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=") left center`,
          overflow: "hidden",
          $nest: {
            "i-panel": {
              backgroundColor: "var(--selected-color)"
            }
          }
        },
        ".color-preview": {
          userSelect: "none",
          touchAction: "none",
          $nest: {
            "> i-panel": {
              width: "100%",
              height: "100%",
              position: "absolute",
              inset: "0px",
              background: "linear-gradient(to right, rgb(255, 255, 255), rgba(255, 255, 255, 0))",
              $nest: {
                "> i-panel": {
                  width: "100%",
                  height: "100%",
                  position: "absolute",
                  inset: "0px",
                  background: "linear-gradient(to top, rgb(0, 0, 0), rgba(0, 0, 0, 0))"
                }
              }
            },
            "#iconPointer": {
              width: 12,
              height: 12,
              borderRadius: "50%",
              boxShadow: "rgb(255, 255, 255) 0px 0px 0px 1.25px",
              transform: "translate(-6px, -6px)",
              position: "absolute",
              cursor: "default",
              top: 0,
              left: 0,
              $nest: {
                "&::before": {
                  width: 12,
                  height: 12,
                  content: '""',
                  position: "absolute",
                  borderRadius: "50%",
                  boxShadow: "rgb(128, 128, 128) 0px 0px 0px 0.75px inset"
                }
              }
            }
          }
        },
        "i-icon svg": {
          fill: "inherit"
        },
        ".modal": {
          paddingBlock: 0,
          backgroundColor: "transparent"
        }
      }
    }
  }
});

// packages/color/src/color.ts
var Theme23 = theme_exports.ThemeVars;
var rgb = ["r", "g", "b", "a"];
var hsl = ["h", "s", "l", "a"];
var hex = ["hex"];
var formatList = ["hex", "rgb", "hsl"];
var formatMap = { hex, rgb, hsl };
var DEFAULT_COLOR = "#000";
var DEFAULT_BG_COLOR = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAADFJREFUOE9jZGBgEGHAD97gk2YcNYBhmIQBgWSAP52AwoAQwJvQRg1gACckQoC2gQgAIF8IscwEtKYAAAAASUVORK5CYII=) #fff";
var ColorPicker = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._format = 0;
    this.inputMap = new Map();
    this.currentH = 0;
    this.currentColor = {
      h: 0,
      s: 0,
      l: 0,
      r: 0,
      g: 0,
      b: 0,
      a: 1,
      hex: DEFAULT_COLOR
    };
    this.currentPalette = "rgb(255, 0, 0)";
  }
  get value() {
    var _a;
    return ((_a = this.currentColor) == null ? void 0 : _a.hex) || "";
  }
  set value(color) {
    const data = convertColor(color);
    if (data.isValid)
      this.currentColor = { ...data };
    this.updateUI(true);
    this.updateIconPointer();
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    if (!value)
      this.captionSpanElm.style.display = "none";
    else
      this.captionSpanElm.style.display = "";
    this.captionSpanElm && (this.captionSpanElm.innerHTML = value);
  }
  get captionWidth() {
    return this._captionWidth;
  }
  set captionWidth(value) {
    if (!value)
      return;
    this._captionWidth = value;
    this.setElementPosition(this.captionSpanElm, "width", value);
  }
  get height() {
    return this.offsetHeight;
  }
  set height(value) {
    this.setPosition("height", value);
  }
  async init() {
    if (!this.wrapperElm) {
      super.init();
      this.onChanged = this.getAttribute("onChanged", true) || this.onChanged;
      this.onClosed = this.getAttribute("onClosed", true) || this.onClosed;
      this.handleMouseUp = this.handleMouseUp.bind(this);
      this.handleMouseMove = this.handleMouseMove.bind(this);
      this.wrapperElm = this.createElement("div", this);
      this.wrapperElm.classList.add("i-color");
      this.captionSpanElm = this.createElement("span", this.wrapperElm);
      this.captionWidth = this.getAttribute("captionWidth", true);
      this.caption = this.getAttribute("caption", true);
      this.mdColorPicker = await Modal.create({
        popupPlacement: "bottomLeft",
        closeOnBackdropClick: true,
        width: "auto",
        minWidth: 230,
        showBackdrop: false,
        onClose: this.onClosePicker.bind(this)
      });
      this.mdColorPicker.onOpen = this.onOpenPicker.bind(this);
      this.mdColorPicker.classList.add("color-picker-modal");
      this.wrapperElm.appendChild(this.mdColorPicker);
      const item = await Panel.create();
      item.classList.add("pnl-select");
      await this.createPreview();
      item.appendChild(this.pnlShown);
      this.pnlWrap = await Panel.create({
        padding: { top: "1rem", left: "1rem", right: "1rem", bottom: "0.75rem" },
        width: "100%",
        background: { color: "#fff" }
      });
      item.appendChild(this.pnlWrap);
      this.mdColorPicker.item = item;
      await this.createPicker();
      const valueElm = this.createElement("span", this.wrapperElm);
      valueElm.classList.add("input-span");
      valueElm.addEventListener("click", () => {
        if (!this.enabled || this._designMode)
          return;
        const isVisible = this.mdColorPicker.visible;
        if (!isVisible) {
          this.updateIconPointer();
        }
        this.mdColorPicker.visible = !this.mdColorPicker.visible;
      });
      this.inputSpanElm = this.createElement("span", valueElm);
      this.inputSpanElm.style.background = this.value || DEFAULT_BG_COLOR;
      const value = this.getAttribute("value", true);
      if (value !== void 0)
        this.value = value;
    }
  }
  onOpenPicker() {
    document.addEventListener("mouseup", this.handleMouseUp);
    document.addEventListener("mousemove", this.handleMouseMove);
  }
  onClosePicker() {
    if (typeof this.onClosed === "function")
      this.onClosed();
    if (this.inputSpanElm)
      this.inputSpanElm.style.background = this.value || DEFAULT_BG_COLOR;
    this.isMousePressed = false;
    document.removeEventListener("mouseup", this.handleMouseUp);
    document.removeEventListener("mousemove", this.handleMouseMove);
  }
  createInputGroup() {
    let wrapElm = this.pnlInput.querySelector(".color-input-group");
    if (!wrapElm) {
      wrapElm = this.createElement("div", this.pnlInput);
      wrapElm.classList.add("color-input-group");
    }
    wrapElm.innerHTML = "";
    const formatType = formatList[this._format] || "";
    const list = formatMap[formatType];
    for (let item of list) {
      const inputWrap = this.createElement("div", wrapElm);
      inputWrap.classList.add("color-input");
      const input = this.createElement("input", inputWrap);
      let value = this.currentColor[item];
      if (item === "s" || item === "l")
        value = (value != null ? value : "") + "%";
      input.value = value !== void 0 ? value : item === "a" ? "1" : "";
      input.addEventListener("input", (event) => this.onInputChanged(event, item));
      this.inputMap.set(item, input);
      const span = this.createElement("span", inputWrap);
      span.style.textTransform = "uppercase";
      span.style.color = "#222";
      span.innerHTML = item;
    }
  }
  async createPreview() {
    this.pnlShown = await Panel.create({
      height: 136,
      width: "100%",
      minWidth: 232,
      overflow: "hidden",
      background: { color: this.currentPalette || "" }
    });
    this.pnlShown.innerHTML = `
      <i-panel>
        <i-panel>
          <i-panel id="iconPointer"></i-panel>
        </i-panel>
      </i-panel>
    `;
    this.pnlShown.classList.add("color-preview");
    this.pnlShown.onClick = this.onColorSelected.bind(this);
  }
  _handleMouseDown(event) {
    const target = event.target;
    this.isMousePressed = this.pnlShown.contains(target);
    return false;
  }
  handleMouseMove(event) {
    if (this.isMousePressed) {
      this.onColorSelected(this.pnlShown, event);
    }
  }
  handleMouseUp(event) {
    this.isMousePressed = false;
  }
  async createPicker() {
    const picker = await GridLayout.create({
      gap: { column: "0.5rem", row: "0.5rem" },
      templateAreas: [["picker", "selected", "palette"], ["picker", "selected", "slider"]],
      templateColumns: ["14px", "30px", "120px"],
      margin: { bottom: "1rem" }
    });
    picker.classList.add("color-picker");
    const pickerIcon = await Icon.create({
      name: "eye-dropper",
      width: 13,
      height: 13,
      fill: "#222"
    });
    pickerIcon.style.gridArea = "picker";
    pickerIcon.onClick = () => this.activeEyeDropper(pickerIcon);
    const colorSelectedWrapper = await Panel.create();
    colorSelectedWrapper.classList.add("selected-color");
    colorSelectedWrapper.style.gridArea = "selected";
    this.colorSelected = await Panel.create({
      position: "absolute",
      width: "100%",
      height: "100%"
    });
    const { h, s, l, a, r = 0, g = 0, b = 0 } = this.currentColor;
    let paletteValue = h || 0;
    paletteValue = paletteValue > 360 ? 360 : paletteValue;
    colorSelectedWrapper.appendChild(this.colorSelected);
    this.colorPalette = await Range2.create({
      width: "100%",
      height: 10,
      min: 0,
      max: 360,
      step: 1,
      value: paletteValue
    });
    this.colorPalette.onChanged = this.onPaletteChanged.bind(this);
    this.colorPalette.classList.add("custom-range", "color-palette");
    this.colorPalette.style.gridArea = "palette";
    this.mdColorPicker.style.setProperty("--opacity-color", `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgb(${r}, ${g}, ${b}) 100%)`);
    if (h !== void 0) {
      this.mdColorPicker.style.setProperty("--selected-color", `hsla(${h}, ${s}%, ${l}%, ${a})`);
    }
    this.colorSlider = await Range2.create({
      width: "100%",
      height: 10,
      min: 0,
      max: 1,
      value: a != null ? a : 1,
      step: 0.01
    });
    this.colorSlider.onChanged = this.onSliderChanged.bind(this);
    this.colorSlider.classList.add("custom-range", "color-slider");
    this.colorSlider.style.gridArea = "slider";
    picker.append(pickerIcon, colorSelectedWrapper, this.colorPalette, this.colorSlider);
    this.pnlInput = await HStack.create({
      alignItems: "center",
      gap: "0.5rem"
    });
    this.createInputGroup();
    const icons = await VStack.create({
      justifyContent: "center",
      alignItems: "center",
      maxHeight: 50
    });
    const topIcon = await Icon.create({
      name: "angle-up",
      fill: "#000",
      width: 16,
      height: 16
    });
    topIcon.classList.add("pointer");
    topIcon.onClick = () => this.onToggleFormat(-1);
    const bottomIcon = await Icon.create({
      name: "angle-down",
      fill: "#000",
      width: 16,
      height: 16
    });
    bottomIcon.classList.add("pointer");
    bottomIcon.onClick = () => this.onToggleFormat(1);
    icons.append(topIcon, bottomIcon);
    this.pnlInput.appendChild(icons);
    this.pnlWrap.append(picker, this.pnlInput);
  }
  activeEyeDropper(pickerIcon) {
    pickerIcon.fill = Theme23.colors.primary.main;
    const hasSupport = () => Boolean("EyeDropper" in window);
    if (hasSupport()) {
      const eyeDropper = new window.EyeDropper();
      eyeDropper.open().then((result) => {
        this.value = result.sRGBHex;
        pickerIcon.fill = "#222";
      }).catch((e) => {
        pickerIcon.fill = "#222";
      });
    } else {
      console.warn("No Support: This browser does not support the EyeDropper API yet!");
    }
  }
  onPaletteChanged() {
    const value = this.colorPalette.value;
    this.setPalette(value);
    if (this.currentPalette) {
      this.pnlShown.background = { color: this.currentPalette };
      const rgbArr = stringToArr(this.currentPalette, true);
      if (this.mdColorPicker)
        this.mdColorPicker.style.setProperty("--opacity-color", `linear-gradient(to right, rgba(${rgbArr[0]}, ${rgbArr[1]}, ${rgbArr[2]}, 0) 0%, ${this.currentPalette} 100%)`);
      const { s, l } = this.currentColor;
      this.updateColor(this.currentH, s, l);
    }
  }
  onSliderChanged() {
    this.currentColor.a = this.colorSlider.value;
    this.updateHex();
    this.updateUI();
  }
  onToggleFormat(value) {
    const maxLength = formatList.length;
    this._format = ((this._format + value) % maxLength + maxLength) % maxLength;
    this.createInputGroup();
  }
  updateIconPointer() {
    if (this.pnlShown) {
      const iconPointer = this.pnlShown.querySelector("#iconPointer");
      if (iconPointer) {
        const { h, s, l } = this.currentColor;
        const hsv = hslToHsv(h, s, l);
        const paletteWidth = this.pnlShown.offsetWidth;
        const paletteHeight = this.pnlShown.offsetHeight;
        const x = hsv.s * paletteWidth / 100 | 0;
        const y = paletteHeight - hsv.v * paletteHeight / 100 | 0;
        iconPointer.style.left = `${x}px`;
        iconPointer.style.top = `${y}px`;
      }
    }
  }
  onColorSelected(target, event) {
    const rect = target.getBoundingClientRect();
    let x = 160;
    let y = 60;
    if (event) {
      x = event.clientX < rect.left ? 0 : event.clientX > rect.right ? rect.width : event.clientX - rect.left;
      y = event.clientY < rect.top ? 0 : event.clientY > rect.bottom ? rect.height : event.clientY - rect.top;
    }
    const iconPointer = target.querySelector("#iconPointer");
    if (iconPointer) {
      iconPointer.style.top = `${y}px`;
      iconPointer.style.left = `${x}px`;
    }
    const paletteWidth = target.offsetWidth;
    const paletteHeight = target.offsetHeight;
    const hue = this.currentH;
    const saturation = x * 100 / paletteWidth | 0;
    const value = 100 - y * 100 / paletteHeight | 0;
    const hsl2 = hsvToHsl(hue, saturation, value);
    this.updateColor(hsl2.h, hsl2.s, hsl2.l);
  }
  updateColor(h, s, l) {
    const a = this.colorSlider.value;
    const data = getUnitValues(h, s, l, a);
    if (data.isValid)
      this.updateCurrentColor(data);
  }
  updateCurrentColor(data, init = false) {
    if (data)
      this.currentColor = { ...data };
    this.updateUI(init);
    if (typeof this.onChanged === "function")
      this.onChanged(this, this.value);
  }
  updateHex() {
    const { h = 0, s = 0, l = 0, a } = this.currentColor;
    this.currentColor.hex = hslaToHex(h, s, l, a);
  }
  updateUI(init) {
    if (init)
      this.initUI();
    for (let unit in this.currentColor) {
      const input = this.inputMap.get(unit);
      if (!input)
        continue;
      const hasSuffix = unit === "s" || unit === "l";
      input.value = `${this.currentColor[unit]}${hasSuffix ? "%" : ""}`;
    }
    const { h = 0, s = 0, l = 0, a = 1, r = 0, g = 0, b = 0, hex: hex2 = "" } = this.currentColor;
    if (this.mdColorPicker) {
      this.mdColorPicker.style.setProperty("--selected-color", `hsla(${h}, ${s}%, ${l}%, ${a})`);
      this.mdColorPicker.style.setProperty("--opacity-color", `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgb(${r}, ${g}, ${b}) 100%)`);
    }
    const hexInput = this.inputMap.get("hex");
    if (hexInput)
      hexInput.value = hex2 || "";
    if (this.inputSpanElm)
      this.inputSpanElm.style.background = this.value || DEFAULT_COLOR;
  }
  initUI() {
    const { h, a } = this.currentColor || {};
    let paletteValue = h || 0;
    paletteValue = paletteValue > 360 ? 360 : paletteValue;
    this.setPalette(paletteValue);
    if (this.colorPalette)
      this.colorPalette.value = paletteValue;
    if (this.colorSlider)
      this.colorSlider.value = a != null ? a : 1;
    if (this.pnlShown) {
      this.pnlShown.background = { color: this.currentPalette || "" };
    }
  }
  setPalette(paletteValue) {
    this.currentH = paletteValue;
    const { r, g, b } = hslaToRgba(paletteValue, 100, 50);
    this.currentPalette = `rgb(${r}, ${g}, ${b})`;
  }
  onInputChanged(event, item) {
    const value = event.target.value;
    let currentColor = { ...this.currentColor };
    let isRgbChanged = false;
    let isHslChanged = false;
    let isAChanged = false;
    switch (item) {
      case "hex":
        const data = convertColor(value);
        if (data.isValid) {
          this.updateCurrentColor(data, true);
          this.updateIconPointer();
        }
        break;
      case "r":
      case "g":
      case "b":
        const isValid = isRgbValid(value);
        currentColor[item] = isValid ? value : 255;
        isRgbChanged = true;
        break;
      case "h":
        const hValid = isHValid(value);
        currentColor[item] = hValid ? value : 0;
        isHslChanged = true;
        break;
      case "s":
      case "l":
        if (!value.includes("%"))
          return;
        const sValid = isPercentValid(value);
        if (sValid) {
          currentColor[item] = value.replace("%", "");
          isHslChanged = true;
        }
        break;
      case "a":
        if (value === "0.")
          return;
        let numValue = +value;
        const aValid = !isNaN(numValue);
        if (!aValid)
          numValue = 0;
        currentColor[item] = numValue < 0 ? 0 : numValue > 1 ? 1 : numValue;
        isAChanged = true;
        break;
    }
    if (item === "hex")
      return;
    const { r, g, b, h, s, l } = currentColor;
    if (isRgbChanged) {
      const { h: h2, s: s2, l: l2 } = rgbaToHsla(r, g, b);
      currentColor = { ...currentColor, h: h2, s: s2, l: l2 };
    } else if (isHslChanged) {
      const { r: r2, g: g2, b: b2 } = hslaToRgba(h, s, l);
      currentColor = { ...currentColor, r: r2, g: g2, b: b2 };
    }
    this.currentColor = { ...currentColor };
    this.updateHex();
    this.updateCurrentColor(void 0, true);
    this.updateIconPointer();
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
ColorPicker = __decorateClass([
  customElements2("i-color", {
    icon: "palette",
    group: GroupType.FIELDS,
    className: "ColorPicker",
    props: {
      value: {
        type: "string",
        default: ""
      },
      caption: {
        type: "string",
        default: ""
      },
      captionWidth: {
        type: "number",
        default: 0
      }
    },
    events: {
      onChanged: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "Event" }
      ],
      onClosed: []
    },
    dataSchema: {
      type: "object",
      properties: {
        value: {
          type: "string"
        },
        caption: {
          type: "string"
        }
      }
    }
  })
], ColorPicker);

// packages/input/src/style/input.css.ts
var Theme24 = theme_exports.ThemeVars;
cssRule("i-input", {
  display: "inline-block",
  fontFamily: Theme24.typography.fontFamily,
  fontSize: Theme24.typography.fontSize,
  background: Theme24.input.background,
  "$nest": {
    "> span": {
      overflow: "hidden",
      display: "none"
    },
    "> span > label": {
      boxSizing: "border-box",
      color: Theme24.text.primary,
      display: "inline-block",
      overflow: "hidden",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      textAlign: "right",
      paddingRight: 4
    },
    "> input": {
      border: `0.5px solid ${Theme24.divider}`,
      boxSizing: "border-box",
      outline: "none",
      color: Theme24.input.fontColor,
      background: Theme24.input.background,
      borderRadius: "inherit",
      fontSize: "inherit",
      maxHeight: "100%",
      maxWidth: "100%"
    },
    ".clear-btn": {
      display: "none",
      verticalAlign: "middle",
      padding: "6px",
      backgroundColor: Theme24.action.focus,
      $nest: {
        "&.active": {
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          cursor: "pointer"
        }
      }
    },
    "textarea": {
      width: "100%",
      lineHeight: 1.5,
      color: Theme24.input.fontColor,
      background: Theme24.input.background,
      fontFamily: Theme24.typography.fontFamily,
      outline: "none",
      borderRadius: "inherit",
      fontSize: "inherit"
    }
  }
});

// packages/input/src/input.ts
var defaultRows = 4;
var CLEAR_BTN_WIDTH = 16;
var DEFAULT_VALUES11 = {
  captionWidth: 0,
  inputType: "text",
  readOnly: false,
  showClearButton: false,
  multiline: false,
  resize: "none"
};
var Input = class extends Control {
  constructor(parent, options) {
    super(parent, options, {});
    this._inputCallback = (value) => {
      this._value = value;
    };
  }
  get caption() {
    if (this._inputControl) {
      return this._inputControl.caption;
    }
    return this._caption;
  }
  set caption(value) {
    if (this._inputControl) {
      this._inputControl.caption = value;
    } else {
      this._caption = value || "";
      this.labelElm.innerHTML = this._caption;
      this.captionSpanElm.style.display = value ? "inline-block" : "none";
    }
  }
  get captionWidth() {
    if (this._inputControl) {
      return this._inputControl.captionWidth;
    }
    return this._captionWidth;
  }
  set captionWidth(value) {
    if (this._inputControl) {
      this._inputControl.captionWidth = value;
    } else {
      value = value != null ? value : "auto";
      this._captionWidth = value;
      this.labelElm.style.width = value + "px";
    }
  }
  get height() {
    return this.offsetHeight;
  }
  set height(value) {
    this.setPosition("height", value);
    if (this._inputControl) {
      this._inputControl.height = value;
    } else {
      this.inputElm.style.height = typeof value === "string" ? value : `${value}px`;
    }
  }
  get value() {
    if (this._inputControl) {
      return this._inputControl.value;
    }
    return this._value;
  }
  set value(value) {
    if (this._inputControl) {
      this._inputControl.value = value;
    } else {
      if (value == null)
        value = "";
      this._value = value;
      if (this.inputElm)
        this.inputElm.value = value;
      if (this.clearIconElm) {
        if (this._showClearButton && value) {
          this.clearIconElm.classList.add("active");
        } else {
          this.clearIconElm.classList.remove("active");
        }
      }
      if (this.inputType === "textarea" && (this.resize === "auto" || this.resize === "auto-grow")) {
        this.inputElm.style.height = "auto";
        this.inputElm.style.height = this.inputElm.scrollHeight + 2 + "px";
      }
    }
  }
  get width() {
    return this.offsetWidth;
  }
  set width(value) {
    this._width = value;
    const clearBtnWidth = this._showClearButton ? this._clearBtnWidth : 0;
    const captionWidth = typeof this._captionWidth === "string" ? this._captionWidth : `${this._captionWidth}px`;
    this.setPosition("width", value);
    if (this.inputElm) {
      if (captionWidth === "auto") {
        this.inputElm.style.width = `calc(100% - ${clearBtnWidth}px)`;
      } else {
        this.inputElm.style.width = `calc(100% - ${captionWidth} - ${clearBtnWidth}px)`;
      }
    }
  }
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(value) {
    this._readOnly = value;
    if (this.inputElm)
      this.inputElm.readOnly = value || this._designMode;
  }
  get inputType() {
    return this._inputType;
  }
  set inputType(type) {
    const isChanged = this._inputType !== type;
    this._inputType = type;
    if (isChanged)
      this._createInputElement(type);
  }
  get inputControl() {
    return this._inputControl;
  }
  get enabled() {
    return super.enabled;
  }
  set enabled(value) {
    super.enabled = value;
    if (this._inputControl) {
      this._inputControl.enabled = value;
    } else if (this.inputElm) {
      this.inputElm.disabled = !value;
    }
  }
  set placeholder(value) {
    this.inputElm.placeholder = value;
  }
  get rows() {
    return this._rows;
  }
  set rows(value) {
    if (this.inputType !== "textarea")
      return;
    this._rows = value;
    this.inputElm.rows = value;
  }
  get multiline() {
    return this._multiline;
  }
  set multiline(value) {
    this._multiline = value;
    if (value && this.inputType !== "textarea") {
      this.inputType = "textarea";
    }
  }
  get resize() {
    return this._resize;
  }
  set resize(value) {
    this._resize = value;
    if (this.inputType === "textarea" && value && this.inputElm) {
      this.inputElm.style.resize = value === "auto-grow" ? "none" : value;
      if (value === "auto" || value === "auto-grow") {
        this.inputElm.style.height = "auto";
        this.inputElm.style.height = this.inputElm.scrollHeight + 2 + "px";
      }
    }
  }
  set border(value) {
    super.border = value;
    const inputTypes = ["text", "number", "textarea", "password"];
    if (!this.inputType || inputTypes.includes(this.inputType)) {
      if (this.border.width !== void 0)
        this.inputElm.style.borderWidth = this.border.width;
      if (this.border.style)
        this.inputElm.style.borderStyle = this.border.style;
      if (this.border.color)
        this.inputElm.style.borderColor = this.border.color;
      if (this.border.bottom || this.border.top || this.border.left || this.border.right)
        this.inputElm.style.borderStyle = "none";
    }
  }
  get border() {
    return super.border;
  }
  set maxLength(value) {
    this._maxLength = value;
    if (this.inputElm) {
      if (value)
        this.inputElm.maxLength = value;
      else
        this.inputElm.removeAttribute("maxLength");
    }
  }
  get maxLength() {
    return this._maxLength;
  }
  get background() {
    return this._background;
  }
  set background(value) {
    super.background = value;
    if (value && value.color !== void 0) {
      this.style.setProperty("--input-background", value.color);
    } else {
      this.style.removeProperty("--input-background");
    }
  }
  get font() {
    return this._font;
  }
  set font(value) {
    super.font = value;
    if (value && value.color !== void 0) {
      this.style.setProperty("--input-font_color", value.color);
    } else {
      this.style.removeProperty("--input-font_color");
    }
  }
  set onClosed(callback) {
    this._onClosed = callback;
    if (!this._inputControl || this.inputType !== "color")
      return;
    this._inputControl.onClosed = callback;
  }
  get onClosed() {
    return this._onClosed;
  }
  _createInputElement(type) {
    this.clearInnerHTML();
    const value = this.getAttribute("value");
    const width = this.getAttribute("width", true);
    const height = this.getAttribute("height", true);
    const checked = this.getAttribute("checked", true);
    const enabled = this.getAttribute("enabled", true);
    const background = this.getAttribute("background", true);
    const designMode = this.getAttribute("designMode", true);
    const caption = this._caption;
    this._clearBtnWidth = height - 2 || CLEAR_BTN_WIDTH;
    switch (type) {
      case "checkbox":
        this._inputControl = new Checkbox(this, {
          value,
          checked,
          enabled,
          caption,
          designMode,
          indeterminate: this.getAttribute("indeterminate", true)
        });
        if (typeof this.onChanged === "function")
          this._inputControl.onChanged = this.onChanged;
        this.appendChild(this._inputControl);
        this.inputElm = this._inputControl.querySelector('input[type="checkbox"]');
        break;
      case "combobox":
        this._inputControl = new ComboBox(this, {
          selectedItem: this.getAttribute("selectedItem", true),
          items: this.getAttribute("items", true),
          width,
          height,
          enabled,
          designMode,
          icon: this.getAttribute("icon", true),
          mode: this.getAttribute("mode", true),
          placeholder: this.getAttribute("placeholder", true),
          parentCallback: this._inputCallback
        });
        if (typeof this.onChanged === "function")
          this._inputControl.onChanged = this.onChanged;
        this.appendChild(this._inputControl);
        this.inputElm = this._inputControl.querySelector("input");
        break;
      case "date":
      case "dateTime":
      case "time":
        this._inputControl = new Datepicker(this, {
          caption,
          value,
          placeholder: this._placeholder,
          type,
          dateTimeFormat: this.getAttribute("dateTimeFormat", true),
          width,
          height,
          designMode,
          enabled,
          parentCallback: this._inputCallback
        });
        if (typeof this.onChanged === "function")
          this._inputControl.onChanged = this.onChanged;
        this.appendChild(this._inputControl);
        this.inputElm = this._inputControl.querySelector('input[type="text"]');
        break;
      case "range":
        this._inputControl = new Range2(this, {
          value,
          caption,
          width,
          height,
          enabled,
          designMode,
          min: this.getAttribute("min", true),
          max: this.getAttribute("max", true),
          step: this.getAttribute("step", true),
          stepDots: this.getAttribute("stepDots", true),
          tooltipFormatter: this.getAttribute("tooltipFormatter", true),
          tooltipVisible: this.getAttribute("tooltipVisible", true),
          trackColor: this.getAttribute("trackColor", true),
          parentCallback: this._inputCallback
        });
        this._inputControl.onChanged = this.onChanged;
        this._inputControl.onMouseUp = this.onMouseUp;
        this._inputControl.onKeyUp = this.onKeyUp;
        this.appendChild(this._inputControl);
        this.inputElm = this._inputControl.querySelector('input[type="range"]');
        break;
      case "radio":
        const id = this.getAttribute("id") || "";
        this._inputControl = new Radio(this, {
          value,
          checked,
          enabled,
          caption,
          designMode,
          id: id + "_radio"
        });
        this.appendChild(this._inputControl);
        this.inputElm = this._inputControl.querySelector('input[type="radio"]');
        break;
      case "textarea":
        this.captionSpanElm = this.createElement("span", this);
        this.labelElm = this.createElement("label", this.captionSpanElm);
        this.inputElm = this.createElement("textarea", this);
        this.inputElm.style.height = "auto";
        const rows = this.getAttribute("rows", true) || defaultRows;
        this.rows = rows;
        if (this._placeholder) {
          this.inputElm.placeholder = this._placeholder;
        }
        this.inputElm.style.resize = value === "auto-grow" ? "none" : value;
        this.inputElm.disabled = enabled === false;
        this.inputElm.addEventListener("input", this._handleChange.bind(this));
        this.inputElm.addEventListener("keydown", this._handleInputKeyDown.bind(this));
        this.inputElm.addEventListener("keyup", this._handleInputKeyUp.bind(this));
        this.inputElm.addEventListener("focus", this._handleOnFocus.bind(this));
        if (caption)
          this.caption = caption;
        break;
      case "color":
        this._inputControl = new ColorPicker(this, {
          value,
          enabled,
          caption,
          width,
          height
        });
        if (typeof this.onChanged === "function")
          this._inputControl.onChanged = this.onChanged;
        if (!this.onClosed) {
          const onClosed = this.getAttribute("onClosed", true);
          this._inputControl.onClosed = onClosed;
        } else {
          this._inputControl.onClosed = this.onClosed;
        }
        this.appendChild(this._inputControl);
        this.inputElm = this._inputControl.querySelector(".input-span");
        break;
      default:
        const inputType = type == "password" ? type : "text";
        this.captionSpanElm = this.createElement("span", this);
        this.labelElm = this.createElement("label", this.captionSpanElm);
        this.inputElm = this.createElement("input", this);
        this.inputElm.setAttribute("autocomplete", "disabled");
        this.inputElm.style.height = this.height + "px";
        this.inputElm.type = inputType;
        if (this._placeholder)
          this.inputElm.placeholder = this._placeholder;
        this.inputElm.disabled = enabled === false;
        this.inputElm.addEventListener("input", this._handleChange.bind(this));
        this.inputElm.addEventListener("keydown", this._handleInputKeyDown.bind(this));
        this.inputElm.addEventListener("keyup", this._handleInputKeyUp.bind(this));
        this.inputElm.addEventListener("focus", this._handleOnFocus.bind(this));
        this._showClearButton = this.getAttribute("showClearButton", true);
        if (this._showClearButton) {
          this.clearIconElm = this.createElement("span", this);
          this.clearIconElm.classList.add("clear-btn");
          this.clearIconElm.style.width = this._clearBtnWidth + "px";
          this.clearIconElm.style.height = this._clearBtnWidth + "px";
          this.clearIconElm.addEventListener("click", () => {
            if (!this._enabled)
              return false;
            this._clearValue();
          });
          const clearIcon = new Icon(this, { name: "times", width: 12, height: 12, fill: theme_exports.ThemeVars.text.primary });
          this.clearIconElm.appendChild(clearIcon);
        }
        if (caption)
          this.caption = caption;
        break;
    }
    if (this.inputElm) {
      this.inputElm.readOnly = designMode || this.readOnly;
      this.inputElm.style.cursor = designMode ? "pointer" : "default";
    }
    if (background && this._inputControl)
      this._inputControl.background = background;
  }
  _handleChange(event) {
    if (this.inputType === "number" && !/^-?\d*[.]?\d*$/.test(this.inputElm.value)) {
      this.inputElm.value = this._value;
      return;
    }
    if (this.inputType === "textarea" && (this.resize === "auto" || this.resize === "auto-grow")) {
      this.inputElm.style.height = "auto";
      this.inputElm.style.height = this.inputElm.scrollHeight + 2 + "px";
    }
    this._value = this.inputElm.value;
    if (typeof this.onChanged === "function")
      this.onChanged(this, event);
  }
  _handleInputKeyDown(event) {
    if (typeof this.onKeyDown === "function")
      this.onKeyDown(this, event);
  }
  _handleInputKeyUp(event) {
    if (typeof this.onKeyUp === "function")
      this.onKeyUp(this, event);
    if (this.clearIconElm) {
      if (this.value) {
        this.clearIconElm.classList.add("active");
      } else {
        this.clearIconElm.classList.remove("active");
      }
    }
  }
  _handleBlur(event, stopPropagation) {
    if (typeof this.onBlur === "function") {
      event.preventDefault();
      this.onBlur(this);
    }
    return true;
  }
  _handleOnFocus(event) {
    if (typeof this.onFocus === "function") {
      event.preventDefault();
      this.onFocus(this);
    }
  }
  _clearValue() {
    this.value = "";
    this.clearIconElm.classList.remove("active");
    if (typeof this.onClearClick === "function")
      this.onClearClick(this);
  }
  focus() {
    this.inputElm.focus();
  }
  init() {
    if (!this.inputType) {
      this._placeholder = this.getAttribute("placeholder", true);
      this._caption = this.getAttribute("caption", true);
      this.inputType = this.getAttribute("inputType", true, DEFAULT_VALUES11.inputType);
      this.multiline = this.getAttribute("multiline", true);
      this.captionWidth = this.getAttribute("captionWidth", true);
      this.value = this.getAttribute("value", true);
      this._designMode = this.getAttribute("designMode", true, false);
      this.readOnly = this.getAttribute("readOnly", true, DEFAULT_VALUES11.readOnly);
      this.resize = this.getAttribute("resize", true, DEFAULT_VALUES11.resize);
      this.maxLength = this.getAttribute("maxLength", true);
      if (this.value && this.clearIconElm)
        this.clearIconElm.classList.add("active");
      super.init();
      if (this.inputType === "textarea" && this.maxHeight != null) {
        if (!isNaN(Number(this.maxHeight))) {
          this.inputElm.style.maxHeight = this.maxHeight + "px";
        } else {
          this.inputElm.style.maxHeight = this.maxHeight + "";
        }
      }
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
__decorateClass([
  observable("value")
], Input.prototype, "_value", 2);
Input = __decorateClass([
  customElements2("i-input", {
    icon: "edit",
    group: GroupType.FIELDS,
    className: "Input",
    props: {
      caption: {
        type: "string",
        default: ""
      },
      captionWidth: {
        type: "number",
        default: DEFAULT_VALUES11.captionWidth
      },
      inputType: {
        type: "string",
        default: DEFAULT_VALUES11.inputType
      },
      value: {
        type: "string",
        default: ""
      },
      placeholder: {
        type: "string",
        default: ""
      },
      readOnly: {
        type: "boolean",
        default: DEFAULT_VALUES11.readOnly
      },
      showClearButton: {
        type: "boolean",
        default: DEFAULT_VALUES11.showClearButton
      },
      rows: {
        type: "number"
      },
      multiline: {
        type: "boolean",
        default: DEFAULT_VALUES11.multiline
      },
      resize: {
        type: "string",
        default: DEFAULT_VALUES11.resize
      },
      maxLength: {
        type: "number"
      }
    },
    events: {
      onChanged: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "Event" }
      ],
      onClosed: [],
      onBlur: [
        { name: "target", type: "Input", isControl: true }
      ],
      onFocus: [
        { name: "target", type: "Input", isControl: true }
      ],
      onClearClick: [
        { name: "target", type: "Input", isControl: true }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        caption: {
          type: "string"
        },
        inputType: {
          type: "string",
          enum: ["password", "number", "textarea", "text"],
          default: DEFAULT_VALUES11.inputType
        },
        value: {
          type: "string"
        },
        placeholder: {
          type: "string"
        },
        readOnly: {
          type: "boolean",
          default: DEFAULT_VALUES11.readOnly
        },
        showClearButton: {
          type: "boolean",
          default: DEFAULT_VALUES11.showClearButton
        },
        rows: {
          type: "number"
        },
        multiline: {
          type: "boolean",
          default: DEFAULT_VALUES11.multiline
        },
        resize: {
          type: "string",
          enum: ["none", "auto", "both", "horizontal", "vertical", "initial", "inherit", "auto-grow"],
          default: DEFAULT_VALUES11.resize
        }
      }
    }
  })
], Input);

// packages/application/src/styles/jsonUI.css.ts
var Theme25 = theme_exports.ThemeVars;
var jsonUICheckboxStyle = style({
  display: "flex",
  alignItems: "center",
  gap: 8,
  $nest: {
    "i-checkbox": {
      display: "flex",
      height: "auto !important"
    }
  }
});
var jsonUIComboboxStyle = style({
  $nest: {
    ".selection": {
      border: `1px solid ${Theme25.divider}`
    },
    ".selection input": {
      paddingInline: 0
    }
  }
});
var jsonUITabStyle = style({
  display: "block",
  $nest: {
    ".tabs-nav": {
      borderBottom: `none`,
      borderRight: `1px solid #606770`
    },
    "i-tab": {
      color: "#606770",
      background: "none",
      margin: "4px",
      border: `none`,
      borderRadius: `5px`,
      $nest: {
        "&:not(.disabled):hover": {
          color: "#606770"
        }
      }
    },
    "i-tab:not(.disabled).active": {
      backgroundColor: "#c2c2c2",
      color: "#000000"
    }
  }
});

// packages/application/src/jsonUI.ts
var import_moment = __toModule(require_moment());
var checkPropertyChange = (value, schema, property) => {
  return validate(value, schema, { changing: property || "property" });
};
var validate = (instance, schema, options) => {
  if (!options)
    options = {};
  var _changing = options.changing;
  function getType(schema2) {
    return schema2.type;
  }
  var errors = [];
  function checkProp(value, schema2, path, scope, i, isNonObjArrayItem) {
    if (isNonObjArrayItem && typeof i === "number") {
      if (typeof value === "object") {
        value = value[Object.keys(value)[0]];
        if (isNaN(value) && (schema2.type === "number" || schema2.type === "integer"))
          value = "";
      }
      scope = scope + "_" + (i + 1).toString();
    } else {
      const parsedPath = path.split(".");
      let parsedScope = scope.split("/");
      let parentProp = "";
      if (parsedScope.length > 1) {
        parsedScope = parsedScope.splice(0, parsedScope.length - 2);
        parentProp = parsedScope[parsedScope.length - 1].split("_")[0];
      }
      let idxOfArray = -1;
      parsedPath.forEach((value2) => {
        if (value2.includes(parentProp)) {
          let matches = value2.match(/\[(.*?)\]/);
          if (matches)
            idxOfArray = parseInt(matches[1]) + 1;
        }
      });
      if (idxOfArray > 0 && getType(schema2) != "object") {
        scope = scope + "_" + idxOfArray;
      }
    }
    var l;
    path += path ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
    function addError(message, scope2, overwritePath) {
      errors.push({ property: overwritePath || path, scope: scope2, message });
    }
    if ((typeof schema2 != "object" || schema2 instanceof Array) && (path || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
      if (typeof schema2 == "function") {
        if (!(value instanceof schema2)) {
          addError("is not an instance of the class/constructor " + schema2.name, scope);
        }
      } else if (schema2) {
        addError("Invalid schema/property definition " + schema2, scope);
      }
      return null;
    }
    if (_changing && schema2.readOnly) {
      addError("is a readonly field, it can not be changed", scope);
    }
    if (schema2["extends"]) {
      checkProp(value, schema2["extends"], path, scope, i);
    }
    function checkType(type, value2, scope2) {
      if (type) {
        if (type != "any" && (type == "null" ? value2 !== null : typeof value2 != type) && !(value2 instanceof Array && type == "array") && typeof type == "string" && !(type == "integer" && value2 % 1 === 0)) {
          return [{
            property: path,
            scope: scope2,
            message: value2 + " - " + typeof value2 + " value found, but a " + type + " is required"
          }];
        }
        if (type instanceof Array) {
          let unionErrors = [];
          for (var j2 = 0; j2 < type.length; j2++) {
            if (!(unionErrors = checkType(type[j2], value2, scope2)).length) {
              break;
            }
          }
          if (unionErrors.length) {
            return unionErrors;
          }
        } else if (typeof type == "object") {
          var priorErrors = errors;
          errors = [];
          checkProp(value2, type, path, scope2);
          var theseErrors = errors;
          errors = priorErrors;
          return theseErrors;
        }
      }
      return [];
    }
    if (value === void 0 || value === "" || value instanceof Array && !value.length) {
      if (schema2.required && typeof schema2.required === "boolean") {
        addError("is missing and it is required", scope);
      }
    } else {
      if (getType(schema2) === "object" && schema2.required instanceof Array) {
        for (let requiredField of schema2.required) {
          if (value[requiredField] === void 0 || value[requiredField] === "" || value[requiredField] instanceof Array && !value[requiredField].length) {
            addError(`is missing and it is required`, scope + "/properties/" + requiredField, requiredField);
          }
        }
      }
      errors = errors.concat(checkType(getType(schema2), value, scope));
      if (schema2.disallow && !checkType(schema2.disallow, value, scope).length) {
        addError(" disallowed value was matched", scope);
      }
      if (value !== null) {
        if (value instanceof Array) {
          if (schema2.items) {
            var itemsIsArray = schema2.items instanceof Array;
            var propDef = schema2.items;
            for (i = 0, l = value.length; i < l; i += 1) {
              if (itemsIsArray)
                propDef = schema2.items[i];
              if (options.coerce)
                value[i] = options.coerce(value[i], propDef);
              if (schema2.items.type == "object") {
                var errors2 = checkProp(value[i], propDef, path, scope, i);
                if (errors2)
                  errors.concat(errors2);
              }
            }
          }
          if (schema2.minItems && value.length < schema2.minItems) {
            addError("There must be a minimum of " + schema2.minItems + " in the array", scope);
          }
          if (schema2.maxItems && value.length > schema2.maxItems) {
            addError("There must be a maximum of " + schema2.maxItems + " in the array", scope);
          }
        } else if (schema2.properties || schema2.additionalProperties) {
          errors.concat(checkObj(value, schema2.properties, path, schema2.additionalProperties, scope));
        }
        if (schema2.items && schema2.items.type != "object") {
          for (let i2 = 0; i2 < value.length; i2++) {
            checkProp(value[i2], schema2.items, path, scope, i2, true);
          }
        }
        if (schema2.pattern && typeof value == "string" && !value.match(schema2.pattern)) {
          addError("does not match the regex pattern " + schema2.pattern, scope);
        }
        if (schema2.maxLength && typeof value == "string" && value.length > schema2.maxLength) {
          addError("may only be " + schema2.maxLength + " characters long", scope);
        }
        if (schema2.minLength && typeof value == "string" && value.length < schema2.minLength) {
          addError("must be at least " + schema2.minLength + " characters long", scope);
        }
        if (typeof schema2.minimum !== "undefined" && typeof value == typeof schema2.minimum && schema2.minimum > value) {
          addError("must have a minimum value of " + schema2.minimum, scope);
        }
        if (typeof schema2.maximum !== "undefined" && typeof value == typeof schema2.maximum && schema2.maximum < value) {
          addError("must have a maximum value of " + schema2.maximum, scope);
        }
        if (schema2["enum"]) {
          var enumer = schema2["enum"];
          l = enumer.length;
          var found;
          for (var j = 0; j < l; j++) {
            if (enumer[j] === value) {
              found = 1;
              break;
            }
          }
          if (!found) {
            addError("does not have a value in the enumeration " + enumer.join(", "), scope);
          }
        }
        if (typeof schema2.maxDecimal == "number" && value.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
          addError("may only have " + schema2.maxDecimal + " digits of decimal places", scope);
        }
        if (value !== "") {
          if (schema2.format === "wallet-address") {
            const regex = new RegExp("^((0x[a-fA-F0-9]{40})|([13][a-km-zA-HJ-NP-Z1-9]{25,34})|(X[1-9A-HJ-NP-Za-km-z]{33})|(4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}))$");
            if (!regex.test(value))
              addError("is not a valid wallet address", scope);
          } else if (schema2.format === "cid") {
            const regex = new RegExp("^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$");
            if (!regex.test(value))
              addError("is not a valid cid", scope);
          } else if (schema2.format === "cid-v0") {
            const regex = new RegExp("^(Qm[1-9A-HJ-NP-Za-km-z]{44,})$");
            if (!regex.test(value))
              addError("is not a valid version 0 cid", scope);
          } else if (schema2.format === "cid-v1") {
            const regex = new RegExp("^(b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$");
            if (!regex.test(value))
              addError("is not a valid version 1 cid", scope);
          } else if (schema2.format === "uuid") {
            const regex = new RegExp("^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$");
            if (!regex.test(value))
              addError("is not a valid uuid", scope);
          }
        }
      }
    }
    return null;
  }
  function checkObj(instance2, objTypeDef, path, additionalProp, scope) {
    if (typeof objTypeDef == "object") {
      if (typeof instance2 != "object" || instance2 instanceof Array) {
        errors.push({ property: path, scope, message: "an object is required" });
      }
      for (var i in objTypeDef) {
        if (objTypeDef.hasOwnProperty(i) && i != "__proto__" && i != "constructor") {
          var value = instance2.hasOwnProperty(i) ? instance2[i] : void 0;
          if (value === void 0 && options.existingOnly)
            continue;
          var propDef = objTypeDef[i];
          if (value === void 0 && propDef["default"]) {
            value = instance2[i] = propDef["default"];
          }
          if (options.coerce && i in instance2) {
            value = instance2[i] = options.coerce(value, propDef);
          }
          checkProp(value, propDef, path, scope + "/properties/" + i, i);
        }
      }
    }
    for (i in instance2) {
      if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
        if (options.filter) {
          delete instance2[i];
          continue;
        } else {
          errors.push({
            property: path,
            message: "The property " + i + " is not defined in the schema and the schema does not allow additional properties",
            scope
          });
        }
      }
      var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
      if (requires && !(requires in instance2)) {
        errors.push({
          property: path,
          scope,
          message: "the presence of the property " + i + " requires that " + requires + " also be present"
        });
      }
      value = instance2[i];
      if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
        if (options.coerce) {
          value = instance2[i] = options.coerce(value, additionalProp);
        }
        checkProp(value, additionalProp, path, scope + "/properties/" + i, i);
      }
      if (!_changing && value && value.$schema) {
        const errors2 = checkProp(value, value.$schema, path, scope + "/properties/" + i, i);
        if (errors2)
          errors = errors.concat(errors2);
      }
    }
    return errors;
  }
  const root = "#";
  if (schema) {
    checkProp(instance, schema, "", root, _changing || "");
  }
  if (!_changing && instance && instance.$schema) {
    checkProp(instance, instance.$schema, "", root, "");
  }
  return { valid: !errors.length, errors };
};
var mustBeValid = (result) => {
  if (!result.valid) {
    throw new TypeError(result.errors.map(function(error) {
      return "for property " + error.property + ": " + error.message;
    }).join(", \n"));
  }
};
var DataSchemaValidator = {
  checkPropertyChange,
  mustBeValid,
  validate
};
function renderUI(target, options, confirmCallback, valueChangedCallback) {
  const defaultDateFormat = options.dateFormat || "DD/MM/YYYY";
  const defaultTimeFormat = options.timeFormat || "HH:mm:ss";
  const defaultDateTimeFormat = options.dateTimeFormat || "DD/MM/YYYY HH:mm:ss";
  const controls2 = {};
  const descriptions = {};
  const errorMsgs = {};
  const flatRules = [];
  const validateOnValueChanged = async (idxScope) => {
    const data = await getData(options.jsonSchema);
    const validationResult = validate(data, options.jsonSchema, { changing: false });
    let showErrMsg = false;
    let errMsg = "";
    if ((validationResult == null ? void 0 : validationResult.valid) == false) {
      for (let idx = 0; idx < validationResult.errors.length; idx++) {
        if (validationResult.errors[idx].scope == idxScope) {
          showErrMsg = true;
          errMsg = validationResult.errors[idx].message;
        }
      }
    }
    if (showErrMsg == true) {
      if (descriptions.hasOwnProperty(idxScope))
        descriptions[idxScope].visible = false;
      if (errorMsgs[idxScope]) {
        errorMsgs[idxScope].caption = errMsg;
        errorMsgs[idxScope].visible = true;
      }
    } else {
      if (descriptions.hasOwnProperty(idxScope))
        descriptions[idxScope].visible = true;
      if (errorMsgs[idxScope]) {
        errorMsgs[idxScope].caption = "";
        errorMsgs[idxScope].visible = false;
      }
    }
    valueChangedCallback && valueChangedCallback(data, errMsg);
  };
  const renderForm = (schema, scope = "#", isArray = false, idx, schemaOptions) => {
    var _a, _b;
    if (!schema)
      return void 0;
    const currentField = scope.substr(scope.lastIndexOf("/") + 1);
    const labelName = schema.title || (scope != "#/" ? convertFieldNameToLabel(currentField) : "");
    const columnWidth = options.columnWidth ? options.columnWidth : "100px";
    const idxScope = idx !== void 0 ? `${scope}_${idx}` : scope;
    const tooltip = schema.tooltip;
    let isRequired = false;
    let arrRequired = [];
    if (typeof schema.required === "boolean") {
      isRequired = schema.required;
    } else if (typeof schema.required === "object") {
      arrRequired = schema.required;
    }
    if (schema.enum && schema.enum.length > 0 || schema.oneOf && schema.oneOf.length > 0) {
      const items = [];
      if (schema.oneOf && schema.oneOf.length > 0) {
        for (const item of schema.oneOf) {
          items.push({
            label: item.title,
            value: item.const
          });
        }
      } else if (schema.enum && schema.enum.length > 0) {
        for (const item of schema.enum) {
          items.push({ label: item, value: item });
        }
      }
      const groupPnl = new Panel();
      const hStack = new HStack(groupPnl, { alignItems: "center", gap: 2 });
      if (!isArray) {
        new Label(hStack, { caption: labelName });
        if (isRequired) {
          new Label(hStack, { caption: "*", font: { color: "#ff0000" } });
        }
        if (tooltip) {
          new Icon(hStack, {
            width: "1rem",
            height: "1rem",
            name: "info-circle",
            margin: { left: 2 },
            tooltip: { content: tooltip, placement: "bottom" }
          });
        }
      }
      const controlPnl = new Panel(groupPnl);
      let combobox = new ComboBox(controlPnl, {
        width: "100%",
        items,
        icon: { name: "caret-down" },
        readOnly: schema.readOnly
      });
      combobox.id = idxScope;
      combobox.classList.add(jsonUIComboboxStyle);
      combobox.onChanged = () => validateOnValueChanged(idxScope);
      controls2[idxScope] = combobox;
      if (isArray) {
        controls2[idxScope].setAttribute("role", "column");
        controls2[idxScope].setAttribute("field", currentField);
      }
      if (schema.description)
        descriptions[idxScope] = new Label(groupPnl, { caption: schema.description });
      errorMsgs[idxScope] = new Label(groupPnl, { visible: false, font: { color: "#ff0000" } });
      return groupPnl;
    } else if (schema.type === "string") {
      if (["date", "time", "date-time"].indexOf(schema.format || "") >= 0) {
        let datePickerType = schema.format;
        if (schema.format === "date-time")
          datePickerType = "dateTime";
        const groupPnl = new Panel();
        const hStack = new HStack(groupPnl, { alignItems: "center", gap: 2 });
        if (!isArray) {
          new Label(hStack, { caption: labelName });
          if (isRequired) {
            new Label(hStack, { caption: "*", font: { color: "#ff0000" } });
          }
          if (tooltip) {
            new Icon(hStack, {
              width: "1rem",
              height: "1rem",
              name: "info-circle",
              margin: { left: 2 },
              tooltip: { content: tooltip, placement: "bottom" }
            });
          }
        }
        const controlPnl = new Panel(groupPnl);
        let dateTimeFormat;
        if (schema.format === "date") {
          dateTimeFormat = defaultDateFormat;
        } else if (schema.format === "date-time") {
          dateTimeFormat = defaultDateTimeFormat;
        } else if (schema.format === "time") {
          dateTimeFormat = defaultTimeFormat;
        }
        const datePicker = new Datepicker(controlPnl, {
          width: columnWidth,
          type: datePickerType,
          dateTimeFormat,
          readOnly: schema.readOnly
        });
        datePicker.id = idxScope;
        datePicker.onChanged = () => validateOnValueChanged(idxScope);
        controls2[idxScope] = datePicker;
        if (isArray) {
          controls2[idxScope].setAttribute("role", "column");
          controls2[idxScope].setAttribute("field", currentField);
          controls2[idxScope].setAttribute("format", schema.format || "");
        }
        if (schema.description)
          descriptions[idxScope] = new Label(groupPnl, { caption: schema.description });
        errorMsgs[idxScope] = new Label(groupPnl, { visible: false, font: { color: "#ff0000" } });
        return groupPnl;
      } else if (schema.format === "data-url") {
        const groupPnl = new Panel();
        const hStack = new HStack(groupPnl, { alignItems: "center", gap: 2 });
        if (!isArray) {
          new Label(hStack, { caption: labelName });
          if (isRequired) {
            new Label(hStack, { caption: "*", font: { color: "#ff0000" } });
          }
          if (tooltip) {
            new Icon(hStack, {
              width: "1rem",
              height: "1rem",
              name: "info-circle",
              margin: { left: 2 },
              tooltip: { content: tooltip, placement: "bottom" }
            });
          }
        }
        const controlPnl = new Panel(groupPnl);
        let upload = new Upload(controlPnl, {
          readOnly: schema.readOnly
        });
        upload.id = idxScope;
        upload.onChanged = () => validateOnValueChanged(idxScope);
        controls2[idxScope] = upload;
        if (isArray) {
          controls2[idxScope].setAttribute("role", "column");
          controls2[idxScope].setAttribute("field", currentField);
          controls2[idxScope].setAttribute("format", schema.format);
        }
        return groupPnl;
      } else {
        const groupPnl = new Panel();
        const hStack = new HStack(groupPnl, { alignItems: "center", gap: 2 });
        if (!isArray) {
          new Label(hStack, { caption: labelName });
          if (isRequired) {
            new Label(hStack, { caption: "*", font: { color: "#ff0000" } });
          }
          if (tooltip) {
            new Icon(hStack, {
              width: "1rem",
              height: "1rem",
              name: "info-circle",
              margin: { left: 2 },
              tooltip: { content: tooltip, placement: "bottom" }
            });
          }
        }
        const controlPnl = new Panel(groupPnl);
        let inputType = "text";
        if (schema.format === "color")
          inputType = "color";
        else if (schema.format === "multi")
          inputType = "textarea";
        let input = new Input(controlPnl, {
          width: columnWidth,
          inputType,
          readOnly: schema.readOnly
        });
        input.id = idxScope;
        input.onBlur = () => validateOnValueChanged(idxScope);
        controls2[idxScope] = input;
        if (isArray) {
          controls2[idxScope].setAttribute("role", "column");
          controls2[idxScope].setAttribute("field", currentField);
        }
        if (schema.description)
          descriptions[idxScope] = new Label(groupPnl, { caption: schema.description });
        errorMsgs[idxScope] = new Label(groupPnl, { visible: false, font: { color: "#ff0000" } });
        return groupPnl;
      }
    } else if (["integer", "number"].indexOf(((_a = schema.type) == null ? void 0 : _a.toString()) || "") >= 0) {
      const groupPnl = new Panel();
      const hStack = new HStack(groupPnl, { alignItems: "center", gap: 2 });
      if (!isArray) {
        new Label(hStack, { caption: labelName });
        if (isRequired) {
          new Label(hStack, { caption: "*", font: { color: "#ff0000" } });
        }
        if (tooltip) {
          new Icon(hStack, {
            width: "1rem",
            height: "1rem",
            name: "info-circle",
            margin: { left: 2 },
            tooltip: { content: tooltip, placement: "bottom" }
          });
        }
      }
      const controlPnl = new Panel(groupPnl);
      let inputType = "number";
      if (schema.type === "integer")
        inputType = "integer";
      let input = new Input(controlPnl, {
        width: columnWidth,
        inputType,
        readOnly: schema.readOnly
      });
      input.id = idxScope;
      input.onBlur = () => validateOnValueChanged(idxScope);
      controls2[idxScope] = input;
      if (isArray) {
        controls2[idxScope].setAttribute("role", "column");
        controls2[idxScope].setAttribute("field", currentField);
        controls2[idxScope].setAttribute("format", inputType);
      }
      if (schema.description)
        descriptions[idxScope] = new Label(groupPnl, { caption: schema.description });
      errorMsgs[idxScope] = new Label(groupPnl, { visible: false, font: { color: "#ff0000" } });
      return groupPnl;
    } else if (schema.type === "boolean") {
      const groupPnl = new Panel();
      groupPnl.classList.add(jsonUICheckboxStyle);
      const hStack = new HStack(groupPnl, { alignItems: "center", gap: 2 });
      if (!isArray) {
        new Label(hStack, { caption: labelName });
        if (isRequired) {
          new Label(hStack, { caption: "*", font: { color: "#ff0000" } });
        }
        if (tooltip) {
          new Icon(hStack, {
            width: "1rem",
            height: "1rem",
            name: "info-circle",
            margin: { left: 2 },
            tooltip: { content: tooltip, placement: "bottom" }
          });
        }
      }
      const controlPnl = new Panel(groupPnl);
      let checkbox = new Checkbox(controlPnl, {
        readOnly: schema.readOnly
      });
      checkbox.id = idxScope;
      checkbox.onChanged = () => validateOnValueChanged(idxScope);
      controls2[idxScope] = checkbox;
      if (isArray) {
        controls2[idxScope].setAttribute("role", "column");
        controls2[idxScope].setAttribute("field", currentField);
      }
      return groupPnl;
    } else if (schema.type === "object") {
      const properties = schema.properties;
      if (!properties)
        return void 0;
      const groupPnl = new Panel(void 0, {
        border: {
          width: 1,
          style: "solid",
          color: "#EEE",
          radius: "0.4rem"
        },
        padding: {
          top: 16,
          bottom: 16,
          left: 16,
          right: 16
        }
      });
      const templateColumns = [];
      if (options.columnsPerRow)
        for (let i = 0; i < options.columnsPerRow; i++)
          templateColumns.push("1fr");
      let form = new GridLayout(void 0, {
        templateColumns,
        gap: {
          row: 10,
          column: 10
        },
        padding: {
          top: 5,
          bottom: 5,
          left: 10,
          right: 10
        }
      });
      if (scope !== "#") {
        const pnl = new Panel(groupPnl, {
          padding: {
            top: 5,
            bottom: 5,
            left: 10,
            right: 10
          },
          border: {
            bottom: {
              width: 1,
              style: "solid",
              color: "#CCC",
              radius: 5
            }
          }
        });
        const hStack = new HStack(pnl, { alignItems: "center", gap: 2 });
        new Label(hStack, { caption: labelName, font: { size: "1.6rem" } });
        if (isRequired) {
          new Label(hStack, { caption: "*", font: { color: "#ff0000" } });
        }
        if (tooltip) {
          new Icon(hStack, {
            width: "1rem",
            height: "1rem",
            name: "info-circle",
            margin: { left: 2 },
            tooltip: { content: tooltip, placement: "bottom" }
          });
        }
      }
      for (const propertyName in properties) {
        let currentSchema = properties[propertyName];
        if (!(currentSchema == null ? void 0 : currentSchema.required) && arrRequired.includes(propertyName)) {
          currentSchema.required = true;
        }
        const control = renderForm(currentSchema, `${idxScope}/properties/${propertyName}`, false, idx);
        form.append(control);
      }
      groupPnl.append(form);
      controls2[idxScope] = groupPnl;
      return groupPnl;
    } else if (schema.type === "array") {
      if (!schema.items)
        return void 0;
      let isVertical = false;
      if (typeof (schemaOptions == null ? void 0 : schemaOptions.detail) === "object") {
        isVertical = schemaOptions.detail.type === "VerticalLayout";
      }
      const groupPnl = new Panel(void 0, {
        border: {
          width: 1,
          style: "solid",
          color: "#EEE",
          radius: "0.4rem"
        },
        padding: {
          top: 16,
          bottom: 16,
          left: 8,
          right: 8
        }
      });
      groupPnl.setAttribute("role", "array");
      const arrayField = scope.split("/");
      groupPnl.setAttribute("array-field", arrayField[arrayField.length - 1]);
      groupPnl.setAttribute("array-field-idx", `${idx === void 0 ? "" : idx}`);
      const pnlTitle = new HStack(groupPnl, {
        padding: {
          top: 5,
          bottom: 5,
          left: 10,
          right: 10
        },
        border: {
          bottom: {
            width: 1,
            style: "solid",
            color: "#DADDE1"
          }
        },
        justifyContent: "space-between",
        alignItems: "center",
        backgroundColor: "transparent"
      });
      const hStack = new HStack(pnlTitle, { alignItems: "center", gap: 2 });
      new Label(hStack, { caption: labelName, font: { size: "1rem" } });
      if (isRequired) {
        new Label(hStack, { caption: "*", font: { color: "#ff0000" } });
      }
      if (tooltip) {
        new Icon(hStack, {
          width: "1rem",
          height: "1rem",
          name: "info-circle",
          margin: { left: 2 },
          tooltip: { content: tooltip, placement: "bottom" }
        });
      }
      const btnAdd = new Icon(new Panel(pnlTitle), {
        name: "plus",
        fill: theme_exports.ThemeVars.colors.primary.main,
        width: "1em",
        height: "1em"
      });
      btnAdd.classList.add("pointer");
      btnAdd.setAttribute("role", "add");
      const pnlItems = new Panel(groupPnl, {
        padding: {
          top: 5,
          bottom: 5,
          left: 5,
          right: 5
        }
      });
      const _items = schema.items;
      const itemsRequired = typeof (_items == null ? void 0 : _items.required) === "object" ? _items.required : [];
      const updateIndex = (props, newIdx, currentIdx, prefixScope, newPrefix, subIdx) => {
        var _a2, _b2, _c;
        for (const propertyName in props) {
          const subIndex = subIdx || 0;
          const finalIndex = subIdx ? subIndex : newIdx;
          const currentScope = `${prefixScope}/properties/${propertyName}_${subIdx ? subIndex : currentIdx}`;
          const newScope = `${newPrefix || prefixScope}/properties/${propertyName}_${finalIndex}`;
          if (props[propertyName].type === "object") {
            updateIndex(props[propertyName].properties, newIdx, currentIdx, currentScope, newScope);
          } else if (props[propertyName].type === "array" && ((_a2 = props[propertyName].items) == null ? void 0 : _a2.type) === "object") {
            const rows = ((_b2 = controls2[currentScope]) == null ? void 0 : _b2.querySelectorAll(":scope > i-panel > [role='row']")) || [];
            let _currentItemIdx = 0;
            while (_currentItemIdx < rows.length) {
              _currentItemIdx++;
              updateIndex(props[propertyName].items.properties, newIdx, currentIdx, currentScope, newScope, subIndex + _currentItemIdx);
            }
          }
          const parentLayout = (_c = controls2[newScope]) == null ? void 0 : _c.closest("[array-item-idx]");
          if (parentLayout) {
            parentLayout.setAttribute("array-item-idx", `${newIdx}`);
            parentLayout["options"]["array-item-idx"] = `${newIdx}`;
          }
          updateSingleIndex(currentScope, newScope, finalIndex);
        }
      };
      const updateNonObjIndex = (newIdx, currentIdx, prefixScope) => {
        const currentScope = `${prefixScope}_${currentIdx}`;
        const newScope = `${prefixScope}_${newIdx}`;
        updateSingleIndex(currentScope, newScope);
      };
      const updateSingleIndex = (currentScope, newScope, finalIndex) => {
        const tempControl = controls2[currentScope];
        controls2[newScope] = tempControl;
        if (controls2[newScope].id) {
          controls2[newScope].id = newScope;
        } else if (controls2[newScope].getAttribute("object-field-idx") && finalIndex != void 0) {
          controls2[newScope].setAttribute("object-field-idx", `${finalIndex}`);
          controls2[newScope]["options"]["object-field-idx"] = `${finalIndex}`;
        } else if (controls2[newScope].getAttribute("array-field-idx") && finalIndex != void 0) {
          controls2[newScope].setAttribute("array-field-idx", `${finalIndex}`);
          controls2[newScope]["options"]["array-field-idx"] = `${finalIndex}`;
        }
        const tempErrMsg = errorMsgs[currentScope];
        if (tempErrMsg) {
          errorMsgs[newScope] = tempErrMsg;
          controls2[newScope].onChanged = () => validateOnValueChanged(newScope);
        }
        const tempDescription = descriptions[currentScope];
        if (tempDescription) {
          descriptions[newScope] = tempDescription;
        }
        delete descriptions[currentScope];
        delete errorMsgs[currentScope];
        delete controls2[currentScope];
      };
      const isObject = _items.type === "object";
      if (!isObject)
        isVertical = true;
      const itemType = (_b = schema.items) == null ? void 0 : _b.type;
      if (isVertical && _items.type) {
        const addCard = () => {
          const index = groupPnl.querySelectorAll(":scope > i-panel > [role='row']").length + 1;
          const arrIndex = groupPnl.getAttribute("array-field-idx") || idx;
          const newIdxScope = idx !== void 0 ? `${scope}_${arrIndex}` : scope;
          const gridSize = isObject ? ["1fr", "3fr"] : ["3fr", "1fr"];
          const gridLayout = new GridLayout(pnlItems, {
            templateColumns: gridSize,
            border: {
              bottom: {
                width: 1,
                style: "solid",
                color: "#DADDE1"
              }
            },
            padding: {
              top: 32,
              bottom: 32,
              left: 8,
              right: 8
            },
            gap: {
              row: 10,
              column: 10
            }
          });
          gridLayout.position = "relative";
          gridLayout.setAttribute("role", "row");
          gridLayout.setAttribute("array-item-idx", `${index}`);
          if (isObject == false) {
            if (schema.required === true) {
              _items.required = true;
            }
            const control = renderForm(_items, `${idxScope}`, true, index);
            if (control) {
              control.setAttribute("object-field-idx", `${index}`);
              if (itemType !== "array" && itemType !== "object") {
                control.setAttribute("single-field", "");
              }
              gridLayout.append(control);
            }
          } else if (typeof _items === "object" && _items.type === "object" && _items.properties) {
            for (const propertyName in _items.properties) {
              let property = schema.items.properties[propertyName];
              if (!(property == null ? void 0 : property.required) && (arrRequired.includes(propertyName) || itemsRequired.includes(propertyName))) {
                property.required = true;
              }
              const control = renderForm(property, `${newIdxScope}/properties/${propertyName}`, true, index);
              if (control && (property == null ? void 0 : property.type) === "object") {
                control.setAttribute("object-field", propertyName);
                control.setAttribute("object-field-idx", `${index}`);
                if (itemType !== "array" && itemType !== "object") {
                  control.setAttribute("single-field", "");
                }
                const lb = control.querySelector(":scope > i-panel");
                if (lb) {
                  lb.style.display = "none";
                }
              }
              ;
              const hStack2 = new HStack(void 0, { gap: 2 });
              const _property = property;
              new Label(hStack2, { caption: _property.title || convertFieldNameToLabel(propertyName) });
              if (_property.required) {
                new Label(hStack2, { caption: "*", font: { color: "#ff0000" } });
              }
              gridLayout.append(hStack2);
              gridLayout.append(control);
            }
          }
          const btnDelete = new Icon(void 0, {
            name: "times",
            fill: "#ff0000",
            width: "1rem",
            height: "1rem"
          });
          if (!isObject) {
            const hStack2 = new HStack(gridLayout, {
              height: "40px",
              padding: {
                top: 10,
                bottom: 10,
                left: 15,
                right: 15
              }
            });
            hStack2.verticalAlignment = "center";
            hStack2.horizontalAlignment = "end";
            hStack2.append(btnDelete);
          } else {
            btnDelete.style.top = "5px";
            btnDelete.style.right = "5px";
            gridLayout.append(btnDelete);
          }
          btnDelete.position = "absolute";
          btnDelete.classList.add("pointer");
          btnDelete.onClick = () => {
            let currentIdx = Number(gridLayout.getAttribute("array-item-idx") || "1");
            let newIdx = Number(gridLayout.getAttribute("array-item-idx") || "1");
            let idxItem = groupPnl.querySelectorAll(":scope > i-panel > [role='row']").length;
            while (newIdx < idxItem) {
              currentIdx++;
              if (isObject)
                updateIndex(_items.properties, newIdx, currentIdx, newIdxScope);
              else
                updateNonObjIndex(newIdx, currentIdx, newIdxScope);
              newIdx = Number(currentIdx);
            }
            gridLayout.remove();
          };
        };
        btnAdd.onClick = () => {
          addCard();
        };
        addCard();
      } else {
        let colCount = 0;
        if (schema.items instanceof Array)
          colCount = schema.items.length;
        else if (typeof schema.items === "object" && schema.items.type === "object" && schema.items.properties)
          colCount = Object.keys(schema.items.properties).length;
        const templateColumns = [];
        for (let i = 0; i < colCount; i++)
          templateColumns.push("1fr");
        templateColumns.push("1em");
        const headerColumn = new GridLayout(pnlItems, {
          templateColumns,
          border: {
            top: {
              width: 1,
              style: "solid",
              color: "#DADDE1"
            },
            bottom: {
              width: 1,
              style: "solid",
              color: "#DADDE1"
            }
          },
          padding: {
            top: 16,
            bottom: 16,
            left: 16,
            right: 16
          },
          gap: {
            row: 10,
            column: 10
          }
        });
        if (schema.items instanceof Array) {
          for (const item of schema.items) {
            const _item = item;
            if (_item.title) {
              const hStack2 = new HStack(headerColumn, { gap: 2 });
              new Label(hStack2, { caption: _item.title });
              if (_item.required) {
                new Label(hStack2, { caption: "*", font: { color: "#ff0000" } });
              }
            }
          }
        } else if (typeof schema.items === "object") {
          if (schema.items.type === "object" && schema.items.properties) {
            for (const propertyName in schema.items.properties) {
              let property = schema.items.properties[propertyName];
              if (!(property == null ? void 0 : property.required) && (arrRequired.includes(propertyName) || itemsRequired.includes(propertyName))) {
                property.required = true;
              }
              const hStack2 = new HStack(headerColumn, { gap: 2 });
              const _property = property;
              new Label(hStack2, { caption: _property.title || convertFieldNameToLabel(propertyName) });
              if (_property.required) {
                new Label(hStack2, { caption: "*", font: { color: "#ff0000" } });
              }
            }
          }
        }
        const addRow = () => {
          const index = groupPnl.querySelectorAll(":scope > i-panel > [role='row']").length + 1;
          const arrIndex = groupPnl.getAttribute("array-field-idx") || idx;
          const newIdxScope = idx !== void 0 ? `${scope}_${arrIndex}` : scope;
          const bodyColumn = new GridLayout(pnlItems, {
            templateColumns,
            gap: {
              row: 10,
              column: 10
            },
            padding: {
              top: 16,
              bottom: 16,
              left: 16,
              right: 16
            },
            border: {
              bottom: {
                width: 1,
                style: "solid",
                color: "#DADDE1"
              }
            }
          });
          bodyColumn.setAttribute("role", "row");
          bodyColumn.setAttribute("array-item-idx", `${index}`);
          if (typeof schema.items === "object" && _items.type === "object" && _items.properties) {
            for (const propertyName in _items.properties) {
              const property = schema.items.properties[propertyName];
              if (!(property == null ? void 0 : property.required) && (arrRequired.includes(propertyName) || itemsRequired.includes(propertyName))) {
                property.required = true;
              }
              const control = renderForm(property, `${newIdxScope}/properties/${propertyName}`, true, index);
              if (control && (property == null ? void 0 : property.type) === "object") {
                control.setAttribute("object-field", propertyName);
                control.setAttribute("object-field-idx", `${index}`);
                if (itemType !== "array" && itemType !== "object") {
                  control.setAttribute("single-field", "");
                }
                const lb = control.querySelector(":scope > i-panel");
                if (lb) {
                  lb.style.display = "none";
                }
              }
              ;
              bodyColumn.append(control);
            }
            const btnDelete = new Icon(bodyColumn, {
              name: "times",
              fill: "#ff0000",
              width: "1em",
              height: "1em",
              marginBlock: {
                top: "auto"
              }
            });
            btnDelete.classList.add("pointer");
            btnDelete.onClick = () => {
              let currentIdx = Number(bodyColumn.getAttribute("array-item-idx") || "1");
              let newIdx = Number(bodyColumn.getAttribute("array-item-idx") || "1");
              let idxItem = groupPnl.querySelectorAll(":scope > i-panel > [role='row']").length;
              while (newIdx < idxItem) {
                currentIdx++;
                updateIndex(_items.properties, newIdx, currentIdx, newIdxScope);
                newIdx = Number(currentIdx);
              }
              bodyColumn.remove();
            };
          }
        };
        addRow();
        btnAdd.onClick = () => {
          addRow();
        };
      }
      controls2[idxScope] = groupPnl;
      return groupPnl;
    } else if (schema.type === "null") {
      return void 0;
    } else if (schema.type === "any") {
      return void 0;
    } else
      return void 0;
  };
  const renderFormBySchema = (dataSchema, uiSchema, scope = "#") => {
    if (!dataSchema || !uiSchema)
      return;
    clearUI();
    let uiWrapper = new Panel(target, {
      padding: {
        left: 10,
        right: 10,
        top: 0,
        bottom: 10
      }
    });
    uiWrapper.id = "uiWrapper";
    let formTabs = new Tabs(uiWrapper, {
      mode: "vertical"
    });
    formTabs.id = "formTabs";
    formTabs.classList.add(jsonUITabStyle);
    formTabs.visible = ["Categorization", "Category"].includes(uiSchema.type);
    let ui = createUI(uiSchema);
    if (ui)
      uiWrapper.append(ui);
    setupRules();
  };
  const setupRules = () => {
    for (const item of flatRules) {
      const { rule, elm } = item;
      if (rule && rule.condition && rule.condition.scope && rule.condition.schema) {
        const control = document.getElementById(rule.condition.scope);
        if (control) {
          const toggleValidate = () => {
            if (rule.effect === "HIDE" || rule.effect === "SHOW") {
              if (control.checked === rule.condition.schema.const) {
                elm.visible = rule.effect === "SHOW";
              } else {
                elm.visible = !(rule.effect === "SHOW");
              }
            } else if (rule.effect == "ENABLE" || rule.effect == "DISABLE") {
              if (control.checked === rule.condition.schema.const) {
                elm.enabled = rule.effect === "ENABLE";
              } else {
                elm.enabled = !(rule.effect === "ENABLE");
              }
            }
          };
          if (control.tagName === "I-CHECKBOX" || control.tagName === "I-SWITCH") {
            control.onChanged = (target2, event) => {
              toggleValidate();
            };
            toggleValidate();
          }
        }
      }
    }
  };
  const clearUI = () => {
    let uiWrapper = document.getElementById("uiWrapper");
    if (uiWrapper)
      uiWrapper.innerHTML = "";
  };
  const generateTemplateColumnsByNumber = (count) => {
    let columns = [];
    for (let i = 0; i < count; i++)
      columns.push("1fr");
    return columns;
  };
  const getDataSchemaByScope = (scope) => {
    const segments = scope.split("/");
    let obj = {};
    for (const segment of segments) {
      if (segment === "#")
        obj = options.jsonSchema;
      else
        obj = obj[segment];
    }
    if (obj == void 0)
      console.log("No corresponding scope:", scope);
    return [segments[segments.length - 1], obj];
  };
  const createUI = (uiSchema, carryData) => {
    if (!uiSchema)
      return null;
    const { elements, type, scope, label, options: options2, rule } = uiSchema;
    if (type === "VerticalLayout") {
      const elm = new VStack(void 0, {
        justifyContent: "center",
        alignItems: "center"
      });
      if (elements)
        elements.map((v) => {
          let ui = createUI(v);
          if (ui)
            elm.append(ui);
        });
      if (rule)
        flatRules.push({ elm, rule });
      return elm;
    } else if (type === "HorizontalLayout") {
      const elm = new GridLayout(void 0, {
        width: "100%",
        gap: { column: 16 },
        templateColumns: elements ? generateTemplateColumnsByNumber(elements.length) : ""
      });
      if (elements)
        elements.map((v) => {
          let ui = createUI(v);
          if (ui)
            elm.append(ui);
        });
      if (rule)
        flatRules.push({ elm, rule });
      return elm;
    } else if (type === "Group") {
      const elm = new Panel(void 0, {
        width: "100%"
      });
      elm.classList.add("box");
      if (label !== false && !!label) {
        let boxHeader = new Panel(elm);
        let boxHeaderLabel = new Label(boxHeader, {
          caption: label
        });
        boxHeaderLabel.classList.add("box-header");
      }
      const boxContent = new Panel(elm);
      boxContent.classList.add("box-content");
      if (elements)
        elements.map((v) => {
          let ui = createUI(v);
          if (ui)
            boxContent.append(ui);
        });
      if (rule)
        flatRules.push({ elm, rule });
      return elm;
    } else if (type === "Categorization") {
      let elm = new Tabs();
      elm.classList.add(jsonUITabStyle);
      let formTabs = document.getElementById("formTabs");
      if (formTabs)
        formTabs.visible = true;
      if (elements) {
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          createUI(element, { tabs: formTabs, index: i });
        }
      }
      elm = formTabs;
      if (rule)
        flatRules.push({ elm, rule });
      return formTabs;
    } else if (type === "Category") {
      let caption;
      if (label !== false) {
        caption = label;
      }
      if (carryData && carryData.tabs && carryData.index != void 0) {
        const children = new Panel(void 0, {
          padding: {
            left: 10,
            right: 10,
            top: 10,
            bottom: 10
          }
        });
        if (elements) {
          for (const element of elements) {
            let ui = createUI(element);
            if (ui)
              children.append(ui);
          }
        }
        let tabCaption = typeof caption == "boolean" ? "" : caption;
        const formTabs = document.getElementById("formTabs");
        let tab = formTabs.add({ caption: tabCaption, children });
        formTabs.activeTabIndex = 0;
        if (rule)
          flatRules.push({ elm: tab, rule });
      }
    } else if (type === "Control" && scope) {
      const [key2, dataSchema] = getDataSchemaByScope(scope);
      const stub = new Panel(void 0, {
        padding: {
          left: 5,
          right: 5,
          top: 5,
          bottom: 5
        }
      });
      stub.classList.add("form-group");
      let caption, labelElm, descriptionElm;
      let formControlElm = new Panel();
      formControlElm.classList.add("form-control");
      let hideLabel = false;
      if (label !== false) {
        caption = label;
        if (!caption)
          caption = convertFieldNameToLabel(key2);
      }
      const control = renderForm(dataSchema, scope, false, void 0, options2);
      formControlElm.append(control);
      if (formControlElm)
        stub.append(formControlElm);
      if (descriptionElm)
        stub.append(descriptionElm);
      if (rule) {
        flatRules.push({ elm: stub, rule });
      }
      ;
      return stub;
    } else
      return null;
  };
  const setDataUpload = (url, control) => {
    if (!url || !control)
      return;
    const getImageTypeFromUrl = (url2) => {
      const extension = url2.match(/\.([^.]+)$/);
      switch (extension && extension[1].toLowerCase()) {
        case "jpg":
        case "jpeg":
          return "image/jpeg";
        case "png":
          return "image/png";
        case "gif":
          return "image/gif";
        case "svg":
          return "image/svg";
        default:
          return "image/png";
      }
    };
    const getExtensionFromType = (fileType) => {
      return fileType.split("/")[1];
    };
    try {
      let imgUrl = url;
      if (url.startsWith("ipfs://")) {
        imgUrl = imgUrl.replace("ipfs://", "https://ipfs.scom.dev/ipfs/");
      }
      fetch(imgUrl).then((response) => response.arrayBuffer()).then((arrayBuffer) => {
        const fileType = getImageTypeFromUrl(imgUrl);
        const blob = new Blob([arrayBuffer], { type: fileType });
        const fileName = `image-${Date.now()}.${getExtensionFromType(fileType)}`;
        const file = new File([blob], fileName, { type: fileType });
        control.fileList = [file];
        control.preview(imgUrl);
      });
    } catch (e) {
      control.fileList = [];
    }
  };
  const setData = (schema, data, scope = "#", idx) => {
    var _a;
    if (!schema || !data && !(schema.type === "number" && data === 0))
      return;
    const idxScope = idx !== void 0 ? `${scope}_${idx}` : scope;
    if (schema.type === "object") {
      if (!schema.properties)
        return;
      for (const propertyName in schema.properties) {
        setData(schema.properties[propertyName], data[propertyName], `${idxScope}/properties/${propertyName}`, idx);
      }
    } else if (schema.type === "array") {
      if (typeof schema.items === "object" && schema.items.properties) {
        const grid = controls2[idxScope];
        const btnAdd = grid.querySelector("[role='add']");
        let rows = grid.querySelectorAll("[role='row']");
        if (data instanceof Array) {
          for (let i = 0; i < data.length; i++) {
            const columnData = data[i];
            if (btnAdd && i > 0)
              btnAdd.onClick(btnAdd);
            if (typeof columnData === "object") {
              for (const propertyName in columnData) {
                const fieldData = columnData[propertyName];
                rows = grid.querySelectorAll(":scope > i-panel > [role='row']");
                if (rows) {
                  const row = rows[rows.length - 1];
                  const column = row.querySelector(`[role='column'][field='${propertyName}']`);
                  if (column) {
                    if (column.tagName === "I-CHECKBOX") {
                      column.checked = fieldData;
                    } else if (column.tagName === "I-COMBO-BOX") {
                      column.selectedItem = column.items.find((v) => v.value === fieldData) || void 0;
                    } else if (column.tagName === "I-DATEPICKER") {
                      const format = column.getAttribute("format");
                      let dateFormat;
                      if (format === "date")
                        dateFormat = defaultDateFormat;
                      else if (format === "time")
                        dateFormat = defaultTimeFormat;
                      else
                        dateFormat = defaultDateTimeFormat;
                      column.value = (0, import_moment.default)(fieldData, dateFormat);
                    } else if (column.tagName === "I-UPLOAD") {
                      setDataUpload(fieldData, column);
                    } else {
                      column.value = fieldData;
                    }
                    continue;
                  }
                  const properties = ((_a = schema.items) == null ? void 0 : _a.properties) || {};
                  const objectField = row.querySelector(`:scope > [object-field='${propertyName}']`);
                  if (objectField) {
                    const idxObj = objectField.getAttribute("object-field-idx");
                    setData(properties[propertyName], fieldData, `${idxScope}/properties/${propertyName}`, Number(idxObj));
                    continue;
                  }
                  const arrayField = row.querySelector(`:scope > [array-field='${propertyName}']`);
                  if (arrayField) {
                    const idxObj = arrayField.getAttribute("array-field-idx");
                    setData(properties[propertyName], fieldData, `${idxScope}/properties/${propertyName}`, Number(idxObj));
                  }
                }
              }
            }
          }
        }
      } else {
        const grid = controls2[idxScope];
        const btnAdd = grid.querySelector("[role='add']");
        for (let i = 0; i < data.length; i++) {
          if (btnAdd && i > 0)
            btnAdd.onClick(btnAdd);
          if (typeof schema.items != "boolean" && typeof schema.items != "undefined")
            setData(schema.items, data[i], `${scope}_${i + 1}`);
        }
      }
    } else {
      const control = controls2[idxScope];
      if (control.tagName === "I-CHECKBOX")
        control.checked = data;
      else if (control.tagName === "I-DATEPICKER") {
        const format = schema.format;
        let dateFormat;
        if (format === "date")
          dateFormat = defaultDateFormat;
        else if (format === "time")
          dateFormat = defaultTimeFormat;
        else
          dateFormat = defaultDateTimeFormat;
        control.value = (0, import_moment.default)(data, dateFormat);
      } else if (control.tagName === "I-COMBO-BOX") {
        control.selectedItem = control.items.find((v) => v.value === data) || void 0;
      } else if (control.tagName === "I-UPLOAD") {
        setDataUpload(data, control);
      } else
        control.value = data;
    }
  };
  const getData = async (schema, scope = "#", idx) => {
    var _a, _b, _c, _d;
    if (!schema)
      return null;
    const idxScope = idx !== void 0 ? `${scope}_${idx}` : scope;
    if (schema.type === "object") {
      const properties = schema.properties;
      if (!properties)
        return void 0;
      const data = {};
      for (const propertyName in properties) {
        data[propertyName] = await getData(properties[propertyName], `${idxScope}/properties/${propertyName}`, idx);
      }
      return data;
    } else if (schema.type === "array") {
      const grid = controls2[idxScope];
      if (!grid)
        return void 0;
      const rows = grid.querySelectorAll("[role='row']");
      if (!rows)
        return void 0;
      const listData = [];
      for (const row of rows) {
        const parentRow = row.closest("[role='array']");
        if (parentRow !== grid)
          continue;
        const columns = row.querySelectorAll("[role='column']");
        const objects = row.querySelectorAll(":scope > [object-field]");
        const arrayField = row.querySelectorAll(":scope > [array-field]");
        if (!columns && !objects && !arrayField)
          continue;
        let columnData = {};
        for (const column of columns) {
          const parentCol = column.closest("[role='row']");
          if (parentCol !== row)
            continue;
          const fieldName = column.getAttribute("field");
          if (!fieldName)
            continue;
          const isSingle = column.closest("[single-field]");
          if (column.tagName === "I-CHECKBOX") {
            columnData[fieldName] = column.checked;
          } else if (column.tagName === "I-COMBO-BOX") {
            columnData[fieldName] = (_a = column.value) == null ? void 0 : _a.value;
          } else if (column.tagName === "I-DATEPICKER") {
            const format = column.getAttribute("format");
            let dateFormat;
            if (format === "date")
              dateFormat = defaultDateFormat;
            else if (format === "time")
              dateFormat = defaultTimeFormat;
            else
              dateFormat = defaultDateTimeFormat;
            columnData[fieldName] = ((_b = column.value) == null ? void 0 : _b.format(dateFormat)) || "";
          } else if (column.tagName === "I-UPLOAD") {
            if (!column.fileList || column.fileList && column.fileList.length === 0)
              return void 0;
            columnData[fieldName] = await column.toBase64(column.fileList[0]);
          } else if (column.tagName === "I-INPUT") {
            const format = column.getAttribute("format");
            if (format === "number")
              columnData[fieldName] = parseFloat(column.value);
            else if (format === "integer")
              columnData[fieldName] = parseInt(column.value);
            else
              columnData[fieldName] = column.value;
          }
          if (isSingle) {
            columnData = columnData[fieldName];
          }
        }
        const properties = ((_c = schema.items) == null ? void 0 : _c.properties) || {};
        for (const obj of objects) {
          const field = obj.getAttribute("object-field");
          const idxObj = obj.getAttribute("object-field-idx");
          if (field && properties[field]) {
            columnData[field] = await getData(properties[field], `${idxScope}/properties/${field}`, Number(idxObj));
          }
        }
        for (const card of arrayField) {
          const field = card.getAttribute("array-field");
          const idxObj = card.getAttribute("array-field-idx");
          if (field && properties[field]) {
            columnData[field] = await getData(properties[field], `${idxScope}/properties/${field}`, Number(idxObj));
          }
        }
        listData.push(columnData);
      }
      return listData;
    } else {
      const control = controls2[idxScope];
      if (!control)
        return void 0;
      if (control.tagName === "I-CHECKBOX")
        return control.checked;
      else if (control.tagName === "I-COMBO-BOX") {
        return (_d = control.value) == null ? void 0 : _d.value;
      } else if (control.tagName === "I-DATEPICKER") {
        const value = control.value;
        if (value === void 0)
          return "";
        if (schema.format === "date")
          return (value == null ? void 0 : value.format(defaultDateFormat)) || "";
        else if (schema.format === "time")
          return (value == null ? void 0 : value.format(defaultTimeFormat)) || "";
        else if (schema.format === "date-time")
          return (value == null ? void 0 : value.format(defaultDateTimeFormat)) || "";
      } else if (control.tagName === "I-UPLOAD") {
        if (!control.fileList || control.fileList && control.fileList.length === 0)
          return void 0;
        const dataUrl = await control.toBase64(control.fileList[0]);
        return dataUrl;
      } else if (control.tagName === "I-INPUT") {
        if (schema.type === "string")
          return control.value;
        else if (schema.type === "integer") {
          const value = parseInt(control.value);
          return isNaN(value) ? void 0 : value;
        } else if (schema.type === "number") {
          const value = parseFloat(control.value);
          return isNaN(value) ? void 0 : value;
        } else
          return control.value;
      }
      return control.value;
    }
  };
  const panel = new Panel();
  if (options == null ? void 0 : options.jsonUISchema) {
    renderFormBySchema(options.jsonSchema, options.jsonUISchema);
  } else {
    const form = renderForm(options.jsonSchema);
    panel.append(form);
  }
  const pnlButton = new HStack();
  const confirmButtonCaption = options.confirmButtonCaption ? options.confirmButtonCaption : "Confirm";
  const buttonStack = new HStack(void 0, {
    justifyContent: "end",
    alignItems: "center",
    width: "100%",
    padding: {
      left: 10,
      right: 10,
      top: 5,
      bottom: 5
    }
  });
  if (options.showClearButton) {
    const clearButtonCaption = options.clearButtonCaption ? options.clearButtonCaption : "Clear";
    const btnClear = new Button(buttonStack, {
      caption: clearButtonCaption,
      padding: {
        top: 5,
        bottom: 5,
        left: 5,
        right: 5
      },
      margin: {
        right: 5
      },
      font: {
        color: options.clearButtonFontColor ? options.clearButtonFontColor : "#FFF"
      },
      background: {
        color: options.clearButtonBackgroundColor ? options.clearButtonBackgroundColor : "#3F51B5"
      }
    });
    btnClear.onClick = () => {
      for (const scope in controls2) {
        const control = controls2[scope];
        if (control.tagName === "I-COMBO-BOX")
          control.clear();
        else if (control.tagName === "I-CHECKBOX")
          control.checked = false;
        else
          control.value = void 0;
      }
    };
  }
  if (!options.hideConfirmButton) {
    const btnConfirm = new Button(buttonStack, {
      caption: confirmButtonCaption,
      padding: {
        top: 5,
        bottom: 5,
        left: 5,
        right: 5
      },
      font: {
        color: options.confirmButtonFontColor ? options.confirmButtonFontColor : "#FFF"
      },
      background: {
        color: options.confirmButtonBackgroundColor ? options.confirmButtonBackgroundColor : "#3F51B5"
      }
    });
    btnConfirm.onClick = async () => {
      if (!confirmCallback)
        return;
      const data = await getData(options.jsonSchema);
      const validationResult = validate(data, options.jsonSchema, { changing: false });
      if (validationResult == null ? void 0 : validationResult.valid)
        confirmCallback(true, data);
      else
        confirmCallback(false, validationResult);
    };
    panel.append(pnlButton);
  }
  if (target) {
    target.append(panel);
    if (buttonStack.childNodes.length > 0) {
      target.append(buttonStack);
    }
    if (options.data) {
      const validationResult = validate(options.data, options.jsonSchema, { changing: false });
      if (validationResult == null ? void 0 : validationResult.valid)
        setData(options.jsonSchema, options.data);
      else
        console.log(validationResult);
    }
  }
}
function convertFieldNameToLabel(name) {
  let label = "";
  for (let i = 0; i < name.length; i++) {
    let char = name[i];
    if (i == 0) {
      label += char.toUpperCase();
      continue;
    }
    if (char == char.toUpperCase())
      label += ` ${char}`;
    else
      label += char;
  }
  return label;
}

// packages/moment/src/index.ts
RequireJS.config({
  paths: {
    "@moment": `${LibPath}lib/moment/2.29.1/moment.js`
  }
});
var moment;
RequireJS.require(["@moment"], (_moment) => {
  moment = _moment;
});

// packages/application/src/formatUtils.ts
var FormatUtils = class {
  static unixToFormattedDate(unixTimestamp) {
    return moment.unix(unixTimestamp).format("YYYY-MM-DD HH:mm:ss");
  }
  static truncateTxHash(hash, length = 20) {
    return hash.substring(0, length) + "...";
  }
  static truncateWalletAddress(address) {
    return address.substring(0, 6) + "..." + address.substring(address.length - 4);
  }
  static formatNumber(value, options) {
    if (!value)
      return "0";
    const { decimalFigures, useSeparators = true, roundingMethod = "round", minValue, shortScale = false } = options || {};
    let stringValue = typeof value === "string" ? value : value.toString();
    stringValue = stringValue.trim();
    if (stringValue === "0")
      return "0";
    if (minValue !== void 0) {
      const compareResult = this.compareToMinValue(stringValue, minValue.toString());
      if (compareResult === -1)
        return `<${minValue}`;
    }
    const hasExponential = stringValue.includes("e");
    stringValue = hasExponential ? this.removeExponential(stringValue) : stringValue;
    let suffix = "";
    if (shortScale) {
      const { value: newValue2, suffix: newSuffix } = this.scaleValue(stringValue);
      if (newValue2)
        stringValue = newValue2;
      suffix = newSuffix;
    }
    let [integerPart, decimalPart] = stringValue.split(".");
    const formattedInteger = useSeparators ? integerPart.replace(/\B(?=(\d{3})+(?!\d))/g, ",") : integerPart;
    if (decimalFigures === void 0 || decimalFigures < 0) {
      return (decimalPart ? `${formattedInteger}.${decimalPart}` : formattedInteger) + suffix;
    }
    let newValue = "";
    if (decimalFigures && decimalFigures > 0) {
      const { newDecimal, newInteger } = this.processDecimalPart(decimalPart, integerPart, options);
      const formattedInteger2 = useSeparators ? newInteger.replace(/\B(?=(\d{3})+(?!\d))/g, ",") : newInteger;
      newValue = newDecimal ? `${formattedInteger2}.${newDecimal}` : formattedInteger2;
    } else {
      const newInteger = this.roundIntegerPart(decimalPart, integerPart, roundingMethod);
      newValue = useSeparators ? newInteger.replace(/\B(?=(\d{3})+(?!\d))/g, ",") : newInteger;
    }
    return (newValue.length > 18 ? newValue.substring(0, 18) + "..." : newValue) + suffix;
  }
  static scaleValue(value) {
    let [integerPart] = value.split(".");
    const absBigInteger = BigInt(integerPart.replace(/\-|\s+/g, ""));
    const newBigValue = new BigDecimal(value);
    let newValue = "";
    let suffix = "";
    if (absBigInteger >= 1e9) {
      newValue = newBigValue.divide(new BigDecimal("1000000000")).toString();
      suffix = "B";
    } else if (absBigInteger >= 1e6) {
      newValue = newBigValue.divide(new BigDecimal("1000000")).toString();
      suffix = "M";
    } else if (absBigInteger >= 1e3) {
      newValue = newBigValue.divide(new BigDecimal("1000")).toString();
      suffix = "K";
    }
    return { value: newValue, suffix };
  }
  static removeExponential(value) {
    let [numberPart, ePart] = value.split("e");
    numberPart = numberPart.replace(".", "");
    const powValue = Number(ePart) > 0 ? Number(ePart) : Number(ePart) * -1;
    const eValue = (10 ** powValue).toLocaleString("en-US", { useGrouping: false });
    const rightPart = Math.abs(numberPart.length - eValue.length);
    if (Number(ePart) < 0) {
      return "0." + "0".repeat(Math.abs(rightPart) - 1) + numberPart;
    } else {
      return numberPart + "0".repeat(rightPart);
    }
  }
  static compareToMinValue(stringValue, minValue) {
    let [integerPart1, decimalPart1 = ""] = stringValue.split(".");
    let [integerPart2, decimalPart2 = ""] = minValue.split(".");
    const maxDecimals = Math.max(decimalPart1.length, decimalPart2.length);
    const bigValue1 = BigInt(integerPart1 + decimalPart1.padEnd(maxDecimals, "0"));
    const bigValue2 = BigInt(integerPart2 + decimalPart2.padEnd(maxDecimals, "0"));
    if (bigValue1 > bigValue2) {
      return 1;
    } else if (bigValue1 < bigValue2) {
      return -1;
    } else {
      return 0;
    }
  }
  static processDecimalPart(decimalPart, integerPart, options) {
    const { decimalFigures = 0, roundingMethod = "round", hasTrailingZero = true } = options || {};
    let roundingValue = { newDecimal: decimalPart, newInteger: integerPart };
    if (decimalPart) {
      const initialDecimalPart = decimalPart.slice(0, decimalFigures).replace(/0+$/g, "");
      switch (roundingMethod) {
        case "round":
          roundingValue = this.customRound(decimalPart, integerPart, decimalFigures, 5, hasTrailingZero);
          break;
        case "ceil":
          if (integerPart.startsWith("-")) {
            roundingValue.newDecimal = initialDecimalPart;
          } else {
            roundingValue = this.customRound(decimalPart, integerPart, decimalFigures, 1, hasTrailingZero);
          }
          break;
        default:
          roundingValue.newDecimal = initialDecimalPart;
      }
    } else if (hasTrailingZero) {
      roundingValue.newDecimal = "0".repeat(decimalFigures);
    }
    return { ...roundingValue };
  }
  static customRound(decimalPart, integerPart, decimalFigures, roundingNumber, hasTrailingZero) {
    const decimalArr = decimalPart.split("");
    let lastIndex2 = decimalArr.length - 1;
    let newInteger = integerPart;
    for (let i = decimalArr.length - 1; i >= 0; i--) {
      if (i < decimalFigures) {
        if (decimalArr[i] === "10" && i === 0) {
          newInteger = this.incrementLastDigit(integerPart);
          lastIndex2 = -1;
          break;
        } else if (decimalArr[i] !== "10") {
          lastIndex2 = i + 1;
          break;
        }
      }
      if (+decimalArr[i] >= roundingNumber && i - 1 >= 0) {
        decimalArr[i] = "0";
        decimalArr[i - 1] = `${+decimalArr[i - 1] + 1}`;
      }
    }
    const newDecimal = lastIndex2 >= 0 ? decimalArr.slice(0, lastIndex2).join("") : "";
    let roundingValue;
    if (hasTrailingZero && newDecimal.length < decimalFigures) {
      roundingValue = newDecimal + "0".repeat(decimalFigures - newDecimal.length);
    } else {
      roundingValue = newDecimal.replace(/0+$/g, "");
    }
    return { newDecimal: roundingValue, newInteger };
  }
  static roundIntegerPart(decimalPart, integerPart, roundingMethod) {
    const firstDecimal = decimalPart && decimalPart.charAt(0);
    const notRounding = integerPart.startsWith("-") && roundingMethod === "ceil" || roundingMethod === "floor" || !firstDecimal || roundingMethod === "round" && +firstDecimal < 5 || roundingMethod === "ceil" && +firstDecimal < 1;
    return notRounding ? integerPart : this.incrementLastDigit(integerPart);
  }
  static incrementLastDigit(integerPart) {
    let chars = integerPart.split("") || [];
    let isNegative = chars[0] === "-";
    isNegative && chars.shift();
    if (chars[chars.length - 1] === "9") {
      for (let i = chars.length - 1; i > 0; i--) {
        const num = +chars[i];
        if (num >= 9 && i - 1 > 0) {
          chars[i] = "0";
          chars[i - 1] = `${+chars[i - 1] + 1}`;
        }
      }
    } else {
      chars[chars.length - 1] = `${+chars[chars.length - 1] + 1}`;
    }
    if (isNegative)
      chars.unshift("-");
    return chars.join("");
  }
};
var _BigDecimal = class {
  constructor(value) {
    let [integerPart, decimalPart = ""] = value.split(".");
    decimalPart = decimalPart.padEnd(_BigDecimal.decimals, "0");
    this.bigVal = BigInt(integerPart + decimalPart);
  }
  static fromBigInt(bigVal) {
    return Object.assign(Object.create(_BigDecimal.prototype), { bigVal });
  }
  toString() {
    const str = this.bigVal.toString().padStart(_BigDecimal.decimals + 1, "0");
    return str.slice(0, -_BigDecimal.decimals) + "." + str.slice(-_BigDecimal.decimals).replace(/\.?0+$/, "");
  }
  divide(value) {
    if (!value)
      throw new Error("Cannot divide to empty value");
    return _BigDecimal.fromBigInt(this.bigVal * BigInt("1" + "0".repeat(_BigDecimal.decimals)) / value.bigVal);
  }
};
var BigDecimal = _BigDecimal;
BigDecimal.decimals = 18;

// packages/application/src/idUtils.ts
var IdUtils = class {
  static generateUUID(length) {
    const uuid = "xxxxxxxx-xxxx-xxxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
      let r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
    if (length) {
      return uuid.substring(0, length);
    }
    return uuid;
  }
};

// packages/application/src/index.ts
var API_IPFS_BASEURL = "/api/ipfs/v0";
var IpfsDataType;
(function(IpfsDataType2) {
  IpfsDataType2[IpfsDataType2["Raw"] = 0] = "Raw";
  IpfsDataType2[IpfsDataType2["Directory"] = 1] = "Directory";
  IpfsDataType2[IpfsDataType2["File"] = 2] = "File";
  IpfsDataType2[IpfsDataType2["Metadata"] = 3] = "Metadata";
  IpfsDataType2[IpfsDataType2["Symlink"] = 4] = "Symlink";
  IpfsDataType2[IpfsDataType2["HAMTShard"] = 5] = "HAMTShard";
})(IpfsDataType || (IpfsDataType = {}));
function topologicalSort(edges) {
  let nodes = {}, sorted = [], visited = {};
  class TSortNode {
    constructor(id) {
      this.id = id;
      this.afters = [];
    }
  }
  ;
  edges.forEach((v) => {
    let from = v[0], to = v[1];
    if (!nodes[from])
      nodes[from] = new TSortNode(from);
    if (!nodes[to])
      nodes[to] = new TSortNode(to);
    nodes[from].afters.push(to);
  });
  Object.keys(nodes).forEach(function visit(idstr, ancestors) {
    let node = nodes[idstr], id = node.id;
    if (visited[idstr])
      return;
    if (!Array.isArray(ancestors))
      ancestors = [];
    ancestors.push(id);
    visited[idstr] = true;
    node.afters.forEach(function(afterID) {
      if (ancestors.indexOf(afterID) >= 0)
        throw new Error("closed chain : " + afterID + " is in " + id);
      visit(afterID.toString(), ancestors.map(function(v) {
        return v;
      }));
    });
    sorted.unshift(id);
  });
  return sorted;
}
var Application = class {
  constructor() {
    this.modules = {};
    this.modulesId = {};
    this.scripts = {};
    this.id = 0;
    this.LibHost = "";
    this.packageNames = new Set();
    this.packages = {};
    this.cidItems = {};
    this.bundleLibs = {};
    this.store = {};
    this.rootDir = "";
    this.globalEvents = new GlobalEvents();
  }
  get EventBus() {
    return EventBus.getInstance();
  }
  static get Instance() {
    return this._instance || (this._instance = new this());
  }
  assets(name) {
    if (this._assets) {
      let items = name.split("/");
      let value = this._assets;
      let item = items.shift();
      while (value && item) {
        value = value[item];
        item = items.shift();
      }
      ;
      return value;
    }
    ;
  }
  calculateElementScconfigPath(packageName) {
    let options = this._initOptions;
    let rootDir = (options == null ? void 0 : options.rootDir) ? options == null ? void 0 : options.rootDir : "";
    if (!rootDir.endsWith("/"))
      rootDir = rootDir + "/";
    let libDir = (options == null ? void 0 : options.libDir) ? (options == null ? void 0 : options.libDir) + "/" : "libs/";
    let path = rootDir + libDir + packageName + "/scconfig.json";
    return path;
  }
  async calculatePackageModuleDir(packageName, modulePath) {
    let packageModulePath = await this.calculatePackageModulePath(packageName, modulePath || "*") || "";
    let currentModuleDir;
    if (packageModulePath.indexOf("://") > 0)
      currentModuleDir = packageModulePath.split("/").slice(0, -1).join("/");
    else if (!packageModulePath.startsWith("/"))
      currentModuleDir = this.LibHost + this.rootDir + packageModulePath.split("/").slice(0, -1).join("/");
    else
      currentModuleDir = this.LibHost + packageModulePath.split("/").slice(0, -1).join("/");
    return currentModuleDir;
  }
  async createElement(name, lazyLoad, attributes, modulePath) {
    name = name.split("/").pop() || name;
    let elementName = `i-${name}`;
    let result;
    let packageName = `@scom/${name}`;
    try {
      if (window.customElements.get(elementName)) {
        let currentModuleDir = await this.calculatePackageModuleDir(packageName, modulePath || "*");
        result = document.createElement(elementName);
        result.currentModuleDir = currentModuleDir;
        ;
      } else {
        let scconfigPath = this.calculateElementScconfigPath(packageName);
        if (scconfigPath) {
          let scconfigResponse = await fetch(scconfigPath);
          if (scconfigResponse.status == 200) {
            let scconfig = await scconfigResponse.json();
            if (scconfig) {
              let promisesMap = {};
              let packageModulePathMap = {};
              for (let dependency of scconfig.dependencies) {
                if (dependency === "@ijstech/components" || this.packageNames.has(dependency))
                  continue;
                let packageModulePath = await this.calculatePackageModulePath(dependency, modulePath || "*");
                if (!packageModulePath || this.packages[packageModulePath])
                  continue;
                try {
                  let m = window["require"](dependency);
                  if (m) {
                    if (!this.packageNames.has(dependency))
                      this.packageNames.add(dependency);
                    this.packages[packageModulePath] = m.default || m;
                    continue;
                  }
                  ;
                } catch (err) {
                }
                ;
                packageModulePathMap[dependency] = packageModulePath;
                promisesMap[dependency] = this.getScript(packageModulePath);
              }
              ;
              let dependenciesArr = Object.keys(promisesMap);
              let scripts2 = await Promise.all(Object.values(promisesMap));
              for (let i = 0; i < dependenciesArr.length; i++) {
                let dependency = dependenciesArr[i];
                let packageModulePath = packageModulePathMap[dependency];
                let script = scripts2[i];
                if (script) {
                  await this.dynamicImportPackage(script, dependency, packageModulePath);
                }
                ;
              }
            }
          }
          ;
        }
        ;
        let loaded = await this.loadPackage(packageName, modulePath || "*");
        if (loaded) {
          let currentModuleDir = await this.calculatePackageModuleDir(packageName, modulePath || "*");
          result = document.createElement(elementName);
          result.currentModuleDir = currentModuleDir;
        }
      }
      ;
      if (result) {
        if (lazyLoad)
          result.setAttribute("lazyLoad", "true");
        for (let name2 in attributes) {
          result.setAttribute(name2, attributes[name2]);
        }
        ;
      }
      ;
    } catch (err) {
      console.dir(err);
    }
    ;
    return result;
  }
  fetch(input, init) {
    if (typeof input == "string") {
      let url = input;
      if (url.indexOf("://") < 0 && !url.startsWith("/"))
        input = `${this.rootDir}${url}`;
    } else if (input instanceof Request) {
      let req = input;
      if (req.url.indexOf("://") < 0 && !req.url.startsWith("/")) {
        input = new Request(`${this.rootDir}${req.url}`);
      }
      ;
    }
    ;
    return fetch(input, init);
  }
  async postData(endpoint, data) {
    data = data || {};
    const response = await fetch(endpoint, {
      method: "POST",
      mode: "cors",
      cache: "no-cache",
      credentials: "same-origin",
      headers: {
        "Content-Type": "application/json"
      },
      referrerPolicy: "no-referrer",
      body: JSON.stringify(data)
    });
    return response.json();
  }
  async showUploadModal() {
    if (!this._uploadModal)
      this._uploadModal = new UploadModal();
    this._uploadModal.show();
  }
  async getUploadUrl(item) {
    let { data } = await this.postData(`${API_IPFS_BASEURL}/upload`, { data: item });
    return data || {};
  }
  async uploadData(fileName, content) {
    let cid = await hashContent(content);
    let item = {
      cid: cid.cid,
      name: fileName,
      size: cid.size,
      type: "file"
    };
    let dir = await hashItems([item]);
    let data = await this.getUploadUrl(dir);
    if ((data == null ? void 0 : data[dir.cid]) && (data == null ? void 0 : data[cid.cid])) {
      let dirStatus = await this.upload(data[dir.cid], JSON.stringify(dir));
      let fileStatus = await this.upload(data[cid.cid], content);
      if (dirStatus == 200 && fileStatus == 200)
        return { success: true, data: dir };
      else
        return { success: false, error: `Failed to upload file. Status code: ${fileStatus}` };
    } else
      return { success: false };
  }
  async uploadFile(extensions) {
    return new Promise(async (resolve, reject) => {
      const input = document.createElement("input");
      input.type = "file";
      if (extensions) {
        const accept = Array.isArray(extensions) ? extensions.map((ext) => `.${ext}`).join(",") : `.${extensions}`;
        input.accept = accept;
      }
      ;
      input.addEventListener("change", async () => {
        var _a;
        const file = (_a = input.files) == null ? void 0 : _a[0];
        if (file) {
          file.path = `/${file.name}`;
          file.cid = await hashFile(file);
          let dir = await hashFiles([file]);
          let { data } = await this.postData(`${API_IPFS_BASEURL}/upload`, { data: dir });
          if (data == null ? void 0 : data[file.cid.cid]) {
            let result = await this.upload(data[file.cid.cid], file);
          }
          ;
          if (data == null ? void 0 : data[dir.cid]) {
            let result = await this.upload(data[dir.cid], JSON.stringify(dir));
          }
          ;
          resolve({
            success: true,
            data: dir
          });
        } else {
          reject({ success: false, error: "No file selected" });
        }
      });
      input.click();
    });
  }
  async uploadTo(targetCid, items) {
    let cid = await (await fetch(`${API_IPFS_BASEURL}/stat/${targetCid}`)).json();
    if (cid == null ? void 0 : cid.links) {
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        let exists = false;
        for (let k = 0; k < cid.links.length; k++) {
          if (cid.links[k].name == item.cid.name) {
            cid.links[k] = item.cid;
            exists = true;
            break;
          }
          ;
        }
        ;
        if (!exists)
          cid.links.push(item.cid);
      }
      ;
      let newCid = await hashItems(cid.links);
      let uploadUrl = await this.getUploadUrl(newCid);
      for (let i = 0; i < items.length; i++) {
        let item = items[i];
        if (uploadUrl[item.cid.cid]) {
          let data;
          if (item.cid.type == "dir")
            data = item.data || JSON.stringify(item.cid);
          else
            data = item.data;
          if (!data)
            throw new Error(`Missing upload data: ${item.cid.name}`);
          let result = await this.upload(uploadUrl[item.cid.cid], data);
          if (result != 200)
            throw new Error(`File upload failed: ${item.cid.name}`);
        }
        ;
      }
      ;
      if (uploadUrl[newCid.cid]) {
        let result = await this.upload(uploadUrl[newCid.cid], JSON.stringify(newCid));
        if (result != 200)
          throw new Error(`File upload failed: ${newCid.cid}`);
      }
      ;
      return {
        success: true,
        data: newCid
      };
    }
    ;
    throw new Error(`Target CID not found: ${targetCid}`);
  }
  async upload(url, data) {
    return new Promise(async (resolve) => {
      if (typeof data == "string") {
        let result = await fetch(url, {
          method: "PUT",
          body: data
        });
        resolve(result.status);
      } else {
        const reader = new FileReader();
        reader.onload = async () => {
          let result = await fetch(url, {
            method: "PUT",
            body: reader.result
          });
          resolve(result.status);
        };
        reader.onerror = () => {
          resolve(0);
        };
        reader.readAsArrayBuffer(data);
      }
      ;
    });
  }
  async getCidItem(host, cid, paths) {
    if (paths.length > 0) {
      let cidItem = this.cidItems[cid];
      if (!cidItem) {
        try {
          let data = localStorage.getItem(cid);
          if (data)
            cidItem = JSON.parse(data);
        } catch (err) {
        }
        ;
        if (!cidItem)
          cidItem = await (await fetch(`${host}/${cid}`)).json();
        let id = await hashItems(cidItem.links);
        if (id.cid != cid)
          throw new Error("CID not match");
        try {
          localStorage.setItem(cid, JSON.stringify(cidItem));
        } catch (err) {
        }
        this.cidItems[cid] = cidItem;
      }
      ;
      if (cidItem && cidItem.links) {
        let path = paths.shift();
        for (let i = 0; i < cidItem.links.length; i++) {
          if (cidItem.links[i].name == path) {
            if (cidItem.links[i].type == "dir")
              return await this.getCidItem(host, cidItem.links[i].cid, paths);
            else {
              return cidItem.links[i];
            }
            ;
          }
          ;
        }
        ;
      }
      ;
    }
    ;
    return;
  }
  async verifyScript(modulePath, script) {
    var _a, _b;
    if (((_a = this._initOptions) == null ? void 0 : _a.ipfs) && typeof ((_b = this._initOptions) == null ? void 0 : _b.ipfs) == "string") {
      try {
        let paths = modulePath.split("/");
        let cid = await this.getCidItem("/ipfs", this._initOptions.ipfs, paths);
        if (!cid)
          return false;
        let scriptCid = await hashContent(script);
        return cid.cid == scriptCid.cid;
      } catch (err) {
        return false;
      }
    }
    ;
    return true;
  }
  async getScript(modulePath) {
    if (this.scripts[modulePath])
      return this.scripts[modulePath];
    try {
      let result = await (await this.fetch(modulePath)).text();
      if (typeof result == "string") {
        if (await this.verifyScript(modulePath, result)) {
          this.scripts[modulePath] = result;
          return result;
        }
        ;
      }
      ;
    } catch (err) {
    }
    ;
    return "";
  }
  async loadScript(modulePath, script) {
    try {
      if (this.scripts[modulePath])
        return true;
      if (!script)
        script = await this.getContent(modulePath);
      if (script && await this.verifyScript(modulePath, script)) {
        this.scripts[modulePath] = script;
        await import(`data:text/javascript,${encodeURIComponent(script)}`);
        return true;
      }
      ;
    } catch (err) {
    }
    ;
    return false;
  }
  async getContent(modulePath) {
    try {
      return await (await this.fetch(modulePath)).text();
    } catch (err) {
    }
    return "";
  }
  async fetchDirectoryInfoByCID(ipfsCid) {
    try {
      const IPFS_API = `https://ipfs.scom.dev/ipfs/${ipfsCid}`;
      let result = await fetch(IPFS_API);
      let jsonContent = await result.json();
      if (jsonContent.links)
        return jsonContent.links;
      return [];
    } catch (err) {
      console.log(err);
    }
    ;
    return [];
  }
  async calculatePackageModulePath(packageName, modulePath) {
    var _a, _b, _c;
    let options = this._initOptions;
    if (options && options.modules && options.modules[packageName]) {
      let pack = options.modules[packageName];
      for (let i = 0; i < ((_a = pack.dependencies) == null ? void 0 : _a.length); i++) {
        let n = pack.dependencies[i];
        if (!RequireJS.defined(n))
          await this.loadPackage(n);
      }
      ;
    }
    ;
    let rootDir = (options == null ? void 0 : options.rootDir) ? options == null ? void 0 : options.rootDir : "";
    if (!rootDir.endsWith("/"))
      rootDir = rootDir + "/";
    let moduleDir = (options == null ? void 0 : options.moduleDir) ? (options == null ? void 0 : options.moduleDir) + "/" : "modules/";
    let libDir = (options == null ? void 0 : options.libDir) ? (options == null ? void 0 : options.libDir) + "/" : "libs/";
    if (!modulePath) {
      if ((_b = options == null ? void 0 : options.modules) == null ? void 0 : _b[packageName])
        modulePath = rootDir + moduleDir + ((_c = options == null ? void 0 : options.modules) == null ? void 0 : _c[packageName].path) + "/index.js";
      else
        return null;
    } else if (modulePath == "*") {
      modulePath = rootDir + libDir + packageName + "/index.js";
    } else if (modulePath.startsWith("{LIB}/")) {
      let libPath = LibPath || "";
      if (LibPath && !LibPath.endsWith("/"))
        libPath = libPath + "/";
      modulePath = modulePath.replace("{LIB}/", libPath);
    }
    return modulePath;
  }
  async loadPackage(packageName, modulePath) {
    let packageModulePath = await this.calculatePackageModulePath(packageName, modulePath);
    if (!packageModulePath)
      return null;
    try {
      let m = window["require"](packageName);
      if (m) {
        if (!this.packageNames.has(packageName))
          this.packageNames.add(packageName);
        this.packages[packageModulePath] = m.default || m;
        return m.default || m;
      }
      ;
    } catch (err) {
    }
    ;
    let script = await this.getScript(packageModulePath);
    if (script) {
      const importedPackage = await this.dynamicImportPackage(script, packageName, packageModulePath);
      return importedPackage;
    }
    ;
    return null;
  }
  async loadPackages(packages) {
    let paths = [];
    let packs = [];
    let pathIdx = {};
    let script = "";
    for (let i = 0; i < packages.length; i++) {
      let pack = packages[i];
      let m;
      try {
        m = window["require"](pack);
      } catch (err) {
      }
      ;
      let path = this.getModulePath(pack);
      if (m) {
        this.packages[path] = m.default || m;
      } else {
        if (!this.packages[path]) {
          packs.push(pack);
          pathIdx[pack] = path;
          paths.push(path);
        }
        ;
      }
    }
    ;
    if (packs.length > 0) {
      let edges = [];
      if (this._initOptions && this._initOptions.modules) {
        for (let idx = packs.length - 1; idx >= 0; idx--) {
          let pack = packs[idx];
          let module2 = this._initOptions.modules[pack];
          if (module2 && module2.dependencies) {
            for (let i = 0; i < module2.dependencies.length; i++) {
              let dependency = module2.dependencies[i];
              let depIdx = packs.indexOf(dependency);
              if (depIdx > -1) {
                edges.push([dependency, pack]);
              }
              ;
            }
            ;
          }
          ;
        }
        ;
        let sorted = topologicalSort(edges);
        for (let i = 0; i < packs.length; i++) {
          if (sorted.indexOf(packs[i]) < 0)
            sorted.push(packs[i]);
        }
        ;
        packs = sorted;
        paths = packs.map((p) => pathIdx[p]);
      }
      ;
      let result = await Promise.all(paths.map((u) => fetch(u)));
      for (let i = 0; i < paths.length; i++) {
        let pack = packs[i];
        let path = paths[i];
        path = path.split("/").slice(0, -1).join("/");
        if (this._initOptions && this._initOptions.modules && this._initOptions.modules[pack])
          script += `application.currentModuleDir=application.rootDir+'modules/${this._initOptions.modules[pack].path}';
`;
        else
          script += `application.currentModuleDir=application.rootDir+'libs/${pack}';
`;
        script += await result[i].text() + "\n";
      }
      ;
      await import(`data:text/javascript,${encodeURIComponent(script)}`);
      for (let i = 0; i < paths.length; i++) {
        let pack = packs[i];
        let path = paths[i];
        let m = window["require"](pack);
        if (m) {
          if (!this.packageNames.has(pack))
            this.packageNames.add(pack);
          this.packages[path] = m.default || m;
        }
        ;
      }
      ;
    }
    ;
  }
  async dynamicImportPackage(script, packageName, packageModulePath) {
    _currentDefineModule = null;
    this.currentModulePath = packageModulePath;
    if (packageModulePath.indexOf("://") > 0)
      this.currentModuleDir = packageModulePath.split("/").slice(0, -1).join("/");
    else if (!packageModulePath.startsWith("/"))
      this.currentModuleDir = this.LibHost + this.rootDir + packageModulePath.split("/").slice(0, -1).join("/");
    else
      this.currentModuleDir = this.LibHost + packageModulePath.split("/").slice(0, -1).join("/");
    if (!this.packageNames.has(packageName)) {
      await import(`data:text/javascript,${encodeURIComponent(script)}`);
      this.packageNames.add(packageName);
    }
    this.currentModulePath = "";
    this.currentModuleDir = "";
    let m = window["require"](packageName);
    if (m) {
      this.packages[packageModulePath] = m.default || m;
      return m.default || m;
    }
    return null;
  }
  async loadModule(modulePath, options) {
    let module2 = await this.newModule(modulePath, options);
    if (module2)
      document.body.append(module2);
    return module2;
  }
  getModulePath(module2) {
    let options = this._initOptions;
    let modulePath = module2;
    if (options && options.modules && options.modules[module2] && options.modules[module2].path) {
      modulePath = "";
      if (options.rootDir) {
        modulePath += options.rootDir;
        if (!modulePath.endsWith("/"))
          modulePath += "/";
      }
      ;
      if (options.moduleDir) {
        modulePath += options.moduleDir;
        if (!modulePath.endsWith("/"))
          modulePath += "/";
      }
      ;
      modulePath += options.modules[module2].path;
      if (!modulePath.endsWith(".js"))
        modulePath += "/index.js";
    } else if (options && options.dependencies && options.dependencies[module2]) {
      let libDir = "";
      if (options == null ? void 0 : options.libDir) {
        libDir = options.libDir;
        if (!libDir.endsWith("/"))
          libDir += "/";
        if (libDir.startsWith("/"))
          libDir = libDir.substring(1);
      } else
        libDir = "libs/";
      modulePath = `${(options == null ? void 0 : options.rootDir) ? options.rootDir : ""}`;
      if (modulePath && !modulePath.endsWith("/"))
        modulePath += "/";
      modulePath += libDir + module2 + "/index.js";
    }
    ;
    return modulePath;
  }
  async initModule(modulePath, script) {
    if (this.modulesId[modulePath])
      return this.modulesId[modulePath];
    _currentDefineModule = null;
    this.currentModulePath = modulePath;
    if (modulePath.indexOf("://") > 0)
      this.currentModuleDir = modulePath.split("/").slice(0, -1).join("/");
    else if (!modulePath.startsWith("/"))
      this.currentModuleDir = this.LibHost + this.rootDir + modulePath.split("/").slice(0, -1).join("/");
    else
      this.currentModuleDir = this.LibHost + modulePath.split("/").slice(0, -1).join("/");
    await import(`data:text/javascript,${encodeURIComponent(script)}`);
    document.getElementsByTagName("html")[0].classList.add(applicationStyle);
    this.currentModulePath = "";
    this.currentModuleDir = "";
    if (!_currentDefineModule && this.packages[modulePath]) {
      _currentDefineModule = this.packages[modulePath];
    }
    ;
    if (_currentDefineModule) {
      let module2 = _currentDefineModule.default || _currentDefineModule;
      if (module2) {
        this.id++;
        let elmId = `i-module--${this.id}`;
        let Module2 = class extends module2 {
        };
        this.modulesId[modulePath] = elmId;
        this.modules[modulePath] = Module2;
        customElements.define(elmId, Module2);
        return elmId;
      }
      ;
    }
    ;
    return null;
  }
  async init(scconfigPath, customData) {
    let scconfig = JSON.parse(await this.getContent(scconfigPath));
    if (!scconfig.rootDir) {
      if (scconfigPath.indexOf("/") > 0) {
        let rootDir = scconfigPath.split("/").slice(0, -1).join("/");
        let a = document.createElement("a");
        a.href = rootDir;
        rootDir = a.href.replace(/^[a-zA-Z]{3,5}:\/{2}[a-zA-Z0-9_.:-]+/, "");
        if (!rootDir.startsWith("/"))
          rootDir = "/" + rootDir;
        if (!rootDir.endsWith("/"))
          rootDir = rootDir + "/";
        this.rootDir = rootDir;
        scconfig.rootDir = rootDir;
      } else {
        let rootDir = window.location.pathname;
        if (rootDir.endsWith(".html") || rootDir.endsWith(".htm"))
          rootDir = rootDir.substring(0, rootDir.lastIndexOf("/"));
        if (!rootDir.endsWith("/"))
          rootDir = rootDir + "/";
        this.rootDir = rootDir;
        scconfig.rootDir = rootDir;
      }
      ;
    } else {
      let rootDir = scconfig.rootDir;
      if (!rootDir.startsWith("/"))
        rootDir = "/" + rootDir;
      if (!rootDir.endsWith("/"))
        rootDir = rootDir + "/";
      this.rootDir = rootDir;
      scconfig.rootDir = rootDir;
    }
    ;
    if (customData)
      scconfig.customData = customData;
    return this.newModule(scconfig.main, scconfig);
  }
  async newModule(module2, options) {
    var _a, _b, _c, _d;
    if (options) {
      if (options.main) {
        this._initOptions = options;
      }
      ;
      if (!this._assets && options.assets)
        this._assets = await this.loadPackage(options.assets) || {};
      if (options.dependencies) {
        let packages = [];
        for (let p in options.dependencies) {
          if (p != options.main) {
            packages.push(p);
          }
          ;
        }
        ;
        await this.loadPackages(packages);
      }
      ;
    }
    ;
    if (((_b = (_a = this._initOptions) == null ? void 0 : _a.geo) == null ? void 0 : _b.enabled) && !this.geoInfo) {
      const apiUrl = this._initOptions.geo.apiUrl || "/api/geo/v0";
      const geoResponse = await fetch(apiUrl);
      const geo = await geoResponse.json();
      this.geoInfo = geo;
    }
    ;
    let modulePath = module2;
    if (this._initOptions) {
      if (modulePath != this._initOptions.main && ((_c = this._initOptions.geo) == null ? void 0 : _c.enabled)) {
        try {
          if (this._initOptions.geo.blockedCountries.includes((_d = this.geoInfo) == null ? void 0 : _d.country)) {
            module2 = this._initOptions.geo.moduleOnBlocking;
            modulePath = this.getModulePath(this._initOptions.geo.moduleOnBlocking);
          } else {
            modulePath = this.getModulePath(module2);
          }
        } catch (err) {
          console.log(err);
          module2 = this._initOptions.geo.moduleOnBlocking;
          modulePath = this.getModulePath(this._initOptions.geo.moduleOnBlocking);
        }
      } else {
        modulePath = this.getModulePath(module2);
      }
    }
    ;
    let elmId = this.modulesId[modulePath];
    if (elmId && modulePath) {
      let Module2 = this.modules[modulePath];
      return new Module2(null, options);
    }
    ;
    let script;
    if (options && options.script)
      script = options.script;
    else {
      if (this._initOptions && this._initOptions.modules && this._initOptions.modules[module2] && this._initOptions.modules[module2].dependencies) {
        let dependencies = this._initOptions.modules[module2].dependencies;
        await this.loadPackages(dependencies);
      }
      ;
      try {
        let m = window["require"](module2);
        if (m) {
          let module3 = m.default || m;
          if (module3) {
            this.currentModulePath = modulePath;
            if (modulePath.indexOf("://") > 0)
              this.currentModuleDir = modulePath.split("/").slice(0, -1).join("/");
            else if (!modulePath.startsWith("/"))
              this.currentModuleDir = this.LibHost + this.rootDir + modulePath.split("/").slice(0, -1).join("/");
            else
              this.currentModuleDir = this.LibHost + modulePath.split("/").slice(0, -1).join("/");
            this.id++;
            let elmId2 = `i-module--${this.id}`;
            let Module2 = class extends module3 {
            };
            this.modulesId[modulePath] = elmId2;
            this.modules[modulePath] = Module2;
            customElements.define(elmId2, Module2);
            let result = new Module2(null, options);
            return result;
          }
          ;
        }
      } catch (err) {
      }
      ;
      if (this.bundleLibs[module2])
        script = this.bundleLibs[module2];
      else
        script = await this.getScript(modulePath);
    }
    ;
    if (script) {
      let elmId2 = await this.initModule(modulePath, script);
      if (elmId2) {
        let Module2 = this.modules[modulePath];
        let result = new Module2(null, options);
        return result;
      }
      ;
    }
    ;
    return null;
  }
  async copyToClipboard(value) {
    if (!value)
      return false;
    try {
      if (navigator.clipboard) {
        await navigator.clipboard.writeText(value);
        return true;
      } else {
        const input = document.createElement("input");
        input.value = value;
        input.style.position = "fixed";
        input.style.opacity = "0";
        document.body.appendChild(input);
        input.focus();
        input.select();
        const result = document.execCommand("copy");
        document.body.removeChild(input);
        return result;
      }
    } catch (err) {
      console.log("debug: copy", err);
      return false;
    }
    ;
  }
  xssSanitize(value) {
    return DOMPurify.sanitize(value);
  }
};
window["application"] = Application.Instance;
var application = Application.Instance;

// packages/alert/src/style/alert.css.ts
cssRule("i-alert", {
  $nest: {
    ".modal": {
      padding: 0,
      borderRadius: 4
    }
  }
});

// packages/alert/src/alert.ts
var DEFAULT_VALUES12 = {
  target: "_blank"
};
var Alert = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this.closeModal = () => {
      this.mdAlert.visible = false;
    };
    this.showModal = () => {
      this.renderUI();
      this.mdAlert.visible = true;
    };
    this.closeModal = this.closeModal.bind(this);
  }
  get status() {
    return this._status;
  }
  set status(value) {
    this._status = value;
  }
  get title() {
    return this._title;
  }
  set title(value) {
    this._title = value;
  }
  get content() {
    return this._content;
  }
  set content(value) {
    this._content = value;
  }
  get link() {
    return this._link;
  }
  set link(value) {
    this._link = value;
  }
  get iconName() {
    switch (this.status) {
      case "error":
        return "times";
      case "warning":
      case "confirm":
        return "exclamation";
      case "success":
        return "check";
      default:
        return "spinner";
    }
  }
  get color() {
    switch (this.status) {
      case "error":
        return theme_exports.ThemeVars.colors.error.main;
      case "warning":
      case "confirm":
        return theme_exports.ThemeVars.colors.warning.main;
      case "success":
        return theme_exports.ThemeVars.colors.success.main;
      default:
        return theme_exports.ThemeVars.colors.primary.main;
    }
  }
  renderUI() {
    this.pnlMain.clearInnerHTML();
    const wrapperElm = new VStack(this.pnlMain, {
      horizontalAlignment: "center",
      gap: "1.75rem"
    });
    const border = this.status === "loading" ? {} : {
      border: {
        width: 2,
        style: "solid",
        color: this.color,
        radius: "50%"
      }
    };
    const paddingSize = this.status === "loading" ? "0.25rem" : "0.6rem";
    new Icon(wrapperElm, {
      width: 55,
      height: 55,
      name: this.iconName,
      fill: this.color,
      padding: {
        top: paddingSize,
        bottom: paddingSize,
        left: paddingSize,
        right: paddingSize
      },
      spin: this.status === "loading",
      ...border
    });
    this.renderContent(wrapperElm);
    this.renderLink(wrapperElm);
    this.renderButtons(wrapperElm);
  }
  renderContent(wrapperElm) {
    if (!this.title && !this.content)
      return [];
    const contentElm = new VStack(wrapperElm, {
      horizontalAlignment: "center",
      gap: "0.75rem",
      lineHeight: 1.5
    });
    this.title ? new Label(contentElm, {
      caption: this.title,
      font: { size: "1.25rem", bold: true }
    }) : null;
    this.content ? new Label(contentElm, {
      caption: this.content,
      overflowWrap: "anywhere"
    }) : null;
  }
  renderLink(wrapperElm) {
    if (this.link)
      new Label(wrapperElm, {
        class: "text-center",
        caption: this.link.caption,
        font: { size: "0.875rem" },
        link: { href: this.link.href, target: "_blank" },
        overflowWrap: "anywhere"
      });
  }
  renderButtons(wrapperElm) {
    if (this.status === "confirm") {
      const hStack = new HStack(wrapperElm, {
        verticalAlignment: "center",
        gap: "0.5rem"
      });
      new Button(hStack, {
        padding: {
          top: "0.5rem",
          bottom: "0.5rem",
          left: "2rem",
          right: "2rem"
        },
        caption: "Cancel",
        font: { color: theme_exports.ThemeVars.colors.secondary.contrastText },
        background: { color: theme_exports.ThemeVars.colors.secondary.main },
        onClick: () => {
          if (typeof this.onClose === "function") {
            this.onClose();
          }
          this.closeModal();
        }
      });
      new Button(hStack, {
        padding: {
          top: "0.5rem",
          bottom: "0.5rem",
          left: "2rem",
          right: "2rem"
        },
        caption: "Confirm",
        font: { color: theme_exports.ThemeVars.colors.primary.contrastText },
        onClick: () => {
          if (typeof this.onConfirm === "function") {
            this.onConfirm();
          }
          this.closeModal();
        }
      });
    } else {
      new Button(wrapperElm, {
        padding: {
          top: "0.5rem",
          bottom: "0.5rem",
          left: "2rem",
          right: "2rem"
        },
        caption: "Close",
        font: { color: theme_exports.ThemeVars.colors.primary.contrastText },
        onClick: () => {
          if (typeof this.onClose === "function") {
            this.onClose();
          }
          this.closeModal();
        }
      });
    }
  }
  async init() {
    if (!this.mdAlert) {
      super.init();
      this.status = this.getAttribute("status", true);
      this.title = this.getAttribute("title", true);
      this.content = this.getAttribute("content", true);
      this.link = this.getAttribute("link", true);
      this.onClose = this.getAttribute("onClose", true);
      this.onConfirm = this.getAttribute("onConfirm", true);
      this.mdAlert = await Modal.create({
        width: "400px"
      });
      this.appendChild(this.mdAlert);
      this.pnlMain = new Panel(this, {
        width: "100%",
        padding: {
          top: "1.5rem",
          bottom: "1.5rem",
          left: "1.5rem",
          right: "1.5rem"
        }
      });
      this.mdAlert.item = this.pnlMain;
    }
  }
};
Alert = __decorateClass([
  customElements2("i-alert", {
    icon: "exclamation-circle",
    group: GroupType.BASIC,
    className: "Alert",
    props: {
      status: { type: "string" },
      title: { type: "string" },
      content: { type: "string" },
      link: {
        type: "object",
        default: { target: DEFAULT_VALUES12.target }
      }
    },
    dataSchema: {
      type: "object",
      properties: {
        status: {
          type: "string",
          enum: ["warning", "success", "error", "loading", "confirm"]
        },
        title: {
          type: "string"
        },
        content: {
          type: "string"
        },
        link: {
          type: "object",
          properties: {
            href: {
              type: "string"
            },
            target: {
              type: "string",
              enum: ["_blank", "_self", "_parent", "_top"],
              default: DEFAULT_VALUES12.target
            }
          }
        }
      }
    },
    events: {}
  })
], Alert);

// packages/code-editor/src/monaco.ts
function getLanguageType(fileName) {
  let ext = fileName.split(".").pop();
  switch (ext) {
    case "js":
      return "javascript";
    case "json":
      return "json";
    case "tsx":
    case "ts":
      return "typescript";
    case "css":
      return "css";
    case "sol":
      return "solidity";
    case "txt":
      return "txt";
    case "md":
      return "markdown";
    case "html":
    case "htm":
      return "html";
    case "xml":
      return "xml";
    case "sh":
      return "shell";
  }
}
async function addFile(fileName, content) {
  let monaco = await initMonaco();
  if (monaco) {
    let model = await getFileModel(fileName);
    if (!model) {
      if ((fileName == null ? void 0 : fileName.endsWith(".tsx")) || (fileName == null ? void 0 : fileName.endsWith(".ts")))
        model = monaco.editor.createModel(content || "", "typescript", monaco.Uri.file(fileName));
      else
        model = monaco.editor.createModel(content || "", getLanguageType(fileName) || "", monaco.Uri.file(fileName));
    }
    return model;
  }
  ;
  return null;
}
async function updateFile(fileName, content) {
  let monaco = await initMonaco();
  if (monaco) {
    let model = await getFileModel(fileName);
    if (model) {
      model.setValue(content);
    }
    return model;
  }
  ;
  return null;
}
async function getFileModel(fileName) {
  let monaco = await initMonaco();
  if (monaco) {
    let models = monaco.editor.getModels();
    for (let i = 0; i < models.length; i++) {
      let model = models[i];
      if (model.uri.path == fileName || model.uri.path == "/" + fileName)
        return model;
    }
    ;
  }
  ;
  return null;
}
async function getModels() {
  let monaco = await initMonaco();
  if (monaco) {
    return monaco.editor.getModels();
  }
}
async function addLib(lib, dts) {
  let monaco = await initMonaco();
  monaco.languages.typescript.typescriptDefaults.addExtraLib(dts, lib);
}
async function initMonaco() {
  if (window.monaco)
    return window.monaco;
  return new Promise((resolve) => {
    window.MonacoEnvironment = {};
    RequireJS.config({ paths: { "vs": `${LibPath}lib/monaco-editor/0.32.1/min/vs` } });
    RequireJS.require([`vs/editor/editor.main`], (monaco) => {
      resolve(monaco);
      if (monaco.$loaded)
        return;
      monaco.$loaded = true;
      monaco.languages.typescript.typescriptDefaults.setCompilerOptions({
        experimentalDecorators: true,
        allowSyntheticDefaultImports: true,
        jsx: monaco.languages.typescript.JsxEmit.Preserve,
        moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,
        allowNonTsExtensions: true,
        target: monaco.languages.typescript.ScriptTarget.ES2020
      });
      monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);
      monaco.languages.registerCompletionItemProvider("typescript", {
        triggerCharacters: [">"],
        provideCompletionItems: (model, position) => {
          const code = model.getValueInRange({
            startLineNumber: position.lineNumber,
            startColumn: 1,
            endLineNumber: position.lineNumber,
            endColumn: position.column
          });
          const tag = code.slice(code.lastIndexOf("<") + 1, code.length);
          if (!tag || !tag.endsWith(">") || tag.startsWith("/") || tag.indexOf(" ") > 0)
            return;
          const word = model.getWordUntilPosition(position);
          return {
            suggestions: [
              {
                label: `</${tag}`,
                kind: monaco.languages.CompletionItemKind.EnumMember,
                insertText: `$1</${tag}`,
                insertTextRules: monaco.languages.CompletionItemInsertTextRule.InsertAsSnippet,
                range: {
                  startLineNumber: position.lineNumber,
                  endLineNumber: position.lineNumber,
                  startColumn: word.startColumn,
                  endColumn: word.endColumn
                }
              }
            ]
          };
        }
      });
    });
  });
}

// packages/code-editor/src/style/code-editor.css.ts
cssRule("i-code-editor", {
  $nest: {
    "*": {
      boxSizing: "border-box"
    },
    ".full-height": {
      height: "100vh"
    },
    ".half-width": {
      width: "50%"
    },
    ".column": {
      display: "flex",
      flexDirection: "column",
      alignItems: "stretch"
    },
    ".row": {
      display: "flex",
      flexDirection: "row"
    },
    ".align-right": {
      marginLeft: "auto",
      alignSelf: "stretch"
    },
    "#flex-wrapper": {
      display: "flex",
      alignItems: "stretch"
    },
    "#operation-editor": {
      height: "60vh",
      minHeight: "260px"
    },
    "#variables-editor": {
      height: "30vh",
      alignItems: "stretch"
    },
    "#results-editor": {
      height: "90vh",
      alignItems: "stretch"
    },
    "#toolbar": {
      minHeight: "40px",
      backgroundColor: "#1e1e1e",
      display: "inline-flex",
      alignItems: "stretch"
    },
    "#toolbar > button, #toolbar > select, #toolbar > span, button#execute-op": {
      margin: "4px",
      padding: "4px"
    },
    "#toolbar button, #toolbar select": {
      backgroundColor: "#1e1e1e",
      color: "#eee",
      border: "1px solid #eee",
      borderRadius: "4px"
    },
    "#toolbar button:hover, i-code-editor #toolbar select:hover, i-code-editor #toolbar button:focus, i-code-editor #toolbar select:focus": {
      backgroundColor: "darkslategrey"
    },
    "#execution-tray": {
      display: "inline-flex",
      alignItems: "baseline"
    },
    "#schema-status": {
      fontFamily: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif",
      color: "#eee"
    },
    "#toolbar button.reload-button": {
      border: "0 none",
      padding: "4px",
      width: "30px",
      textAlign: "center"
    }
  }
});

// packages/code-editor/src/code-editor.ts
var CodeEditor = class extends Control {
  get monaco() {
    return window.monaco;
  }
  init() {
    if (!this.editor) {
      super.init();
      let language = this.getAttribute("language", true);
      if (language)
        this.language = language;
      this.style.display = "inline-block";
      if (this.language)
        this.loadContent(void 0, this.language);
    }
    ;
  }
  get editor() {
    return this._editor;
  }
  focus() {
    this._editor.focus();
  }
  setCursor(line2, column) {
    this.editor.setPosition({ lineNumber: line2, column });
  }
  get language() {
    return this._language;
  }
  set language(value) {
    this._language = value;
    if (!this.editor) {
      this.loadContent();
    } else {
      let monaco = this.monaco;
      let model = this.editor.getModel();
      if (model) {
        monaco.editor.setModelLanguage(model, value);
      }
    }
  }
  get designMode() {
    return this._designMode;
  }
  set designMode(value) {
    this._designMode = value;
    if (this.editor)
      this.editor.updateOptions({ readOnly: value });
  }
  async loadContent(content, language, fileName) {
    let monaco = await initMonaco();
    if (content == void 0)
      content = content || this._value || "";
    this._value = content;
    language = language || this._language || "typescript";
    this._language = language;
    if (!this._editor) {
      let captionDiv = this.createElement("div", this);
      captionDiv.style.display = "inline-block";
      captionDiv.style.height = "100%";
      captionDiv.style.width = "100%";
      const customOptions = this._options || {};
      let options = {
        theme: "vs-dark",
        tabSize: 2,
        formatOnPaste: true,
        formatOnType: true,
        renderWhitespace: "none",
        automaticLayout: true,
        readOnly: this._designMode,
        minimap: {
          enabled: false
        },
        ...customOptions
      };
      this._editor = monaco.editor.create(captionDiv, options);
      this._editor.onDidChangeModelContent((event) => {
        if (typeof this.onChange === "function")
          this.onChange(this, event);
      });
      this._editor.onKeyDown((event) => {
        if (typeof this.onKeyDown === "function") {
          this.onKeyDown(this, event);
        }
      });
      this._editor.onKeyUp((event) => {
        if (typeof this.onKeyUp === "function") {
          this.onKeyUp(this, event);
        }
      });
      if (fileName) {
        let model = await getFileModel(fileName);
        if (model) {
          this._editor.setModel(model);
          model.setValue(content);
          return;
        }
      }
      ;
      if (language == "typescript" || (fileName == null ? void 0 : fileName.endsWith(".tsx")) || (fileName == null ? void 0 : fileName.endsWith(".ts"))) {
        let model = monaco.editor.createModel(content || this._value || "", "typescript", fileName ? monaco.Uri.file(fileName) : void 0);
        this._editor.setModel(model);
      } else {
        let model = monaco.editor.createModel(content || this._value || "", language || this._language, fileName ? monaco.Uri.file(fileName) : void 0);
        this._editor.setModel(model);
      }
      ;
    } else {
      let model = this._editor.getModel();
      if (language == "typescript" && model && fileName && this._fileName != fileName) {
        if (!this._fileName)
          model.dispose();
        model = await getFileModel(fileName);
        if (!model) {
          model = monaco.editor.createModel(content || this._value || "", "typescript", monaco.Uri.file(fileName));
        }
        this._editor.setModel(model);
      } else {
        this._editor.setValue(content);
        if (language && model)
          monaco.editor.setModelLanguage(model, language);
      }
      ;
    }
    ;
    this._fileName = fileName || "";
    this._editor.setScrollTop(0);
  }
  async updateFileName(oldValue, newValue) {
    let oldModel = await getFileModel(oldValue);
    if (oldModel) {
      if (!oldModel) {
        console.error("Model not found");
        return;
      }
      let newModel = await getFileModel(newValue);
      const newUri = this.monaco.Uri.parse(newValue);
      if (!newModel)
        newModel = this.monaco.editor.createModel(oldModel.getValue(), oldModel.getLanguageId(), newUri);
      newModel.setValue(oldModel.getValue());
      this.editor.setModel(newModel);
      oldModel.dispose();
    }
  }
  dispose() {
    var _a;
    if (this._editor) {
      (_a = this._editor.getModel()) == null ? void 0 : _a.dispose();
    }
  }
  async disposeEditor() {
    var _a;
    if (this._editor) {
      (_a = this._editor.getModel()) == null ? void 0 : _a.dispose();
      const models = await getModels() || [];
      for (let i = 0; i < models.length; i++) {
        const model = models[i];
        model.dispose();
      }
      this._editor.dispose();
      const domNode = this._editor.getDomNode();
      if (domNode) {
        if (this.contains(domNode))
          this.removeChild(domNode);
        domNode.remove();
      }
    }
  }
  scrollToLine(line2, column) {
    const topOffset = this._editor.getTopForPosition(line2, column);
    this._editor.setScrollTop(topOffset);
  }
  async loadFile(fileName) {
    var _a;
    let model = await getFileModel(fileName);
    if (model) {
      if (!this._fileName)
        (_a = this._editor.getModel()) == null ? void 0 : _a.dispose();
      this._fileName = fileName;
      this._editor.setModel(model);
    }
    ;
  }
  updateOptions(options) {
    this._options = options;
    if (this._editor)
      this._editor.updateOptions(options);
  }
  get value() {
    if (this._editor)
      return this._editor.getValue();
    else
      return this._value;
  }
  set value(value) {
    this._value = value;
    if (this._editor) {
      this._editor.setValue(value);
      this._editor.setScrollTop(0);
    } else
      this.loadContent();
  }
};
CodeEditor.addLib = addLib;
CodeEditor.addFile = addFile;
CodeEditor.getFileModel = getFileModel;
CodeEditor.updateFile = updateFile;
CodeEditor = __decorateClass([
  customElements2("i-code-editor", {
    icon: "code",
    group: GroupType.FIELDS,
    className: "CodeEditor",
    props: {
      language: {
        type: "string",
        default: ""
      }
    },
    events: {
      onChange: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "Event" }
      ],
      onKeyDown: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "KeyboardEvent" }
      ],
      onKeyUp: [
        { name: "target", type: "Control", isControl: true },
        { name: "event", type: "KeyboardEvent" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        language: {
          type: "string"
        }
      }
    }
  })
], CodeEditor);

// packages/code-editor/src/diff-editor.ts
var EditorType;
(function(EditorType2) {
  EditorType2[EditorType2["modified"] = 0] = "modified";
  EditorType2[EditorType2["original"] = 1] = "original";
})(EditorType || (EditorType = {}));
var CodeDiffEditor = class extends Control {
  init() {
    if (!this.editor) {
      super.init();
      this.language = this.getAttribute("language", true);
      this.style.display = "inline-block";
    }
    ;
  }
  get editor() {
    return this._editor;
  }
  get language() {
    return this._language;
  }
  set language(value) {
    this._language = value;
    if (!this.editor) {
      if (this.language) {
        this.loadContent(1, "", this.language);
        this.loadContent(0, "", this.language);
      }
    } else {
      this.setModelLanguage(value, "getOriginalEditor");
      this.setModelLanguage(value, "getModifiedEditor");
    }
  }
  get designMode() {
    return this._designMode;
  }
  set designMode(value) {
    this._designMode = value;
    if (this.editor)
      this.editor.updateOptions({ readOnly: value });
  }
  setModelLanguage(value, functionName) {
    let monaco = window.monaco;
    let model = this.editor[functionName]().getModel();
    if (model) {
      monaco.editor.setModelLanguage(model, value);
    }
  }
  dispose() {
    if (this._editor) {
      const originalModel = this.getModel(1);
      const modifiedModel = this.getModel(0);
      if (originalModel) {
        originalModel.dispose();
      }
      if (modifiedModel) {
        modifiedModel.dispose();
      }
    }
  }
  updateFileName() {
  }
  getEditor(type) {
    if (type === 1)
      return this.editor.getOriginalEditor();
    else
      return this.editor.getModifiedEditor();
  }
  getModel(type) {
    return this.getEditor(type).getModel();
  }
  async loadContent(type, content, language, fileName) {
    var _a;
    let monaco = await initMonaco();
    let initialSetup = true;
    const funcName = type === 0 ? "getModifiedEditor" : "getOriginalEditor";
    const value = type === 0 ? this._modifiedValue : this._originalValue;
    const newFileName = `${type}` + fileName;
    if (content == void 0)
      content = content || value || "";
    type === 0 ? this._modifiedValue = content : this._originalValue = content;
    language = language || this._language || "typescript";
    this._language = language;
    if (!this._editor) {
      let captionDiv = this.createElement("div", this);
      captionDiv.style.display = "inline-block";
      captionDiv.style.height = "100%";
      captionDiv.style.width = "100%";
      let options = {
        theme: "vs-dark",
        originalEditable: false,
        automaticLayout: true,
        readOnly: this._designMode
      };
      this._editor = monaco.editor.createDiffEditor(captionDiv, options);
      (_a = this._editor.getModifiedEditor()) == null ? void 0 : _a.onDidChangeModelContent((event) => {
        if (typeof this.onChange === "function")
          this.onChange(this, event);
      });
      if (fileName) {
        let model2 = await getFileModel(newFileName);
        if (model2) {
          this.editor[funcName]().setModel(model2);
          model2.setValue(content);
          return;
        }
      }
      ;
    }
    let model = this.getModel(type);
    if (model && model.getValue() === content && this._fileName === fileName) {
      return;
    }
    if (model) {
      if (fileName && this._fileName !== fileName) {
        initialSetup = true;
        model.dispose();
        model = await getFileModel(newFileName);
        if (!model)
          model = monaco.editor.createModel(content || value || "", language || this._language || "typescript", monaco.Uri.file(newFileName));
        this._editor[funcName]().setModel(model);
        this._editor[funcName]().setValue(content);
      } else {
        this.getEditor(type).setValue(content);
        if (language && model)
          monaco.editor.setModelLanguage(model, language);
      }
      ;
    } else {
      let model2 = await getFileModel(newFileName);
      if (!model2) {
        const file = fileName ? monaco.Uri.file(newFileName) : void 0;
        if (language == "typescript" || (fileName == null ? void 0 : fileName.endsWith(".tsx")) || (fileName == null ? void 0 : fileName.endsWith(".ts"))) {
          model2 = monaco.editor.createModel(content || value || "", "typescript", file);
        } else
          model2 = monaco.editor.createModel(content || value || "", language || this._language || "typescript", file);
      }
      initialSetup = true;
      this._editor[funcName]().setModel(model2);
    }
    this._fileName = fileName || "";
  }
  updateOptions(options) {
    this.editor.updateOptions(options);
  }
  get originalValue() {
    if (this.editor)
      return this.editor.getOriginalEditor().getValue();
    else
      return this._originalValue;
  }
  set originalValue(value) {
    this._originalValue = value;
    if (this.editor) {
      this.editor.getOriginalEditor().setValue(value);
    } else
      this.loadContent(1);
  }
  get modifiedValue() {
    if (this.editor)
      return this.editor.getModifiedEditor().getValue();
    else
      return this._modifiedValue;
  }
  set modifiedValue(value) {
    this._modifiedValue = value;
    if (this.editor) {
      this.editor.getModifiedEditor().setValue(value);
    } else {
      this.loadContent(0);
    }
  }
};
CodeDiffEditor.addLib = addLib;
CodeDiffEditor.addFile = addFile;
CodeDiffEditor.getFileModel = getFileModel;
CodeDiffEditor.updateFile = updateFile;
CodeDiffEditor = __decorateClass([
  customElements2("i-code-diff-editor")
], CodeDiffEditor);

// packages/data-grid/src/dataGrid.ts
var import_moment3 = __toModule(require_moment());

// packages/data-grid/src/style/dataGrid.css.ts
var Theme26 = theme_exports.ThemeVars;
cssRule("i-data-grid", {
  border: "0.5px solid #dadada",
  $nest: {
    ".container": {
      position: "absolute",
      overflow: "hidden",
      height: "100%",
      width: "100%"
    },
    ".scrollBox": {
      overflow: "auto",
      position: "absolute",
      height: "100%",
      width: "100%",
      top: 0,
      zIndex: 4
    },
    ".grid": {
      position: "absolute",
      fontSize: "12px",
      fontFamily: '"Segoe UI", Tahoma, Arial, Helvetica, sans-serif',
      color: "#5A5757",
      borderSpacing: 0,
      tableLayout: "fixed"
    },
    ".grid tr": {
      overflow: "hidden"
    },
    ".grid tr div": {
      paddingLeft: "2px",
      paddingRight: "2px"
    },
    ".grid_cell_hidden": {
      display: "none"
    },
    ".grid_fixed_cell": {
      background: "#F9F9F9",
      borderBottom: "0.5px solid #dadada",
      borderRight: "0.5px solid #dadada",
      boxSizing: "border-box"
    },
    ".grid_curr_cell": {
      border: "2px solid #5f5f5f",
      boxSizing: "border-box"
    },
    ".grid_selected_cell": {
      backgroundColor: "rgb(160, 195, 255)",
      pointerEvents: "none",
      opacity: 0.2
    },
    ".grid_cell": {
      borderBottom: "0.5px solid #dadada",
      borderRight: "0.5px solid #dadada",
      boxSizing: "border-box",
      background: "white",
      cursor: "default"
    },
    ".grid_cell_value": {
      textOverflow: "ellipsis",
      wordWrap: "break-word",
      whiteSpace: "pre",
      width: "100%"
    },
    ".grid_cell_value.image img": {
      maxHeight: "100%",
      maxWidth: "100%"
    },
    ".grid_header_splitter": {
      position: "relative",
      zoom: 1,
      filter: "alpha(opacity=50)",
      opacity: 0.5,
      float: "right",
      cursor: "e-resize"
    },
    "input": {
      border: "none",
      outline: "none"
    },
    "table": {
      marginLeft: "1px",
      marginTop: "1px"
    }
  }
});

// packages/data-grid/src/dataGrid.ts
function parseNumber(value, decimal) {
  if (typeof value == "string")
    value = value.replace(/,/g, "");
  if (decimal)
    return parseFloat(parseFloat(value).toFixed(decimal));
  else
    return parseFloat(value);
}
function getCursorPosX(event) {
  event = event || window.event;
  let pos = 0;
  if (event instanceof TouchEvent) {
    if (event.changedTouches && event.changedTouches[0])
      pos = event.changedTouches[0].pageX || event.changedTouches[0].clientX;
    else if (event.touches && event.touches[0])
      pos = event.touches[0].pageX || event.touches[0].clientX;
  } else
    pos = event.pageX || event.clientX;
  return pos + document.body.scrollLeft + document.documentElement.scrollLeft;
}
function getCursorPosY(event) {
  event = event || window.event;
  let pos = 0;
  if (event instanceof TouchEvent) {
    if (event.changedTouches && event.changedTouches[0])
      pos = event.changedTouches[0].pageY || event.changedTouches[0].clientY;
    else if (event.touches && event.touches[0])
      pos = event.touches[0].pageY || event.touches[0].clientY;
  } else
    pos = event.pageY || event.clientY;
  return pos + document.body.scrollTop + document.documentElement.scrollTop;
}
var TGridOptions = class {
  constructor(owner) {
    this._autoRowHeight = false;
    this._rowSelect = false;
    this.autoAddRow = false;
    this.fileDropUpload = false;
    this.sortOnClick = true;
    this.owner = owner;
  }
  get autoRowHeight() {
    return this._autoRowHeight;
  }
  set autoRowHeight(value) {
    if (value != this._autoRowHeight) {
      this.owner.rowHeights = [];
      this._autoRowHeight = value;
      this.owner.enableUpdateTimer();
    }
    ;
  }
  get rowSelect() {
    return this._rowSelect;
  }
  set rowSelect(value) {
    if (this._rowSelect != value) {
      this._rowSelect = value;
      this.owner.enableUpdateTimer();
    }
    ;
  }
};
var DataGridCell = class {
  constructor(grid, col, row) {
    this._visible = true;
    this.grid = grid;
    this._col = col;
    this._row = row;
  }
  get button() {
    return this._button;
  }
  set button(value) {
    this._button = value;
    this.grid.enableUpdateTimer();
  }
  get checkBox() {
    return this._checkBox;
  }
  set checkBox(value) {
    this._checkBox = value;
    this.grid.enableUpdateTimer();
  }
  get col() {
    return this._col;
  }
  set col(value) {
    this._col = value;
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this.grid.enableUpdateTimer();
  }
  get displayValue() {
    return;
  }
  get formula() {
    return this._formula;
  }
  set formula(value) {
    this._formula = value;
    this.grid.enableUpdateTimer();
  }
  get hint() {
    return this._hint;
  }
  set hint(value) {
    this._hint = value;
    this.grid.enableUpdateTimer();
  }
  get horizontalAlign() {
    return this._horizontalAlign;
  }
  set horizontalAlign(value) {
    this._horizontalAlign = value;
    this.grid.enableUpdateTimer();
  }
  get html() {
    return this._html;
  }
  set html(value) {
    this._html = value;
    this.grid.enableUpdateTimer();
  }
  get image() {
    return this._image;
  }
  set image(value) {
    this._image = value;
    this.grid.enableUpdateTimer();
  }
  get object() {
    return this._object;
  }
  set object(value) {
    this._object = value;
    this.grid.enableUpdateTimer();
  }
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(value) {
    this._readOnly = value;
    this.grid.enableUpdateTimer();
  }
  get row() {
    return this._row;
  }
  set row(value) {
    this._row = value;
  }
  get text() {
    return this._text;
  }
  set text(value) {
    this._text = value;
    this.grid.enableUpdateTimer();
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.grid.enableUpdateTimer();
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.grid.enableUpdateTimer();
  }
};
var DataGridCells = class {
  constructor(owner) {
    this.data = [[]];
    this.grid = owner;
  }
  assign(data) {
    for (let r = 0; r < data.length; r++) {
      let d = data[r]["data"];
      let row = data[r]["row"];
      for (let c = 0; c < d.length; c++) {
        this.setValue(c, row, d[c]);
      }
    }
  }
  cells(aCol, aRow, refresh2) {
    if (refresh2)
      return this.getCell(aCol, aRow);
    else if (this.data[aRow]) {
      let cell = this.data[aRow][aCol];
      if (cell && cell.mergeRect && (aCol != cell.mergeRect.startCol || aRow != cell.mergeRect.startRow)) {
        cell = this.data[cell.mergeRect.startRow][cell.mergeRect.startCol];
      }
      return cell || this.getCell(aCol, aRow);
    } else
      return this.getCell(aCol, aRow);
  }
  clear() {
    this.data = [[]];
  }
  deleteCol(aCol) {
    for (let r = 0; r < this.data.length; r++) {
      let row = this.data[r];
      if (row)
        row.splice(aCol, 1);
    }
    this.updateCellIndex();
  }
  deleteRow(aRow) {
    if (this.data.length > aRow)
      this.data.splice(aRow, 1);
    this.updateCellIndex();
  }
  getCell(aCol, aRow, refresh2) {
    if (typeof this.data[aRow] == "undefined")
      this.data[aRow] = [];
    if (typeof this.data[aRow][aCol] == "undefined")
      this.data[aRow][aCol] = new DataGridCell(this.grid, aCol, aRow);
    if (refresh2 && this.data[aRow][aCol])
      this.data[aRow][aCol]._displayValue = void 0;
    return this.data[aRow][aCol];
  }
  getObject(aCol, aRow) {
    let cell = this.cells(aCol, aRow);
    if (cell)
      return cell.object;
    else
      return void 0;
  }
  getValue(aCol, aRow) {
    let cell = this.cells(aCol, aRow);
    if (cell) {
      if (cell.mergeRect)
        cell = this.getCell(cell.mergeRect.startCol, cell.mergeRect.startRow);
      if (cell.value != void 0) {
        return cell.value;
      } else
        return "";
    }
    ;
  }
  getExcelValue(aCol, aRow, callback) {
  }
  getExcelValues(startCol, startRow, callback) {
  }
  getExcelValues1(startCol, startRow, callback) {
  }
  insertCol(aCol) {
    for (let r = 0; r < this.data.length; r++) {
      let row = this.data[r];
      if (row)
        row.splice(aCol, 0, void 0);
    }
    this.updateCellIndex();
  }
  insertRow(aRow) {
    this.data.splice(aRow, 0, []);
    this.updateCellIndex();
  }
  loadFromJSON(json) {
    let data = json["data"];
    for (let i = 0; i < data.length; i++) {
      let row = data[i];
      for (let k = 0; k < row.length; k++) {
        let cell = row[k];
        if (cell)
          this.setValue(k, i, cell["v"]);
      }
    }
  }
  moveRow(fromIdx, toIdx) {
    if (toIdx < this.data.length) {
      this.data.splice(toIdx, 0, this.data.splice(fromIdx, 1)[0]);
      this.updateCellIndex();
    }
  }
  saveToJSON(json) {
    let data = [];
    json["data"] = data;
    for (let i = 0; i < this.data.length; i++) {
      let row = this.data[i];
      data[i] = [];
      for (let k = 0; k < row.length; k++) {
        let cell = row[k];
        if (cell)
          data[i][k] = {
            "v": cell._value
          };
      }
    }
  }
  setDateValue(aCol, aRow, aValue) {
    let cell = this.getCell(aCol, aRow);
    cell._value = aValue;
    cell._isDate = true;
  }
  setMergeCell(rect) {
    for (let col = rect.startCol; col <= rect.endCol; col++)
      for (let row = rect.startRow; row <= rect.endRow; row++) {
        let cell = this.getCell(col, row);
        cell.mergeRect = rect;
      }
  }
  setObject(aCol, aRow, aObject) {
    let cell = this.getCell(aCol, aRow);
    cell.object = aObject;
  }
  setRowCount(value) {
    if (this.data.length > value)
      this.data.length = value;
  }
  setValue(aCol, aRow, aValue, disp) {
    let cell = this.getCell(aCol, aRow);
    if (!disp)
      cell._value = aValue;
    else
      cell._dispValue = aValue;
  }
  setFile(aCol, aRow, aValue) {
    let cell = this.getCell(aCol, aRow);
    cell._file = aValue;
  }
  sort(col, descending) {
    let fixedRow = this.data.slice(0, this.grid.fixedRow);
    let data = this.data.slice(this.grid.fixedRow);
    for (let i = 0; i < data.length; i++) {
      if (data[i] && data[i][col])
        data[i][col]._idx = i;
    }
    ;
    let self = this;
    data.sort(function(item1, item2) {
      if (self.grid["onSort"]) {
        if (item1[col] && item2[col])
          return self.grid["onSort"](self.grid, descending, col, item1[col]._row, item2[col].row);
        else if (item1[col]) {
          if (descending)
            return -1;
          else
            return 1;
        } else {
          if (descending)
            return 1;
          else
            return -1;
        }
      } else {
        let value1;
        let value2;
        let idx1 = 0;
        let idx2 = 0;
        ;
        if (item1[col]) {
          value1 = item1[col]._displayValue || item1[col]._value;
          idx1 = item1[col]._idx;
        }
        if (value1 == void 0)
          value1 = "";
        if (item2[col]) {
          value2 = item2[col]._displayValue || item2[col]._value;
          idx2 = item2[col]._idx;
        }
        if (value2 == void 0)
          value2 = "";
        if (typeof value1 == "string")
          value1 = value1.toLowerCase();
        if (typeof value2 == "string")
          value2 = value2.toLowerCase();
        if (value1 == value2)
          return idx1 > idx2 ? 1 : idx1 < idx2 ? -1 : 0;
        else if (value1 > value2)
          return descending ? -1 : 1;
        else
          return descending ? 1 : -1;
      }
    });
    this.data = fixedRow.concat(data);
    this.updateCellIndex();
  }
  updateCellIndex() {
    for (let r = 0; r < this.data.length; r++) {
      let row = this.data[r];
      for (let c = 0; c < row.length; c++) {
        let cell = this.data[r][c];
        if (cell) {
          cell._col = c;
          cell._row = r;
        }
        ;
      }
      ;
    }
    ;
  }
};
var TGridColumn = class {
  constructor(grid, colIdx) {
    this._visible = true;
    this._resizable = true;
    this._sortable = true;
    this._readOnly = false;
    this.grid = grid;
    this._colIdx = colIdx;
    if (!this._type)
      this._type = "string";
  }
  get asJSON() {
    return {
      "color": this._color && this._color != "clNone" ? this._color : void 0,
      "horizontalAlign": this._horizontalAlign != void 0 && this._horizontalAlign != 1 ? this._horizontalAlign : void 0,
      "type": this._type && this._type != "string" ? this._type : void 0,
      "width": this.width,
      "readOnly": this._readOnly ? this._readOnly : void 0,
      "visible": !this._visible ? this._visible : void 0,
      "resizable": !this._resizable ? this._resizable : void 0,
      "lookupContext": this._lookupContext ? this._lookupContext : void 0,
      "lookupTable": this._lookupTable ? this._lookupTable : void 0,
      "suggestTable": this._suggestTable ? this._suggestTable : void 0,
      "lookupField": this._lookupField ? this._lookupField : void 0,
      "lookupDetailField": this._lookupDetailField ? this._lookupDetailField : void 0,
      "lookupDetailValue": this._lookupDetailValue ? this._lookupDetailValue : void 0,
      "lookupDetailType": this._lookupDetailType ? this._lookupDetailType : void 0,
      "listOfValue": this._listOfValue ? this._listOfValue : void 0,
      "format": this._format ? this._format : void 0,
      "formula": this._formula ? this._formula : void 0,
      "displayUserName": this._displayUserName,
      "binding": this._binding
    };
  }
  set asJSON(value) {
    this._color = value.color;
    this._horizontalAlign = value["horizontalAlign"] != void 0 ? value["horizontalAlign"] : value["alignment"];
    this._type = value["type"] || value["dataType"];
    this._readOnly = value["readOnly"];
    this._visible = value["visible"];
    this._resizable = value["resizable"];
    this._lookupContext = value["lookupContext"];
    this._lookupTable = value["lookupTable"];
    this._lookupField = value["lookupField"];
    this._suggestTable = value["suggestTable"];
    this._lookupDetailField = value["lookupDetailField"];
    this._lookupDetailValue = value["lookupDetailValue"];
    this._lookupDetailType = value["lookupDetailType"];
    this._listOfValue = value["listOfValue"];
    this._displayUserName = value["displayUserName"];
    this._format = value["format"];
    this._formula = value["formula"];
    this._binding = value["binding"];
    if (value["width"] != void 0)
      this["width"] = value["width"];
    if (value["rows"] && value["rows"] > 1)
      this._rows = value["rows"];
    this.grid.enableUpdateTimer();
  }
  get binding() {
    return this._binding;
  }
  set binding(value) {
    this._binding = value;
  }
  get colIdx() {
    return this._colIdx;
  }
  set colIdx(value) {
    if (this.colIdx > -1)
      this.grid.columns[this.colIdx] = null;
    this._colIdx = value;
    this.grid.columns[value] = this;
    this.grid.enableUpdateTimer();
  }
  get color() {
    return this._color || "clNone";
  }
  set color(value) {
    this._color = value;
    this.grid.enableUpdateTimer();
  }
  get comboItems() {
    return this._comboItems;
  }
  set comboItems(value) {
    this._comboItems = value;
    this.grid.enableUpdateTimer();
  }
  get default() {
    return (!this._color || this._color == "clNone") && (this._horizontalAlign == void 0 || this._horizontalAlign == 1) && (!this._type || this._type == "string") && !this._readOnly && this._visible && !this._dataType && this._resizable && !this._lookupContext && !this._lookupTable && !this._lookupField && !this._listOfValue;
  }
  get format() {
    return this._format;
  }
  set format(value) {
    this._format = value;
    this.grid.enableUpdateTimer();
  }
  get formula() {
    return this._formula;
  }
  set formula(value) {
    this._formula = value;
    this.grid.enableUpdateTimer();
  }
  get horizontalAlign() {
    return this._horizontalAlign || 1;
  }
  set horizontalAlign(value) {
    this._horizontalAlign = value;
    this.grid.enableUpdateTimer();
  }
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(value) {
    this._readOnly = value;
    this.grid.enableUpdateTimer();
  }
  get resizable() {
    return this._resizable !== false;
  }
  set resizable(value) {
    this._resizable = value;
    this.grid.enableUpdateTimer();
  }
  get sortable() {
    return this._sortable !== false;
  }
  set sortable(value) {
    this._sortable = value;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
    switch (value) {
      case "checkBox":
        this._dataType = "boolean";
        break;
      case "comboBox":
        this._dataType = "string";
        break;
      case "datePicker":
        this._dataType = "date";
        break;
      case "dateTimePicker":
        this._dataType = "dateTime";
        break;
      case "integer":
        this._dataType = "integer";
        break;
      case "number":
        this._dataType = "number";
        break;
      case "string":
        this._dataType = "string";
        break;
      case "timePicker":
        this._dataType = "time";
        break;
      default:
        this._dataType = "string";
        break;
    }
    this.grid.enableUpdateTimer();
  }
  get dataType() {
    return this._dataType;
  }
  get visible() {
    return this._visible !== false;
  }
  set visible(value) {
    this._visible = value;
    this.grid.enableUpdateTimer();
  }
  get width() {
    return this.grid.getColWidth(this._colIdx);
  }
  set width(value) {
    this.grid.setColWidth(this._colIdx, value);
    this.grid.enableUpdateTimer();
  }
};
var TGridColumns = class {
  constructor(grid) {
    this.columns = [];
    this.grid = grid;
  }
  clear() {
    this.columns = [];
  }
  deleteCol(aCol) {
    this.columns.splice(aCol, 1);
    this.updateColIndex();
  }
  getColumn(index) {
    if (index > this.columns.length) {
      let len = this.columns.length;
      for (let i = len; i <= index; i++)
        this.columns.push("");
    }
    let col = this.columns[index];
    if (!col) {
      col = new TGridColumn(this.grid, index);
      this.columns[index] = col;
    }
    return col;
  }
  insertCol(colIdx) {
    let col = new TGridColumn(this.grid, colIdx);
    this.columns.splice(colIdx, 0, col);
    this.updateColIndex();
  }
  loadFromJSON(value) {
    this.count = value.length;
    for (let i = 0; i < value.length; i++) {
      if (value[i]) {
        let col = this.getColumn(i);
        if (value[i]["colIdx"] == void 0)
          value[i]["colIdx"] = i;
        col["asJSON"] = value[i];
      }
    }
    this.grid.colCount = this.count;
  }
  _loadFromJSON(value) {
    this.loadFromJSON(value);
  }
  saveToJSON() {
    let result = [];
    let withValue = false;
    for (let i = 0; i < this.columns.length; i++) {
      if (this.columns[i] && !this.columns[i]["default"]) {
        withValue = true;
        result.push(this.columns[i]["asJSON"]);
      } else
        result.push("");
    }
    if (withValue)
      return result;
  }
  setColCount(value) {
    this.columns.length = value;
  }
  updateColIndex() {
    for (let i = 0; i < this.columns.length; i++)
      this.columns[i]._colIdx = i;
  }
};
var TGridRow = class {
  constructor(grid) {
    this._visible = true;
    this._resizable = false;
    this.grid = grid;
    if (!this._type)
      this._type = "string";
  }
  get color() {
    return this._color;
  }
  set color(value) {
    this._color = value;
    this.grid.enableUpdateTimer();
  }
  get comboItems() {
    return this._comboItems;
  }
  set comboItems(value) {
    this._comboItems = value;
    this.grid.enableUpdateTimer();
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this.grid.enableUpdateTimer();
  }
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(value) {
    this._readOnly = value;
    this.grid.enableUpdateTimer();
  }
  get resizable() {
    return this._resizable;
  }
  set resizable(value) {
    this._resizable = value;
    this.grid.enableUpdateTimer();
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
    switch (value) {
      case "checkBox":
        this._dataType = "boolean";
        break;
      case "comboBox":
        this._dataType = "string";
        break;
      case "datePicker":
        this._dataType = "date";
        break;
      case "dateTimePicker":
        this._dataType = "dateTime";
        break;
      case "integer":
        this._dataType = "integer";
        break;
      case "number":
        this._dataType = "number";
        break;
      case "string":
        this._dataType = "string";
        break;
      case "timePicker":
        this._dataType = "time";
        break;
      default:
        this._dataType = "string";
        break;
    }
    this.grid.enableUpdateTimer();
  }
  get dataType() {
    return this._dataType;
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    this._visible = value;
    this.grid.enableUpdateTimer();
  }
};
var TGridRows = class {
  constructor(grid, defaultHeight) {
    this.rows = [];
    this.grid = grid;
    this.defaultHeight = defaultHeight;
  }
  clear() {
    this.rows = [];
  }
  getHeight(index) {
    let row = this.rows[index];
    if (row)
      return row.height;
    else
      return this.defaultHeight;
  }
  getRow(index) {
    let row = this.rows[index];
    if (!row) {
      row = new TGridRow(this.grid);
      this.rows[index] = row;
    }
    ;
    return row;
  }
};
var DataGrid = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._listOfValue = {};
    this._defaultRowHeight = 19;
    this._defaultColWidth = 64;
    this._layout = "grid";
    this.mergeRect = [];
    this.tableCells = [[]];
    this.tableSplitters = [];
    this.selectedCells = [];
    this.selectedCellsHighlight = [];
    this._colCount = 3;
    this._rowCount = 3;
    this.colWidths = [];
    this._rowHeights = [];
    this._fixedCol = 0;
    this._fixedRow = 1;
    this._leftCol = 0;
    this._topRow = 1;
    this._row = 0;
    this._col = 0;
    this._scrollLeft = 0;
    this._scrollTop = 0;
    this.showDataInternalFlag = false;
    this._sorting = false;
    this._updateTableInternalFlag = false;
    this._totalColWidth = 0;
    this._totalRowHeight = 0;
    this.visibleRowCount = 0;
    this.visibleColCount = 0;
    this.sortingDescending = false;
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  get fixedCol() {
    return this._fixedCol;
  }
  set fixedCol(value) {
    this._fixedCol = value;
    if (this._leftCol < this._fixedCol)
      this._leftCol = this._fixedCol;
  }
  get fixedRow() {
    return this._fixedRow;
  }
  set fixedRow(value) {
    this._fixedRow = value;
    if (this._topRow < this._fixedRow)
      this._topRow = this._fixedRow;
  }
  get layout() {
    return this._layout;
  }
  set layout(value) {
    this._layout = value;
  }
  async init() {
    await super.init();
    this._init();
  }
  _init() {
    this._fixedCol = 0;
    this._fixedRow = 1;
    this._leftCol = 0;
    this._topRow = 1;
    this.options = new TGridOptions(this);
    this.placeHolder = this.createElement("div", this);
    this._table = this.createElement("table", this);
    this.data = new DataGridCells(this);
    this.columns = new TGridColumns(this);
    this.gridRows = new TGridRows(this, this._defaultRowHeight);
    this.cellHighlight = this.createElement("div", this);
    this.placeHolder.style.position = "absolute";
    this.cellHighlight.className = "grid_curr_cell";
    this.cellHighlight.style.position = "absolute";
    this.cellHighlight.style.display = "none";
    this.cellHighlight.style.zIndex = "3";
    this.selectedRangeHighlight = this.createElement("div", this);
    this.selectedRangeHighlight.className = "grid_selected_cell";
    this.selectedRangeHighlight.style.position = "absolute";
    this.selectedRangeHighlight.style.display = "none";
    this.selectedRangeHighlight.style.zIndex = "3";
    this._table.className = "grid";
    this._table.style.tableLayout = "fixed";
    this._table.style.position = "relative";
    this.tableContainer = this.createElement("div", this);
    this.tableContainer.className = "container";
    this.tableContainer.appendChild(this._table);
    this._scrollBox = this.createElement("div", this);
    this._scrollBox.className = "scrollBox";
    this._scrollBox.tabIndex = 0;
    this._scrollBox.appendChild(this.placeHolder);
    this.edit = this.createElement("input", this);
    this.edit.setAttribute("autocomplete", "disabled");
    this.edit.className = "grid_edit";
    this.edit.style.border = "0px";
    this.edit.style.width = "10px";
    this.edit.style.height = "10px";
    this.edit.style.position = "absolute";
    this.edit.style.top = "-100px";
    this.edit.style.left = "-100px";
    this.style.overflow = "hidden";
    this.style.backgroundColor = "#FFFFFF";
    this._height = 89;
    this._width = 324;
    this.colWidths = [];
    this._scrollLeft = 0;
    this._scrollTop = 0;
    this._scrollBox.addEventListener("mousewheel", (event) => {
      console.dir(event);
      let delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail));
      this._handleMouseWheel(event, delta);
    });
    this._handleInput = this._handleInput.bind(this);
    this._handleDragOver = this._handleDragOver.bind(this);
    this._handleFileDrop = this._handleFileDrop.bind(this);
    this.edit.addEventListener("input", this._handleInput);
    this.edit.addEventListener("propertychange", this._handleInput);
    this.addEventListener("dragover", this._handleDragOver);
    this.addEventListener("drop", this._handleFileDrop);
    this._scrollBox.onscroll = this._handleScroll.bind(this);
    this.setCurrCell(this._fixedCol, this._fixedRow);
    this._updateLanguage();
    this._updateListOfValues();
    this.enableUpdateTimer(true, true);
  }
  calcTopRow(rowIdx) {
    if (rowIdx == this._fixedRow)
      return rowIdx;
    let row = rowIdx;
    let height = this._scrollBox.clientHeight;
    if (this.layout == "card") {
    } else {
      for (let i = 0; i < this._fixedRow; i++)
        height = height - this.getRowHeight(i) - 0.8;
      height = height - this.getRowHeight(row);
      while (row > this._fixedRow) {
        let h = this.getRowHeight(row) + 0.8;
        height = height - h;
        if (height < h - 4) {
          return row - 1;
        }
        ;
        row--;
      }
    }
    return row;
  }
  cells(aCol, aRow, refresh2) {
    return this.data.getCell(aCol, aRow, refresh2);
  }
  get col() {
    return this._col;
  }
  set col(value) {
    this._col = value;
  }
  get row() {
    return this._row;
  }
  set row(value) {
    this._row = value;
  }
  get colCount() {
    return this._colCount;
  }
  set colCount(value) {
    this._colCount = value;
    this.enableUpdateTimer(false, true);
  }
  get readOnly() {
    return this._readOnly;
  }
  set readOnly(value) {
    this._readOnly = value;
  }
  get rowCount() {
    return this._rowCount;
  }
  set rowCount(value) {
    this._rowCount = value;
    this.enableUpdateTimer(true, false);
  }
  get topRow() {
    return this._topRow;
  }
  set topRow(value) {
    this._topRow = value;
  }
  _updateRowHeights(row) {
    let height = this._defaultRowHeight;
    for (let col = 0; col < this._colCount; col++) {
      let cell = this.data.cells(col, row);
      if (cell && cell._height && cell._height > height) {
        height = cell._height;
      }
    }
    ;
    this._rowHeights[row] = height;
    this._updateTotalRowHeight();
    return height;
  }
  setObject(aCol, aRow, aObject) {
    if (this.data)
      this.data.setObject(aCol, aRow, aObject);
  }
  setJSONValue(value, prop, newValue) {
    let obj;
    try {
      if (value)
        obj = JSON.parse(value);
      else
        obj = {};
    } catch (err) {
      obj = {};
    }
    obj[prop] = newValue;
    return JSON.stringify(obj);
  }
  updateBindingData(cell, column) {
    column = column || this.columns.getColumn(cell._col);
    if (column && column.binding) {
      let obj = this.getObject(0, cell._row);
      if (!obj) {
        obj = {};
        this.setObject(0, this._row, obj);
      }
      obj[column.binding] = cell._value;
    }
  }
  _updateCurrCellValue(editor) {
    console.dir("### _updateCurrCellValue");
    let cardViewEditor = false;
    if (editor)
      cardViewEditor = true;
    if (this.editorMode || this._cardPanel) {
      let oldValue = this.data.getValue(this._col, this._row);
      editor = editor || this.editor;
      if (!editor || editor._isModified === false)
        return;
      let cell = this.data.getCell(this._col, this._row);
      let rowOrColDataType = this.cols(this._col).dataType;
      let rowOrColType = this.cols(this._col).type;
      if (rowOrColDataType == "boolean" && rowOrColType == "checkBox") {
        cell._value = editor.checked;
      } else if (rowOrColDataType == "date" && rowOrColType == "datePicker") {
        cell._value = editor.value;
      } else if (rowOrColDataType == "dateTime" && rowOrColType == "dateTimePicker") {
        cell._value = editor.value;
      } else if (rowOrColDataType == "time" && rowOrColType == "timePicker") {
        cell._value = editor.value;
      } else if (rowOrColDataType == "string" && rowOrColType == "comboBox") {
        cell._value = editor.value.value;
      } else if (rowOrColDataType == "number" && rowOrColType == "number") {
        cell._value = parseFloat(editor.value);
      } else if (rowOrColDataType == "integer" && rowOrColType == "integer") {
        cell._value = parseInt(editor.value);
      } else {
        let newValue;
        if (editor.valueCode)
          newValue = editor.valueCode;
        else if (editor.getText)
          newValue = editor.getText();
        else
          newValue = application.xssSanitize(editor.value);
        let text = "";
        if (editor.getText)
          text = editor.getText();
        else
          text = newValue;
        if (cell.mergeRect && (this._col != cell.mergeRect.startCol || this._row != cell.mergeRect.startRow))
          cell = this.data.getCell(cell.mergeRect.startCol, cell.mergeRect.startRow);
        if (true) {
          if (this.options._autoRowHeight) {
            let div = this._currCell.div;
            div.textContent = text;
            let height = div.clientHeight + 3;
            if (cell.mergeRect) {
              height = height / (cell.mergeRect.endRow - cell.mergeRect.startRow + 1);
              for (let i = cell.mergeRect.startRow; i <= cell.mergeRect.endRow; i++) {
                cell._height = height;
                this._updateRowHeights(i);
              }
            } else {
              cell._height = height;
              this._updateRowHeights(this._row);
            }
          } else
            this._currCell.div.textContent = text;
        }
        cell._value = newValue;
        this.origValue = void 0;
        if (!cardViewEditor)
          this.enableUpdateTimer();
        if (cell._field) {
          if (!cell._record) {
            let column = this.columns.getColumn(cell._col);
            let record = this.getObject(0, cell._row);
            let rs = record[cell._lookupTable];
            cell._record = rs.append();
            let v = column._lookupDetailValue;
            switch (column._lookupDetailType) {
              case "date":
                v = new Date(v);
                v.setHours(0, 0, 0, 0);
                break;
              case "numeric":
                if (typeof v == "string")
                  v = parseFloat(v);
                break;
            }
            ;
            cell._record[column._lookupDetailField] = v;
          }
          cell._record[cell._field] = newValue;
        } else if (this._dataBindingContext) {
          let record = this.getObject(0, this._row);
          let field = this.getObject(this._col, 0);
          let idx = 0;
          let jsonValue;
          if (typeof field == "number") {
            idx = field;
            field = this.dataBinding["fields"][idx];
            if (this.dataBinding["jsonValues"])
              jsonValue = this.dataBinding["jsonValues"][idx];
          }
          this.data.getCell(0, this._row)._newRow = false;
          let fieldType = this.dataBinding["fieldTypes"][idx];
          if (fieldType == "float")
            newValue = parseNumber(newValue);
          else if (fieldType == "integer")
            newValue == Math.round(parseNumber(newValue));
          else if (editor && editor["dataType"] == "dtNumber")
            newValue = parseNumber(newValue);
          if (!record && field) {
            record = this._dataBindingContext["append"]();
            this.setObject(0, this._row, record);
          }
          if (record && field) {
            if (jsonValue)
              newValue = this.setJSONValue(record[field], jsonValue, newValue);
            if (record[field] != newValue)
              record[field] = newValue;
          }
          if (true)
            this.enableUpdateTimer();
        }
        this.updateBindingData(cell);
        if (this.onCellChange)
          this.onCellChange(this, cell, oldValue, newValue);
      }
      this.enableUpdateTimer();
    }
    ;
  }
  hideEditor(updateValue) {
    this.edit.value = "";
    if (updateValue && this.editor && this.editor["dataType"] == "dtUserAccount") {
      let editor = this.editor;
      editor["dataType"] = "";
      this.editor = null;
      let self = this;
      return;
    }
    if (updateValue && this.editor && this.editor["dataType"] == "dtFile")
      updateValue = false;
    else if (this.editor && this.editor.buildInEditor && this.editor["dataType"] == "dtLookup") {
      this.editor["onChange"] = void 0;
      this.editor.hide(updateValue);
    }
    if (updateValue)
      this._updateCurrCellValue();
    if (this.editor) {
      this.editorMode = false;
      let editor = this.editor;
      this.editor = void 0;
      this.removeChild(editor);
      this.edit.removeEventListener("propertychange", this._handleInput);
      this.edit.removeEventListener("input", this._handleInput);
      this.edit.value = "";
      this.edit.addEventListener("propertychange", this._handleInput);
      this.edit.addEventListener("input", this._handleInput);
      this.focus();
      this.edit.focus();
      if (this.onEditModeChanged)
        this.onEditModeChanged(this);
    }
    ;
  }
  checkEmptyRow(row) {
    let cell = this.data.getCell(0, row);
    if (cell._newRow != void 0)
      return cell._newRow;
    for (let i = 0; i < this._colCount; i++) {
      if (this.data.getValue(i, row) != "" && this.data.getValue(i, row) != void 0) {
        return false;
      }
    }
    return true;
  }
  setRowCount(aRowCount) {
    if (this._rowCount != aRowCount) {
      this._rowCount = aRowCount;
      if (this._row >= this._rowCount || this._row < this._fixedRow)
        this._row = this._fixedRow;
      this.data.setRowCount(aRowCount);
      this.refresh();
      this.enableUpdateTimer(true);
    }
  }
  refresh() {
    super.refresh();
    this.highlightCurrCell();
    if (this._scrollBox) {
      this._scrollBox.style.height = this.heightValue + "px";
      this._scrollBox.style.width = this.widthValue + "px";
    }
    ;
  }
  deleteRow(row) {
    if (this._dataBindingContext && this._dataBindingContext["readOnly"])
      return;
    this.data.deleteRow(row);
    if (this._rowHeights.length > row)
      this._rowHeights.splice(row, 1);
    this.setRowCount(this._rowCount - 1);
    if (this._dataBindingContext) {
      let record = this.getObject(0, this._row);
      if (record && this._dataBindingContext["current"] !== record) {
        if (this._bindingRecordSet)
          this._bindingRecordSet["current"] = record;
        this._dataBindingContext["current"] = record;
      }
    }
    ;
    this.enableUpdateTimer();
  }
  getObject(aCol, aRow) {
    return this.data.getObject(aCol, aRow);
  }
  getValue(col, row) {
    return this.data.getValue(col, row);
  }
  setScrollLeft() {
    console.dir("#setScrollLeft");
    this._scrollBox.onscroll = null;
    clearTimeout(this._restScrollboxHandler);
    clearTimeout(this._setScrollLeftInterval);
    this._setScrollLeftInterval = setTimeout(() => {
      this.setScrollLeftInternal();
      this._restScrollboxHandler = setTimeout(() => {
        this._scrollBox.onscroll = this._handleScroll.bind(this);
      }, 10);
    }, 10);
  }
  setScrollLeftInternal() {
    if (this._leftCol == this._fixedCol) {
      this._scrollBox.scrollLeft = 0;
      this._scrollLeft = this._scrollBox.scrollLeft;
    } else {
      let w = 0;
      for (let i = 0; i < this._fixedCol; i++)
        w = w + this.getColWidth(i) + 0.8;
      for (let i = this._leftCol; i < this._colCount; i++)
        w = w + this.getColWidth(i) + 0.8;
      this._scrollBox.scrollLeft = this._scrollBox.scrollWidth - w;
      this._scrollLeft = this._scrollBox.scrollLeft;
    }
    ;
  }
  setScrollTop() {
    this._scrollBox.onscroll = null;
    clearInterval(this._restScrollboxHandler);
    clearInterval(this._setScrollTopInterval);
    this._setScrollTopInterval = setTimeout(() => {
      this.setScrollTopInternal();
      this._restScrollboxHandler = setTimeout(() => {
        this._scrollBox.onscroll = this._handleScroll.bind(this);
      }, 10);
    }, 10);
  }
  setScrollTopInternal() {
    console.dir("setScrollTopInternal");
    if (this._topRow == this._fixedRow) {
      this._scrollBox.scrollTop = 0;
      this._scrollTop = this._scrollBox.scrollTop;
    }
    if (this.layout == "card") {
    } else {
      let h = 0;
      for (let i = 0; i < this._fixedRow; i++)
        h = h + this.getRowHeight(i) + 0.8;
      for (let i = this._topRow; i < this._rowCount; i++)
        h = h + this.getRowHeight(i) + 0.8;
      this._scrollBox.scrollTop = this._scrollBox.scrollHeight - h;
      this._scrollTop = this._scrollBox.scrollTop;
    }
    ;
  }
  setLeftCol(aLeftCol, skipSetScroll) {
    if (aLeftCol != this._leftCol) {
      if (this.editorMode) {
        this.hideEditor(true);
      }
      ;
      if (aLeftCol < this._fixedCol)
        this._leftCol = this._fixedCol;
      else if (aLeftCol >= this._colCount)
        this._leftCol = this._colCount - 1;
      else
        this._leftCol = aLeftCol;
      this.showData(100);
      if (!skipSetScroll)
        this.setScrollLeft();
      this.enableUpdateTimer();
    }
  }
  setTopRow(row, skipSetScroll) {
    if (row != this._topRow) {
      if (this.editorMode) {
        this.hideEditor(true);
      }
      ;
      if (row < this._fixedRow)
        this._topRow = this._fixedRow;
      else if (row >= this._rowCount)
        this._topRow = this._rowCount - 1;
      else
        this._topRow = row;
      this.showData(100);
      if (!skipSetScroll)
        this.setScrollTop();
      this.enableUpdateTimer();
    }
    ;
  }
  showData(interval) {
    let self = this;
    self.showDataFlag = true;
    if (self._showDataTimeout) {
      clearTimeout(self._showDataTimeout);
    }
    if (interval && !self._refreshDataTimeout) {
      self._refreshDataTimeout = setTimeout(function() {
        clearTimeout(self._refreshDataTimeout);
        self._refreshDataTimeout = void 0;
      }, 10);
    }
    ;
    self._showDataTimeout = setTimeout(function() {
      if (self._refreshDataTimeout) {
        clearTimeout(self._refreshDataTimeout);
        self._refreshDataTimeout = void 0;
      }
      clearTimeout(self._showDataTimeout);
      self._showDataTimeout = void 0;
      if (self.showDataFlag) {
        self.showDataFlag = false;
        self._updateTableInternal();
        if (!self["_destroyed"])
          self.showDataInternal();
      }
    }, 100);
  }
  getTableCellByActualIndex(aColIdx, aRowIdx) {
    let aCol;
    let aRow;
    if (aColIdx < this._fixedCol)
      aCol = aColIdx;
    else
      aCol = aColIdx - this._leftCol + this._fixedCol;
    if (aRowIdx < this._fixedRow)
      aRow = aRowIdx;
    else
      aRow = aRowIdx - this._topRow + this._fixedRow;
    for (let i = this._topRow; i < aRow; i++) {
      if (this.gridRows.rows[i] && this.gridRows.rows[i]._visible == false)
        aRow--;
    }
    if (aRow >= this._fixedRow && aCol >= this._fixedCol && this.tableCells[aRow] && this.tableCells[aRow][aCol])
      return this.tableCells[aRow][aCol];
    else
      return void 0;
  }
  getTableCell(aColIdx, aRowIdx) {
    if (this.tableCells && this.tableCells[aRowIdx])
      return this.tableCells[aRowIdx][aColIdx];
    else
      return void 0;
  }
  highlightCurrCell() {
    var _a, _b, _c;
    this._currCell = this.getTableCellByActualIndex(this._col, this._row);
    if (!this.options._rowSelect) {
      if (!this._currCell) {
        if (this.cellHighlight)
          this.cellHighlight.style.display = "none";
        return;
      }
      ;
    }
    ;
    this.highlightSelectedCell();
    this.selectedRangeHighlight.style.display = "none";
    if (this._currCell || this.options._rowSelect && this._row < this._rowCount) {
      if (this.options._rowSelect) {
        this.cellHighlight.style.display = "block";
        if (this._currCell) {
          this.cellHighlight.style.display = "";
          this.cellHighlight.style.top = this._currCell.offsetTop - 1 + "px";
          this.cellHighlight.style.height = this._currCell.offsetHeight + 1 + "px";
        } else
          this.cellHighlight.style.display = "none";
        this.cellHighlight.style.left = "0px";
        if (this._totalColWidth + 2 < this.tableContainer.clientWidth)
          this.cellHighlight.style.width = this._totalColWidth + 2 + "px";
        else
          this.cellHighlight.style.width = this.tableContainer.clientWidth + 2 + "px";
      } else if (this._currCell) {
        let tableCell = this.getTableCell(this._col, this._row);
        if (tableCell && this._currCell.cell) {
          let edit = this.edit;
          edit.value = this._currCell.cell._displayValue || this._currCell.cell._value || "";
          if (edit instanceof HTMLInputElement)
            edit.setSelectionRange(0, edit.value.length);
        } else {
          this.edit.value = "";
        }
        ;
        this.cellHighlight.style.display = "block";
        let parentRect = this.getBoundingClientRect();
        let elemRect = (_a = this._currCell) == null ? void 0 : _a.getBoundingClientRect();
        this.cellHighlight.style.top = this._currCell.offsetTop + "px";
        this.cellHighlight.style.left = this._currCell.offsetLeft + "px";
        if ((_b = this._currCell) == null ? void 0 : _b.offsetWidth)
          this.cellHighlight.style.width = this._currCell.offsetWidth + 1 + "px";
        else
          this.cellHighlight.style.width = "0px";
        if ((_c = this._currCell) == null ? void 0 : _c.offsetHeight)
          this.cellHighlight.style.height = this._currCell.offsetHeight + 1 + "px";
        else
          this.cellHighlight.style.height = "0px";
      }
      ;
    } else {
      this.cellHighlight.style.display = "none";
    }
    if (this._currCell && this._currCell.cell)
      this.cellHighlight.title = this._currCell.cell._hint || "";
    else
      this.cellHighlight.title = "";
  }
  setCurrCell(aCol, aRow, triggerEvent) {
    if (this._col == aCol && this._row == aRow)
      return;
    this.selectedCells = [];
    let cell = this.data.getCell(aCol, aRow);
    let idx = this.selectedCells.indexOf(cell);
    if (idx < 0) {
      this.selectedCells.push(cell);
    } else {
      this.selectedCells.splice(idx, 1);
    }
    this.highlightSelectedCell();
    if (this.editorMode) {
      this.hideEditor(true);
    }
    ;
    if (aCol < this._fixedCol)
      aCol = this._fixedCol;
    if (aRow < this._fixedRow)
      aRow = this._fixedRow;
    let rowChange = false;
    if (aCol < this._colCount && aRow < this._rowCount) {
      this._col = aCol;
      if (this._row != aRow) {
        rowChange = true;
        if (!this._readOnly && this.options._autoAddRow && this._row == this._rowCount - 1 && this.checkEmptyRow(this._row)) {
          if (this._dataBindingContext) {
            let record = this.getObject(0, this._row);
            if (record)
              this._dataBindingContext["delete"](record);
            this.deleteRow(this._row);
          } else
            this._rowCount = this._rowCount - 1;
          this.enableUpdateTimer();
        }
      }
      this._row = aRow;
      if (aCol < this._leftCol)
        this.setLeftCol(aCol);
      if (aRow < this._topRow)
        this.setTopRow(aRow);
      if (this._scrollBox.clientWidth > 0) {
        let topRow = this.calcTopRow(aRow);
        if (topRow > this._topRow)
          this.setTopRow(topRow);
        let leftCol = this.calcLeftCol(aCol);
        if (leftCol > this._leftCol)
          this.setLeftCol(leftCol);
      }
      this.highlightCurrCell();
      if (rowChange) {
        let record = this.getObject(0, this._row);
        if (this._bindingRecordSet && this._bindingRecordSet["current"] !== record)
          this._bindingRecordSet["current"] = record;
        if (this._dataBindingContext && this._dataBindingContext["current"] !== record) {
          this._skipRefreshData = true;
          if (this._bindingRecordSet)
            this._bindingRecordSet["current"] = record;
          this._dataBindingContext["current"] = record;
        }
        if (triggerEvent && this.onRowChange) {
          this.onRowChange(this);
        }
      }
      if (triggerEvent && this.onCellSelect) {
        this.onCellSelect(this, cell);
      }
    }
    ;
  }
  highlightSelectedCell() {
    if (this.selectedCells.length > 1) {
      let idx = {};
      for (let i = 0; i < this.selectedCells.length; i++) {
        let cell = this.selectedCells[i];
        idx[cell.col + "-" + cell.row] = false;
      }
      for (let i = this.selectedCellsHighlight.length - 1; i > -1; i--) {
        let div = this.selectedCellsHighlight[i];
        if (typeof idx[div.col + "-" + div.row] == "undefined") {
          this.removeChild(this.selectedCellsHighlight[i]);
          this.selectedCellsHighlight["splice"](i, 1);
        } else
          idx[div.col + "-" + div.row] = true;
      }
      for (let i = 0; i < this.selectedCells.length; i++) {
        let cell = this.selectedCells[i];
        if (idx[cell["col"] + "-" + cell["row"]] == false) {
          let tableCell = this.getTableCellByActualIndex(cell.col, cell.row);
          if (tableCell) {
            let div = this.createElement("div", this);
            this.appendChild(div);
            this.selectedCellsHighlight.push(div);
            div.className = "grid_selected_cell";
            div.style.position = "absolute";
            div.style.display = "block";
            div.style.zIndex = "3";
            div.col = cell["col"];
            div.row = cell["row"];
            div.style.top = tableCell.offsetTop + "px";
            div.style.left = tableCell.offsetLeft + "px";
            div.style.width = tableCell.offsetWidth + "px";
            div.style.height = tableCell.offsetHeight + "px";
          }
          ;
        }
        ;
      }
      ;
    } else {
      for (let i = this.selectedCellsHighlight.length - 1; i > -1; i--)
        this.removeChild(this.selectedCellsHighlight[i]);
      this.selectedCellsHighlight = [];
    }
    ;
  }
  _updateLanguage() {
  }
  _updateListOfValues() {
  }
  _handleScrollHorizontal(sender) {
    if (sender.scrollLeft == 0) {
      this.setLeftCol(this._fixedCol, true);
      return;
    }
    let width = sender.scrollWidth - sender.scrollLeft - sender.clientWidth;
    for (let i = 0; i < this._fixedCol; i++)
      width = width - this.getColWidth(i) - 1;
    for (let i = this._colCount - 1; i > 0; i--) {
      let w = this.getColWidth(i);
      width = width - w - 1;
      if (width <= 0) {
        let col = this.calcLeftCol(i);
        this.setLeftCol(col, true);
        break;
      }
    }
    this.highlightCurrCell();
  }
  _handleScrollVertical(sender) {
    if (sender.scrollTop == 0) {
      if (this._cardPanel)
        this._cardPanel["setTop"](0);
      this.setTopRow(this._fixedRow, true);
      return;
    }
    if (this.layout == "card") {
    } else {
      let height = sender.scrollHeight - sender.scrollTop - sender.clientHeight;
      for (let i = 0; i < this._fixedRow; i++) {
        height = height - this.getRowHeight(i);
      }
      for (let i = this._rowCount - 1; i > 0; i--) {
        let h = this.getRowHeight(i);
        height = height - h;
        if (height <= 0) {
          let row = this.calcTopRow(i);
          this.setTopRow(row, true);
          break;
        }
      }
      ;
    }
    this.highlightCurrCell();
  }
  _handleScroll(event) {
    let target = event.target;
    clearTimeout(this.scrollHorizontalTimer);
    clearTimeout(this.scrollVerticalTimer);
    if (this._scrollLeft != target.scrollLeft) {
      this._scrollLeft = target.scrollLeft;
      this.scrollHorizontalTimer = setTimeout(() => {
        this._handleScrollHorizontal(target);
      }, 10);
    } else if (this._scrollTop != target.scrollTop) {
      this._scrollTop = target.scrollTop;
      this.scrollVerticalTimer = setTimeout(() => {
        this._handleScrollVertical(target);
      }, 10);
    }
  }
  _handleFileDrop(event) {
    console.dir("## _handleFileDrop");
  }
  _handleDragOver(event) {
    console.dir("## _handleDragOver");
  }
  _handleInput(event) {
    this.showEditor(this.edit.value);
  }
  _handleMouseWheel(event, delta) {
    console.dir("## _handleMouseWheel");
  }
  getColLeft(aCol) {
    let cell = this.getTableCellByActualIndex(aCol, 1);
    if (cell)
      return cell.offsetLeft;
    let r = 0;
    for (let i = 0; i < this._fixedCol; i++) {
      r = r + this.getColWidth(i);
    }
    for (let i = this._leftCol; i < aCol; i++) {
      r = r + this.getColWidth(i);
    }
    return r;
  }
  getColRight(aCol) {
    let cell = this.getTableCellByActualIndex(aCol, 1);
    if (cell)
      return cell.offsetLeft + this.getColWidth(aCol);
    let r = 0;
    for (let i = 0; i < this._fixedCol; i++) {
      r = r + this.getColWidth(i);
      if (i == aCol)
        return r;
    }
    ;
    for (let i = this._leftCol; i < aCol; i++) {
      r = r + this.getColWidth(i);
    }
    ;
    return r + this.getColWidth(aCol);
  }
  getColWidth(col) {
    let column = this.cols(col);
    if (column && column._visible === false)
      return 0;
    let w = this.colWidths[col];
    if (w != void 0)
      return w;
    else
      return this._defaultColWidth;
  }
  getRowHeight(row) {
    let h = this._rowHeights[row];
    if (h)
      return h;
    else
      return this._defaultRowHeight;
  }
  _updateTotalRowHeight() {
    this._totalRowHeight = 0;
    for (let i = 0; i < this._rowCount; i++) {
      this._totalRowHeight = this._totalRowHeight + this.getRowHeight(i) + 0.8;
    }
    this.placeHolder.style.height = this._totalRowHeight + "px";
  }
  _updateTotalColWidth() {
    this._totalColWidth = 0;
    for (let i = 0; i < this._colCount; i++) {
      this._totalColWidth = this._totalColWidth + this.getColWidth(i);
    }
    if (this._totalColWidth < parseFloat(this["width"].toString()))
      this.placeHolder.style.width = "100%";
    else
      this.placeHolder.style.width = this._totalColWidth + "px";
  }
  _updateTableRows() {
    for (let i = this._table.rows.length - 1; i >= 0; i--) {
      this._table.deleteRow(i);
    }
    this.visibleRowCount = Math.round(this.heightValue / this._defaultRowHeight) + 1;
    if (this.visibleRowCount > this._rowCount)
      this.visibleRowCount = this._rowCount;
    for (let i = this._table.rows.length; i < this.visibleRowCount; i++) {
      let r = this._table.insertRow(this._table.rows.length);
    }
    ;
  }
  getActualColIdx(col) {
    if (col < this._fixedCol)
      return col;
    else
      return col + this._leftCol - this._fixedCol;
  }
  getActualRowIdx(row) {
    if (row < this._fixedRow)
      return row;
    else {
      let result = row + this._topRow - this._fixedRow;
      for (let i = this._topRow; i <= result; i++) {
        if (this.gridRows.rows[i] && this.gridRows.rows[i]._visible == false)
          result++;
      }
      ;
      return result;
    }
    ;
  }
  cols(colIdx) {
    return this.columns.getColumn(colIdx);
  }
  rows(rowIdx) {
    return this.gridRows.getRow(rowIdx);
  }
  _updateTableCellDiv(tableCell, col, row) {
    if (!tableCell.div) {
      let div = this.createElement("div");
      tableCell.div = div;
      div.owner = this;
      if (row < this._fixedRow)
        tableCell.className = "header grid_fixed_cell";
      else if (col < this._fixedCol)
        tableCell.className = "grid_fixed_cell";
      let actCol = this.getActualColIdx(col);
      let actRow = this.getActualRowIdx(row);
      let cell = this.data.cells(actCol, actRow);
      let w = 0;
      let h = 0;
      if (cell && cell.mergeRect) {
        let divRect = this.createElement("div");
        divRect.style.overflow = "hidden";
        divRect.style.position = "relative";
        tableCell.appendChild(divRect);
        w = this.getColWidth(cell.mergeRect.startCol) - 2;
        h = this.getRowHeight(cell.mergeRect.startRow) - 1;
        for (let i = cell.mergeRect.startCol + 1; i <= cell.mergeRect.endCol; i++)
          w = w + this.getColWidth(i) - 2;
        for (let i = cell.mergeRect.startRow + 1; i <= cell.mergeRect.endRow; i++)
          h = h + this.getRowHeight(i) - 2;
        let left = 0;
        let top = 0;
        if (cell.mergeRect.startCol > this._fixedCol && cell.mergeRect.startCol < this._leftCol) {
          for (let i = cell.mergeRect.startCol; i < this._leftCol; i++)
            left = left + this.getColWidth(i) - 2;
        }
        if (cell.mergeRect.startRow > this._fixedRow && cell.mergeRect.startRow < this._topRow) {
          for (let i = cell.mergeRect.startRow; i < this._topRow; i++)
            top = top + this.getRowHeight(i) - 1;
        }
        divRect.appendChild(div);
        divRect.style.width = w - left + "px";
        divRect.style.height = h - top + "px";
        div.style.position = "absolute";
        div.style.left = -left + "px";
        div.style.top = -top + "px";
      } else {
        w = this.getColWidth(actCol) - 2;
        let column = this.cols(actCol);
        if (column && column._visible === false)
          tableCell.className += " grid_cell_hidden";
        h = this.getRowHeight(actRow) - 2;
        if (row < this._fixedRow)
          tableCell.style.minWidth = w + "px";
        tableCell.style.position = "relative";
        tableCell.appendChild(div);
      }
      div.style.width = w + "px";
      div.style.height = "auto";
      div.style.whiteSpace = "wrap";
      div.style.maxHeight = h + "px";
      div.style.overflow = "hidden";
      if (col == 0)
        div.style.minHeight = h + "px";
      div.className = "grid_cell_value";
    }
    ;
  }
  _updateTableCols() {
    let w = 0;
    for (let i = 0; i < this._fixedCol; i++)
      w = w + this.getColWidth(i);
    this.visibleColCount = this._fixedCol;
    let width = this.widthValue;
    if (width == 0)
      this._needUpdate = true;
    else
      this._needUpdate = false;
    for (let i = this._leftCol; i < this._colCount; i++) {
      w = w + this.getColWidth(i);
      if (this.visibleColCount < this._colCount)
        this.visibleColCount++;
      if (w >= width)
        break;
    }
    ;
    for (let row = 0; row < this._table.rows.length; row++) {
      let r = this._table.rows[row];
      this.tableCells[row] = [];
      for (let col = 0; col < this.visibleColCount; col++) {
        let tableCell = r.insertCell(r.cells.length);
        if (col == 0)
          tableCell.style.height = this._defaultRowHeight + "px";
        tableCell.owner = this;
        if ((col + this._leftCol) % 2 == 0)
          tableCell.className = "grid_cell even_col";
        else
          tableCell.className = "grid_cell odd_col";
        if ((row + this._topRow) % 2 == 0)
          tableCell.className += " even_row";
        else
          tableCell.className += " odd_row";
        this._updateTableCellDiv(tableCell, col, row);
        this.tableCells[row][col] = tableCell;
        if (row == 0 && (col < this._fixedCol && col == this.sortingCol || (col >= this._fixedCol && col + (this._leftCol > 0 ? this._leftCol - this._fixedCol : 0)) == this.sortingCol)) {
          tableCell.style.position = "relative";
          let elm = this.createElement("div");
          elm.style.position = "absolute";
          elm.style.width = "6px";
          elm.style.height = "6px";
          elm.style.right = "4px";
          if (this.sortingDescending) {
            elm.style.top = "2px";
            elm.className = "fa fa-sort-desc";
          } else {
            elm.style.top = "6px";
            elm.className = "fa fa-sort-asc";
          }
          tableCell.appendChild(elm);
        }
      }
    }
  }
  setColWidth(aColIndex, width, trigerEvent) {
    let orig = 0;
    orig = this.colWidths[aColIndex];
    this.colWidths[aColIndex] = width;
    for (let i = 0; i < this.tableCells.length; i++) {
      let tableCell = this.getTableCell(aColIndex, i);
      let tableCellDiv = tableCell == null ? void 0 : tableCell.div;
      let column = this.cols(aColIndex);
      if (tableCell && tableCell.div && !column._checkBox && !column._radioButton)
        tableCellDiv.style.width = width - 3 + "px";
    }
    for (let i = 0; i < this._rowCount; i++) {
      let cell = this.cells(aColIndex, i);
      if (cell)
        cell._height = void 0;
    }
    if (trigerEvent && this.onColResize) {
      if (this.resizeTimer)
        clearTimeout(this.resizeTimer);
      this.resizeTimer = setTimeout(() => {
        this.onColResize(this, aColIndex, width);
      }, 50);
    }
    this.enableUpdateTimer(true, true);
  }
  _updateTableMergedCells() {
    console.dir("### _updateTableMergedCells");
  }
  sort(col, descending) {
    let currRow = this.data.data[this._row];
    if (this.editorMode)
      this.hideEditor();
    this._rowHeights = [];
    if (this.data.data.length > this._rowCount)
      this.data.data.length = this._rowCount;
    if (col >= 0)
      this.data.sort(col, descending);
    this.sortingDescending = descending || false;
    this.sortingCol = col;
    if (currRow)
      this._row = this.data.data.indexOf(currRow);
    this.enableUpdateTimer();
  }
  getEditor(col, row, cell, inputValue) {
    let colOrRowType = this.columns.getColumn(col).type;
    if (colOrRowType == "checkBox") {
      let editor = new Checkbox(void 0, {
        checked: cell.value != void 0 ? cell.value : false
      });
      editor.style.marginLeft = "1px";
      editor.className = "grid_edit";
      this.appendChild(editor);
      return editor;
    } else if (colOrRowType == "datePicker") {
      let editor = new Datepicker(void 0, {
        type: "date",
        width: this.getColWidth(cell.col) - 1
      });
      editor.className = "grid_edit";
      this.appendChild(editor);
      if (cell.value != void 0) {
        editor.value = cell.value;
      } else {
        editor.value = import_moment3.default.unix(import_moment3.default.now() / 1e3);
      }
      let inputElm = editor.getElementsByTagName("input")[0];
      inputElm.style.height = "";
      inputElm.style.padding = "0px";
      inputElm.style.backgroundColor = "white";
      let btn = editor.getElementsByClassName("datepicker-toggle")[0];
      btn.style.backgroundColor = "white";
      return editor;
    } else if (colOrRowType == "timePicker") {
      let editor = new Datepicker(void 0, {
        type: "time",
        width: this.getColWidth(cell.col) - 1
      });
      editor.className = "grid_edit";
      this.appendChild(editor);
      if (cell.value != void 0) {
        editor.value = cell.value;
      } else {
        editor.value = import_moment3.default.unix(import_moment3.default.now() / 1e3);
      }
      let inputElm = editor.getElementsByTagName("input")[0];
      inputElm.style.height = "";
      inputElm.style.padding = "0px";
      inputElm.style.backgroundColor = "white";
      let btn = editor.getElementsByClassName("datepicker-toggle")[0];
      btn.style.backgroundColor = "white";
      return editor;
    } else if (colOrRowType == "dateTimePicker") {
      let editor = new Datepicker(void 0, {
        type: "dateTime",
        width: this.getColWidth(cell.col) - 1
      });
      editor.className = "grid_edit";
      this.appendChild(editor);
      if (cell.value != void 0) {
        editor.value = cell.value;
      } else {
        editor.value = import_moment3.default.unix(import_moment3.default.now() / 1e3);
      }
      let inputElm = editor.getElementsByTagName("input")[0];
      inputElm.style.height = "";
      inputElm.style.padding = "0px";
      inputElm.style.backgroundColor = "white";
      let btn = editor.getElementsByClassName("datepicker-toggle")[0];
      btn.style.backgroundColor = "white";
      return editor;
    } else if (colOrRowType == "comboBox") {
      let colOrRowComboItems = this.cols(col).comboItems;
      let _selectedItem = colOrRowComboItems[0];
      for (let i = 0; i < colOrRowComboItems.length; i++) {
        if (cell.value === colOrRowComboItems[i].value) {
          _selectedItem = colOrRowComboItems[i];
          break;
        }
      }
      let editor = new ComboBox(void 0, {
        items: colOrRowComboItems,
        selectedItem: _selectedItem,
        icon: { name: "caret-down", width: "16px", height: "16px" }
      });
      editor.className = "grid_edit comboBoxEditor";
      this.appendChild(editor);
      let rowHeight = this.getRowHeight(cell.row);
      let selectionElm = editor.getElementsByClassName("selection")[0];
      selectionElm.style.maxWidth = `100%`;
      selectionElm.style.padding = "0px";
      let inputElm = selectionElm.getElementsByTagName("input")[0];
      inputElm.style.padding = "0px";
      let iconBtn = editor.getElementsByClassName("icon-btn")[0];
      iconBtn.style.padding = "0px";
      iconBtn.style.width = rowHeight + "px";
      iconBtn.style.height = rowHeight + "px";
      let iconElm = iconBtn.getElementsByTagName("i-icon")[0];
      iconElm.style.width = rowHeight + "px";
      iconElm.style.height = rowHeight + "px";
      return editor;
    } else if (colOrRowType == "number") {
      let editor = this.createElement("input", this);
      editor.type = "number";
      editor.value = cell.value;
      editor.setAttribute("autocomplete", "disabled");
      editor.className = "grid_edit";
      this.appendChild(editor);
      return editor;
    } else if (colOrRowType == "integer") {
      let editor = this.createElement("input", this);
      editor.type = "text";
      editor.addEventListener("input", () => {
        const currentValue = editor.value;
        const sanitizedValue = currentValue.replace(/[^0-9]/g, "");
        editor.value = sanitizedValue;
      });
      editor.value = cell.value;
      editor.setAttribute("autocomplete", "disabled");
      editor.className = "grid_edit";
      this.appendChild(editor);
      return editor;
    } else {
      let editor = this.createElement("input", this);
      if (inputValue)
        editor.value = inputValue;
      editor.setAttribute("autocomplete", "disabled");
      editor.className = "grid_edit";
      return editor;
    }
  }
  handleEditControlChange(event) {
    console.dir("## handleEditControlChange");
  }
  _handleEditDblClick(event, stopPropagation) {
    return true;
  }
  colLeft() {
    let aRow = this._row;
    let aCol = this._col - 1;
    while (aCol > this._fixedCol) {
      let column = this.cols(aCol);
      if (column && column.visible === false)
        aCol--;
      else
        break;
    }
    ;
    if (aCol < this._colCount) {
      let cell = this.data.cells(aCol, aRow);
      if (cell && cell.mergeRect) {
        if (cell.mergeRect.startRow != aRow) {
          aRow = cell.mergeRect.endRow + 1;
        }
        ;
        this.setCurrCell(aCol, aRow, true);
      } else
        this.setCurrCell(aCol, aRow, true);
    }
    ;
  }
  colRight() {
    let aRow = this._row;
    let aCol = this._col + 1;
    while (aCol < this._colCount - 1) {
      let column = this.cols(aCol);
      if (column && column.visible === false)
        aCol++;
      else
        break;
    }
    ;
    if (aCol < this._colCount) {
      let cell = this.data.cells(aCol, aRow);
      if (cell && cell.mergeRect) {
        if (cell.mergeRect.startRow != aRow) {
          aRow = cell.mergeRect.endRow + 1;
        }
        this.setCurrCell(aCol, aRow, true);
      } else
        this.setCurrCell(aCol, aRow, true);
    }
    ;
  }
  autoAddRow() {
    if (!this._readOnly && !this.options._rowSelect && this.options._autoAddRow && this._row == this._rowCount - 1) {
      let emptyRow = this.checkEmptyRow(this._row);
      if (!emptyRow) {
        this._rowCount = this._rowCount + 1;
        this.setCurrCell(this._col, this._row + 1, true);
        let cell = this.data.getCell(0, this._row);
        if (this._dataBindingContext) {
          cell._newRow = true;
          let rd = this._dataBindingContext["append"]();
          this.setObject(0, this._row, rd);
          this._skipRefreshData = true;
          if (this._bindingRecordSet)
            this._bindingRecordSet["current"] = rd;
          this._dataBindingContext["current"] = rd;
        }
        this._updateTotalRowHeight();
        this.enableUpdateTimer();
      }
    }
  }
  rowDown(disableAutoAddRow) {
    let aCol = this._col;
    let aRow = this._row + 1;
    while (aRow < this._rowCount - 1 && this.gridRows.rows[aRow] && this.gridRows.rows[aRow]._visible == false) {
      aRow++;
    }
    if (this.gridRows.rows[aRow] && this.gridRows.rows[aRow]._visible == false)
      aRow = this._row;
    this.gridRows.rows[aRow] && this.gridRows.rows[aRow]._visible == false;
    if (!disableAutoAddRow)
      this.autoAddRow();
    if (aRow < this._rowCount) {
      let cell = this.data.cells(aCol, aRow);
      if (cell && cell.mergeRect) {
        if (cell.mergeRect.startRow != aRow) {
          aRow = cell.mergeRect.endRow + 1;
        }
        this.setCurrCell(aCol, aRow, true);
      } else
        this.setCurrCell(aCol, aRow, true);
    }
    ;
  }
  calcBottomRow(topRowIdx) {
    if (topRowIdx == this._rowCount - 1)
      return topRowIdx;
    let row = topRowIdx;
    let height = this._scrollBox.clientHeight;
    if (this.layout == "card") {
    } else {
      for (let i = 0; i < this._fixedRow; i++)
        height = height - this.getRowHeight(i) - 0.8;
      height = height - this.getRowHeight(row);
      while (row < this._rowCount - 1) {
        let h = this.getRowHeight(row - 1) + 0.8;
        height = height - h;
        if (height <= 0)
          return row;
        row++;
      }
      ;
    }
    ;
    return row;
  }
  calcLeftCol(colIdx) {
    if (colIdx == this._fixedCol)
      return colIdx;
    let col = colIdx;
    let width = this._scrollBox.clientWidth;
    for (let i = 0; i < this._fixedCol; i++)
      width = width - this.getColWidth(i) - 0.8;
    width = width - this.getColWidth(col) - 0.8;
    while (col > this._fixedCol - 1) {
      let w = this.getColWidth(col - 1) + 0.8;
      width = width - w;
      if (width <= 0) {
        return col;
      }
      col--;
    }
    return col;
  }
  rowUp() {
    let aCol = this._col;
    let aRow = this._row - 1;
    let cell = this.data.cells(aCol, aRow);
    if (cell && cell.mergeRect) {
      if (cell.mergeRect.endRow != aRow) {
        aRow = cell.mergeRect.startRow - 1;
      }
      ;
      this.setCurrCell(aCol, aRow, true);
    } else
      this.setCurrCell(aCol, aRow, true);
  }
  restoreOrigCellValue() {
    if (this.origValue != void 0) {
      if (this.editorMode)
        this.editor.value = this.origValue;
      else
        this._currCell.div.textContent = this.origValue;
    }
    ;
  }
  _handleKeyDown(event, stopPropagation) {
    if (!this.editorMode)
      this.edit.focus();
    if (!this.enabled)
      return false;
    else if (event.keyCode == 229) {
      setTimeout(() => {
      }, 10);
      return true;
    }
    ;
    let keyCode = event.keyCode;
    switch (keyCode) {
      case 9: {
        if (event.shiftKey)
          this.colLeft();
        else
          this.colRight();
        return true;
      }
      case 13: {
        if (this.editorMode) {
          if (!event.shiftKey) {
            this.hideEditor(true);
            this.colRight();
          }
        } else {
          this.setCurrCell(this._col + 1, this._row, true);
        }
        return true;
      }
      case 32: {
        let col = this.cols(this._col);
        let row = this.rows(this._row);
        let cell = this.cells(this._col, this._row);
        if (cell && cell.checkBox) {
          if (this._currCell) {
            this.toggleCellValue(col, cell);
            this._updateCell(this._currCell, cell, col, row);
          }
          ;
          event.stopPropagation();
        }
        break;
      }
      case 33: {
        let bottomRow = this.calcBottomRow(this._topRow);
        let row = this.calcTopRow(bottomRow);
        row = this.calcTopRow(row);
        this.setCurrCell(this._col, row);
        return true;
      }
      case 34: {
        let bottomRow = this.calcBottomRow(this._topRow);
        let row = this.calcBottomRow(bottomRow);
        this.setCurrCell(this._col, row);
        return true;
      }
      case 35: {
        if (!this.editorMode) {
          if (event.ctrlKey) {
            this.setCurrCell(this._colCount - 1, this._rowCount - 1);
          } else
            this.setCurrCell(this._colCount - 1, this._row);
        }
        return true;
      }
      case 36: {
        if (!this.editorMode) {
          if (event.ctrlKey)
            this.setCurrCell(this._fixedCol, this._fixedRow);
          else
            this.setCurrCell(this._fixedCol, this._row);
        }
        return true;
      }
      case 38: {
        this.rowUp();
        return true;
      }
      case 40: {
        if (this.editorMode) {
          this.hideEditor(true);
        }
        this.rowDown();
        return true;
      }
      default: {
        let col = this.cols(this._col);
        let cell = this.cells(this._col, this._row);
        if (cell && cell.checkBox)
          event.stopPropagation();
      }
    }
    ;
    if (this.editorMode) {
      switch (keyCode) {
        case 27:
          this.restoreOrigCellValue();
          this.hideEditor();
          this.focus();
          return true;
        case 37:
          return;
        case 39:
          return;
      }
      ;
    } else {
      switch (keyCode) {
        case 37:
          this.colLeft();
          return true;
        case 39:
          this.colRight();
          return true;
      }
    }
    ;
  }
  _handleBlur(event, stopPropagation) {
    return true;
  }
  showEditor(inputValue) {
    let column = this.columns.getColumn(this._col);
    let contextReadonly = false;
    if (this._dataBindingContext) {
      contextReadonly = this._dataBindingContext["readOnly"] || this._dataBindingContext["_context"]["options"]["_readOnly"];
    }
    if (!column._file && contextReadonly)
      return;
    if (!column._file && this.checkCellReadOnly())
      return;
    let cell = this.data.cells(this._col, this._row);
    this._currCell = this.getTableCellByActualIndex(this._col, this._row);
    if (this._currCell && !this.editorMode) {
      let top = this._currCell.offsetTop - 1;
      this.editorMode = true;
      this.origValue = this._currCell.div.innerHTML || "";
      if (this.editor) {
        this.editor.owner = null;
        this.editor["onChange"] = null;
        this.editor["onDblClick"] = null;
        this.editor["onKeyDown"] = null;
        this.editor["onHideDropDownPanel"] = null;
      }
      let editor;
      if (this.onGetEditControl) {
        editor = this.onGetEditControl(this, cell);
        if (editor)
          this.appendChild(editor);
      }
      if (!editor) {
        editor = this.getEditor(this._col, this._row, cell, inputValue);
      }
      if (editor) {
        editor.onchange = this.handleEditControlChange.bind(this);
        editor.ondblclick = this._handleEditDblClick.bind(this);
        editor.onkeydown = this._handleKeyDown.bind(this);
        editor.onblur = this._handleBlur.bind(this);
        this.editor = editor;
        editor.style.position = "absolute";
        editor.style.display = "block";
        editor.focus();
        if (cell.mergeRect) {
          let w = 0;
          let h = 0;
          for (let i = cell.mergeRect.startCol; i < cell.mergeRect.endCol; i++)
            w += this.getColWidth(i);
          editor.style.width = w - 1 + "px";
          for (let i = cell.mergeRect.startCol; i < cell.mergeRect.endCol; i++)
            h += this.getRowHeight(i) + 0.8;
          editor.style.height = h - 1 + "px";
          this.editor["setTop"](this._currCell.offsetTop + 1);
          this.editor["setLeft"](this._currCell.offsetLeft + 1);
        } else {
          editor.style.width = this.getColWidth(this._col) - 2 + "px";
          editor.style.height = this.getRowHeight(this._row) - 2 + "px";
          editor.style.top = this._currCell.offsetTop + 2 + "px";
          editor.style.left = this._currCell.offsetLeft + 2 + "px";
        }
      }
      if (this.onEditModeChanged) {
        this.onEditModeChanged(this);
      }
      ;
      this.editor = editor;
      let self = this;
      setTimeout(() => {
        if (editor) {
          editor.style.zIndex = "9999";
          editor.focus();
        }
        ;
      }, 10);
    } else
      this.edit.value = "";
  }
  _handleMouseDown(event) {
    if (!this.enabled)
      return true;
    let target = event.target;
    if (target && target.isSpliter)
      return true;
    let aCol = 0;
    let aRow = 0;
    if (target == this.editor) {
      return true;
    } else {
      let rect = this.getBoundingClientRect();
      let x = getCursorPosX(event) - rect.left;
      let y = getCursorPosY(event) - rect.top;
      if (x > this._scrollBox.clientWidth || y > this._scrollBox.clientHeight)
        return true;
      for (let row = 0; row < this._table.rows.length; row++) {
        let tableCell = this.tableCells[row][0];
        if (tableCell.offsetTop + tableCell.clientHeight >= y) {
          let r = this.tableCells[row];
          for (let col = 0; col < r.length; col++) {
            tableCell = r[col];
            if (tableCell && tableCell.offsetLeft + tableCell.clientWidth >= x && tableCell.offsetTop + tableCell.clientHeight >= y) {
              let tableCellDiv = tableCell == null ? void 0 : tableCell.div;
              aCol = this.getActualColIdx(col);
              aRow = this.getActualRowIdx(row);
              let cell = this.cells(aCol, aRow);
              this.lastClickCell = cell;
              let elms = tableCellDiv.querySelectorAll("button");
              if (elms.length > 0) {
                let offsetX = x - tableCell.offsetLeft;
                for (let i = 0; i < elms.length; i++) {
                  if (elms[i].offsetLeft + elms[i].clientWidth > offsetX) {
                    this.setCurrCell(aCol, aRow, true);
                    let btn;
                    if (Array.isArray(cell._value))
                      btn = cell._value[i];
                    else
                      btn = cell._value;
                    if (this.onButtonClick) {
                      this.onButtonClick(this, cell, btn);
                    }
                    if (this.onCellClick) {
                      this.onCellClick(this, cell);
                    }
                  }
                }
                return true;
              }
              let column = this.columns.getColumn(aCol);
              let gridRow = this.gridRows.getRow(aRow);
              if (column && (cell && cell._checkBox || column._checkBox || column._radioButton)) {
                if (aRow >= this._fixedRow || !cell.readOnly && cell._checkBox) {
                  this.toggleCellValue(column, cell);
                  this._updateCell(tableCell, cell, column, gridRow);
                  this.setCurrCell(aCol, aRow, true);
                } else if (this.options._sortOnClick && column._sortable) {
                  if (aCol == this.sortingCol)
                    this.sort(aCol, !this.sortingDescending);
                  else
                    this.sort(aCol);
                }
              } else if (aCol == this._col && aRow == this._row) {
                if (!this.editorMode) {
                  let cell2 = this.data.cells(aCol, aRow);
                  this.edit.value = cell2._displayValue || cell2._value || "";
                  this.showEditor(cell2._displayValue || cell2._value || "");
                }
              } else if (aRow < this._fixedRow) {
                application.globalEvents.abortEvent(event);
                if (this.editorMode)
                  this.hideEditor();
                if (this.options._sortOnClick) {
                  if (aCol == this.sortingCol)
                    this.sort(aCol, !this.sortingDescending);
                  else
                    this.sort(aCol);
                }
              } else {
                this.setCurrCell(aCol, aRow, true);
              }
              if (cell && this.onCellClick)
                this.onCellClick(this, cell);
              break;
            }
          }
          if (aRow != void 0)
            break;
        }
      }
    }
    if (aRow == void 0 && this.editorMode) {
      this.hideEditor(true);
    }
    if (!this.editorMode) {
      this.edit.focus();
    }
    ;
    return true;
  }
  _updateCell(tableCell, cell, column, row) {
    let tableCellDiv = tableCell == null ? void 0 : tableCell.div;
    let _cell = cell;
    let _column = column;
    let _row = row;
    let _tableCell = tableCell;
    let withDispValue = false;
    let disp;
    if (!tableCell.classList.contains("header")) {
      let colOrRowType = this.cols(cell.col).type;
      switch (colOrRowType) {
        case "string":
          if (cell.value == void 0)
            cell._value = "";
          break;
        case "checkBox":
          if (cell.value == void 0 || cell.value == "")
            cell._value = false;
          break;
        case "datePicker":
          if (cell.value == void 0 || cell.value == "")
            cell._value = import_moment3.default.unix(import_moment3.default.now() / 1e3);
          break;
        case "dateTimePicker":
          if (cell.value == void 0 || cell.value == "")
            cell._value = import_moment3.default.unix(import_moment3.default.now() / 1e3);
          break;
        case "timePicker":
          if (cell.value == void 0 || cell.value == "")
            cell._value = import_moment3.default.unix(import_moment3.default.now() / 1e3);
          break;
        case "comboBox":
          let colOrRowComboItems = this.cols(cell.col).comboItems;
          if (cell.value == void 0 || cell.value == "")
            cell._value = colOrRowComboItems ? colOrRowComboItems[0].value : void 0;
          break;
        case "number":
          if (cell.value == void 0 || cell.value == "")
            cell._value = 0;
          break;
        case "integer":
          if (cell.value == void 0 || cell.value == "")
            cell._value = 0;
          break;
      }
    }
    if (tableCellDiv) {
      tableCell.style.display = "";
      if (cell._encrypted)
        tableCellDiv.style.color = "green";
      else
        tableCellDiv.style.color = "";
      tableCellDiv.style.display = "";
      if (cell) {
        _cell._tableCell = tableCellDiv;
        let font = {
          "bold": this.font.bold,
          "color": this.font.color,
          "italic": this.font.italic,
          "name": this.font.name,
          "size": this.font.size,
          "underline": this.font.underline
        };
        let value;
        if (this.onDisplayCell) {
          disp = {
            "button": _cell._button,
            "checkBox": _cell._checkBox,
            "col": _cell._col,
            "color": _cell._color,
            "dataType": _cell._dataType,
            "font": font,
            "formula": _cell._formula,
            "horizontalAlign": _cell._horizontalAlign,
            "html": _cell._html,
            "image": _cell._image,
            "object": _cell._object,
            "readOnly": _cell._readOnly,
            "row": _cell._row,
            "text": _cell._text,
            "value": _cell._value,
            "visible": _cell._visible
          };
          try {
            this.onDisplayCell(this, disp);
            if (disp.value != _cell._value) {
              _cell._displayValue = disp["value"];
              withDispValue = true;
            }
            value = disp["value"];
          } catch (e) {
            value = "";
          }
        } else if (column && _column._formula) {
          if (this.formula) {
            this.formulaCell = cell;
            value = this.formula["parse"](column._formula)["result"];
          } else {
          }
        } else
          value = _cell._value;
        let c = (_cell ? _cell._color : "") || (_column ? _column._color : "");
        tableCell.classList.remove("bg-warning", "bg-success", "bg-info", "bg-danger", "bg-highlight");
        if (c) {
          if (["warning", "success", "info", "danger", "highlight"].indexOf(c) > -1)
            tableCell.classList.add("bg-" + c);
          else
            tableCell.style.backgroundColor = c;
        } else
          tableCellDiv.style.backgroundColor = "";
        let align;
        if (_cell._horizontalAlign != void 0)
          align = _cell._horizontalAlign;
        else if (_column && _column._horizontalAlign != void 0) {
          align = _column._horizontalAlign;
        }
        if (align != void 0) {
          switch (align) {
            case 0:
              tableCellDiv.style.textAlign = "center";
              break;
            case 1:
              tableCellDiv.style.textAlign = "left";
              break;
            case 2:
              tableCellDiv.style.textAlign = "right";
              break;
          }
        }
        if (!_cell.visible)
          tableCellDiv.style.display = "none";
        else
          tableCellDiv.style.display = "";
        let colOrRowType;
        let colOrRowDataType;
        if (_column && _row) {
          colOrRowType = _column._type;
          colOrRowDataType = _column._dataType;
        } else if (_column) {
          colOrRowType = _column._type;
          colOrRowDataType = _column._dataType;
        } else {
          colOrRowType = _row._type;
          colOrRowDataType = _row._dataType;
        }
        if (colOrRowDataType == "boolean") {
          let item = new Checkbox(void 0, {
            checked: cell.value
          });
          tableCellDiv.appendChild(item);
        } else if (colOrRowDataType == "date") {
          let item = new Label(void 0, {
            caption: cell.value.format("YYYY-MM-DD")
          });
          tableCellDiv.appendChild(item);
        } else if (colOrRowDataType == "dateTime") {
          let item = new Label(void 0, {
            caption: cell.value.format("YYYY-MM-DD HH:mm:ss")
          });
          tableCellDiv.appendChild(item);
        } else if (colOrRowDataType == "time") {
          let item = new Label(void 0, {
            caption: cell.value.format("HH:mm:ss")
          });
          tableCellDiv.appendChild(item);
        } else if (colOrRowDataType == "string") {
          let item = new Label(void 0, {
            caption: cell.value.toString()
          });
          tableCellDiv.appendChild(item);
        } else if (colOrRowDataType == "number") {
          let item = new Label(void 0, {
            caption: cell.value.toString()
          });
          tableCellDiv.appendChild(item);
        } else if (colOrRowDataType == "integer") {
          let item = new Label(void 0, {
            caption: cell.value.toString()
          });
          tableCellDiv.appendChild(item);
        } else {
          if (_column && _column._type == "image" && _cell._file && _cell._file["url"]) {
            tableCellDiv.classList.add("image");
            tableCellDiv.style.height = this._defaultRowHeight + "px";
            tableCellDiv.innerHTML = '<img src="' + withDispValue ? _cell._displayValue : _cell._file["url"] + '?size=t" style="max-height:100%;max-width=100%"/>';
          } else if (disp && disp.image) {
            tableCellDiv.classList.add("image");
            tableCellDiv.style.height = this._defaultRowHeight + "px";
            tableCellDiv.innerHTML = '<img src="' + withDispValue ? value : disp.value + '"/>';
          } else if (disp && disp.html) {
            tableCellDiv.innerHTML = withDispValue ? value : application.xssSanitize(disp.value);
          } else if (_cell && (_cell.image || _cell._dataType == 5) || _column && _column._dataType == 5) {
            tableCellDiv.classList.add("image");
            tableCellDiv.style.height = this._defaultRowHeight + "px";
            tableCellDiv.innerHTML = '<img src="' + withDispValue ? value : _cell._value + '"/>';
          } else if (_cell && (_cell.html || _cell._dataType == 6) || _column && _column._dataType == 6) {
            tableCellDiv.innerHTML = withDispValue ? value : application.xssSanitize(_cell._value);
          } else if (value && !Array.isArray(value) && !(value instanceof Date) && typeof value == "object") {
            if (Array.isArray(value)) {
              let html = "";
              for (let i = 0; i < value.length; i++)
                html += "<button>" + (value[i]["caption"] || "...") + "</button>";
              tableCellDiv.innerHTML = html;
            } else
              tableCellDiv.innerHTML = "<button>" + (value["caption"] || "...") + "</button>";
          } else if (_column && _column._button) {
            tableCellDiv.innerHTML = "<button>" + (value || "...") + "</button>";
          } else if (_cell && _cell._checkBox || _column && _column._checkBox) {
            if (value)
              tableCellDiv.className = "check_box_checked";
            else
              tableCellDiv.className = "check_box_unchecked";
            tableCellDiv.style.position = "relative";
            tableCellDiv.style.margin = "auto";
            tableCellDiv.style.top = (this._defaultRowHeight - 13) / 2 + "px";
            tableCellDiv.style.left = "1px";
            tableCellDiv.style["height"] = "100%";
            tableCellDiv.style["width"] = "13px";
          } else if (_column && _column._radioButton) {
            if (value)
              tableCellDiv.className = "radio_button.checked";
            else
              tableCellDiv.className = "radio_button.unchecked";
            tableCellDiv.style.position = "relative";
            tableCellDiv.style.margin = "auto";
            tableCellDiv.style.top = (this._defaultRowHeight - 13) / 2 + "px";
            tableCellDiv.style.left = "1px";
            tableCellDiv.style["height"] = "100%";
            tableCellDiv.style["width"] = "13px";
          } else {
            if (_cell._dispValue && tableCell.classList.contains("grid_fixed_cell")) {
              tableCellDiv.textContent = _cell._dispValue;
            } else if (withDispValue) {
              tableCellDiv.textContent = value;
            } else if (_cell.row < this._fixedRow) {
              tableCellDiv.textContent = value;
            } else {
              if (column && _column._type == "lookupDetail") {
                let rd;
                if (_cell._record)
                  rd = _cell._record;
                else {
                  let record = this.getObject(0, _cell._row);
                  if (record) {
                    let rs = record[_column._lookupTable];
                    if (rs) {
                      rd = rs.first;
                      _cell._field = _column._lookupField;
                      let v1 = _column._lookupDetailValue;
                      switch (_column._lookupDetailType) {
                        case "date":
                          v1 = new Date(v1);
                          v1.setHours(0, 0, 0, 0);
                          break;
                        case "numeric":
                          if (typeof v1 == "string")
                            v1 = parseFloat(v1);
                          break;
                      }
                      while (rd) {
                        let v2 = rd[_column._lookupField];
                        switch (_column._lookupDetailType) {
                          case "date":
                            v2 = new Date(rd[_column._lookupDetailField]);
                            v2.setHours(0, 0, 0, 0);
                            break;
                          case "numeric":
                            if (typeof v2 == "string")
                              v2 = parseFloat(v2);
                            break;
                        }
                        if (v1 == v2)
                          break;
                        else if (_column._lookupDetailType == "date" && v1.getTime() == v2.getTime())
                          break;
                        rd = rs["next"];
                      }
                    }
                  }
                }
                if (rd) {
                  _cell._value = rd[_column._lookupField];
                  _cell._record = rd;
                  tableCellDiv.textContent = rd[_column._lookupField];
                }
              } else if (column && _column._type == "listOfValue" && _column._listOfValue) {
                let lsv = this._listOfValue[_column._listOfValue];
                if (lsv != void 0)
                  tableCellDiv.textContent = lsv[value] || value;
                else
                  tableCellDiv.textContent = value;
              } else if (column && (_column._type == "lookup" || _column._type == "lookupCombo")) {
              } else if (_column && _column._type == "{userAccount}") {
              } else {
                let type = typeof value;
                if (type != "undefined") {
                  if (type == "number")
                    tableCellDiv.textContent = parseNumber(value.toPrecision(12)).toString();
                  else {
                    tableCellDiv.textContent = value;
                  }
                } else
                  tableCellDiv.textContent = "";
              }
            }
          }
        }
      } else {
        if (cell && _cell._checkBox || column && _column._checkBox) {
          tableCellDiv.className = "check_box_unchecked";
          tableCellDiv.style.position = "relative";
          tableCellDiv.style.top = "1px";
          tableCellDiv.style.left = "1px";
          tableCellDiv.style["height"] = "13px";
          tableCellDiv.style["width"] = "13px";
        } else if (column && _column._radioButton) {
          tableCellDiv.className = "radio_button.unchecked";
          tableCellDiv.style.position = "relative";
          tableCellDiv.style.top = "1px";
          tableCellDiv.style.left = "1px";
          tableCellDiv.style["height"] = "13px";
          tableCellDiv.style["width"] = "13px";
        } else
          tableCellDiv.textContent = "";
      }
    }
  }
  checkCellReadOnly(col, row) {
    if (!this._enabled || this._readOnly || this.options._rowSelect)
      return true;
    else {
      if (col == void 0)
        col = this._col;
      if (row == void 0)
        row = this._row;
      if ((col < this._fixedCol || row < this._fixedRow) && this.layout != "card")
        return true;
      let column = this.cols(col);
      if (column._readOnly)
        return true;
      else {
        let record = this.getObject(0, row);
        if (record && record["_isReadOnly"])
          return true;
        let cell = this.data.cells(col, row);
        if (cell)
          return cell.readOnly || !cell.visible;
        else
          return false;
      }
      ;
    }
    ;
  }
  toggleCellValue(column, cell) {
    if (!this.checkCellReadOnly(cell.col, cell.row)) {
      cell._value = !cell._value;
      if (this._dataBindingContext) {
        let record = this.getObject(0, cell._row);
        let field = this.getObject(cell._col, 0);
        if (!record && field) {
          record = this._dataBindingContext["append"]();
          this.setObject(0, cell._row, record);
        }
        if (record && field) {
          record[field] = cell._value;
        }
        this.enableUpdateTimer();
      }
      this.updateBindingData(cell, column);
      if (this.onCellChange)
        this.onCellChange(this, cell, !cell._value, cell._value);
    }
  }
  _handleMouseMove(event) {
    if (application.globalEvents._leftMouseButtonDown) {
    }
    if (this._colResizing) {
      let pos = getCursorPosX(event);
      this.setColWidth(this.resizeCol, this.origColWidth + (pos - this.mouseDownPosX), true);
      this.showData(100);
      this.highlightCurrCell();
      return true;
    }
    return true;
  }
  _handleMouseUp(event) {
    if (this._colResizing) {
      this._colResizing = false;
      this._updateTableSplitter();
    }
    return true;
  }
  _handleColumnResizeStart(event) {
    if (this.editorMode) {
      this.hideEditor(true);
    }
    ;
    let pos = getCursorPosX(event);
    this.mouseDownPosX = pos;
    this.resizeCol = this.getActualColIdx(event.target.cellIndex);
    this.origColWidth = this.getColWidth(this.resizeCol);
    this._colResizing = true;
  }
  _updateTableSplitter() {
    let splitter;
    for (let i = this.tableSplitters.length - 1; i < this.visibleColCount; i++) {
      splitter = this.tableSplitters[i];
      if (splitter)
        splitter.style.display = "none";
    }
    ;
    for (let col = 0; col < this.visibleColCount; col++) {
      splitter = this.tableSplitters[col];
      if (!splitter) {
        splitter = this.createElement("div", this);
        this.tableSplitters[col] = splitter;
        splitter.isSpliter = true;
        splitter.owner = this;
        splitter.cellIndex = col;
        splitter.onmousedown = this._handleColumnResizeStart.bind(this);
        this.appendChild(splitter);
        splitter.style.zIndex = 5;
        splitter.style.cursor = "e-resize";
        splitter.style.position = "absolute";
        splitter.style.top = "0px";
        splitter.style.width = "6px";
      }
      ;
      let colIdx = this.getActualColIdx(col);
      let left = this.getColRight(colIdx);
      let height = 0;
      for (let row = 0; row < this._fixedRow; row++) {
        height = height + this.getRowHeight(row) + 0.8;
      }
      splitter.style.left = left + "px";
      if (this._fixedCol > 0 && col == this._fixedCol - 1)
        splitter.style.height = "100%";
      else
        splitter.style.height = height + "px";
      splitter.style.display = "";
    }
  }
  _showDataInternalGrid() {
    if (!this._table)
      return;
    for (let r = 0; r < this._fixedRow; r++) {
      for (let c = 0; c < this._fixedCol; c++) {
        let tableCell = this.getTableCell(c, r);
        let column = null;
        let row2 = null;
        if (this.columns)
          column = this.columns.getColumn(c);
        if (this.gridRows)
          row2 = this.gridRows.getRow(r);
        if (tableCell) {
          let cell = this.data.cells(c, r);
          this._updateCell(tableCell, cell, column, row2);
        }
      }
    }
    for (let r = 0; r < this._fixedRow; r++) {
      for (let c = this._fixedCol; c < this.visibleColCount; c++) {
        let row2 = this.gridRows.getRow(r);
        let tableCell = this.getTableCell(c, r);
        if (tableCell) {
          let cell = this.data.cells(this.getActualColIdx(c), r);
          if (cell)
            tableCell.cell = cell;
          this._updateCell(tableCell, cell, void 0, row2);
        }
      }
    }
    for (let r = this._fixedRow; r < this.visibleRowCount; r++) {
      for (let c = 0; c < this._fixedCol; c++) {
        let column = this.columns.getColumn(c);
        let tableCell = this.getTableCell(c, r);
        if (tableCell) {
          let cell = this.data.cells(c, this.getActualRowIdx(r));
          if (cell)
            tableCell.cell = cell;
          this._updateCell(tableCell, cell, column);
        }
      }
    }
    for (let c = this._fixedCol; c < this.visibleColCount; c++) {
      let colIdx = this.getActualColIdx(c);
      let _column = this.columns.getColumn(colIdx);
      if (_column && (_column._type == "lookup" || _column._type == "lookupCombo")) {
      }
    }
    for (let r = this._fixedRow; r < this.visibleRowCount; r++) {
      let rowIdx = this.getActualRowIdx(r);
      for (let c = this._fixedCol; c < this.visibleColCount; c++) {
        let colIdx = this.getActualColIdx(c);
        let column = this.columns.getColumn(colIdx);
        let row2 = this.gridRows.getRow(rowIdx);
        let tableCell = this.getTableCell(c, r);
        if (tableCell) {
          let cell = this.data.cells(colIdx, rowIdx);
          tableCell.cell = cell;
          this._updateCell(tableCell, cell, column, row2);
        }
        ;
      }
      ;
    }
    ;
    if (this.options._autoRowHeight) {
      for (let r = 0; r < this.visibleRowCount; r++) {
        if (this._table.rows[r].clientHeight > this._defaultRowHeight) {
          for (let c = 0; c < this.visibleColCount; c++) {
            let tableCell = this.getTableCell(c, r);
            if (tableCell && tableCell.cell) {
              let cell = tableCell.cell;
              let row2 = this.getActualRowIdx(r);
              if (!cell._height) {
                cell._height = tableCell.div.clientHeight + 3;
              }
              if (!this._rowHeights[row2] || this._rowHeights[row2] < cell._height) {
                this._rowHeights[row2] = cell._height;
              }
            }
          }
        }
      }
    }
    ;
    let row = this._table.rows[0];
    if (row) {
      if (row.cells.length > this._colCount - this._leftCol + this._fixedCol) {
        for (let r = 0; r < this._table.rows.length; r++) {
          let row2 = this._table.rows[r];
          for (let c = this._colCount - this._leftCol + this._fixedCol; c < row2.cells.length; c++) {
            row2.cells[c].style.display = "none";
          }
          ;
        }
        ;
      }
      ;
    }
    ;
    if (this._table.rows.length > this._rowCount - this._topRow + this._fixedRow) {
      for (let c = this._rowCount - this._topRow + this._fixedRow; c < this._table.rows.length; c++) {
        if (c > -1) {
          this._table.rows[c].style.display = "none";
        }
        ;
      }
      ;
    }
    ;
    this.highlightCurrCell();
  }
  showDataInternal() {
    this.showDataFlag = false;
    if (!this.showDataInternalFlag) {
      this.showDataInternalFlag = true;
      try {
        if (this.layout == "card") {
        } else
          this._showDataInternalGrid();
      } finally {
        this.showDataInternalFlag = false;
      }
      ;
    }
    ;
  }
  _updateTableInternal(updateRowHeightFlag, updateColWidthFlag) {
    if (!this._updateTableInternalFlag) {
      this._updateTableInternalFlag = true;
      try {
        if (this.layout == "card") {
        } else {
          if (updateRowHeightFlag) {
            this._updateTotalRowHeight();
          }
          ;
          if (updateColWidthFlag) {
            this._updateTotalColWidth();
          }
          ;
          this.tableCells = [[]];
          if (this._totalColWidth < parseFloat(this.width.toString()))
            this.placeHolder.style.width = "100%";
          else
            this.placeHolder.style.width = this._totalColWidth + "px";
          this.placeHolder.style.height = this._totalRowHeight + "px";
          this._updateTableRows();
          this._updateTableCols();
          this._updateTableMergedCells();
          this._updateTableSplitter();
        }
      } catch (err) {
      } finally {
        this._updateTableInternalFlag = false;
      }
      ;
    }
    ;
  }
  enableUpdateTimer(updateRowHeightFlag, updateColWidthFlag) {
    updateRowHeightFlag = updateRowHeightFlag || false;
    updateColWidthFlag = updateColWidthFlag || false;
    clearTimeout(this._updateTableTimer);
    this._updateTableTimer = setTimeout(() => {
      if (this._scrollBox.clientWidth) {
        this._updateTableTimer = void 0;
        this._sorting = false;
        if (updateRowHeightFlag)
          this._rowHeights = [];
        this._updateTableInternal(updateRowHeightFlag, updateColWidthFlag);
        this.showDataInternal();
      } else {
        this._updateTableTimer = setTimeout(() => {
          this._sorting = false;
          if (updateRowHeightFlag)
            this._rowHeights = [];
          this._updateTableInternal(updateRowHeightFlag, updateColWidthFlag);
          this.showDataInternal();
        }, 100);
      }
    }, 10);
  }
};
DataGrid = __decorateClass([
  customElements2("i-data-grid")
], DataGrid);

// packages/markdown/src/styles/index.css.ts
var Theme27 = theme_exports.ThemeVars;
cssRule("i-markdown", {
  fontFamily: Theme27.typography.fontFamily,
  fontSize: Theme27.typography.fontSize,
  color: `var(--custom-text-color, ${Theme27.text.primary})`
});

// packages/markdown/src/plaintify.ts
function escape2(html) {
  const escapeMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  return html.replace(/[&<>"']/g, (match) => escapeMap[match]);
}
var block = (text) => text + "\n\n";
var escapeBlock = (text) => escape2(text) + "\n\n";
var line = (text) => text + "\n";
var inline = (text) => text;
var newline = () => "\n";
var empty = () => "";
var TxtRenderer = {
  code: escapeBlock,
  blockquote: block,
  html: empty,
  heading: block,
  hr: newline,
  list: (text) => block(text.trim()),
  listitem: line,
  checkbox: empty,
  paragraph: block,
  table: (header, body) => line(header + body),
  tablerow: (text) => line(text.trim()),
  tablecell: (text) => text + " ",
  strong: inline,
  em: inline,
  codespan: inline,
  br: newline,
  del: inline,
  link: (_0, _1, text) => text,
  image: (_0, _1, text) => text,
  text: inline,
  options: {}
};

// packages/markdown/src/markdown.ts
var libs = [`${LibPath}lib/marked/marked.umd.js`];
async function markdownToPlainText(text) {
  return new Promise((resolve, reject) => {
    RequireJS.require(libs, async (marked) => {
      marked.use({
        gfm: true,
        renderer: TxtRenderer
      });
      const plainText = await marked.parse(text);
      resolve(plainText);
    });
  });
}
var Markdown = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this.gitbookProcess = true;
    this._theme = "light";
  }
  get theme() {
    return this._theme;
  }
  set theme(value) {
    this._theme = value;
    if (this._theme === "light")
      this.classList.remove("toastui-editor-dark");
    else
      this.classList.add("toastui-editor-dark");
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    this._space = value;
    if (!this.elm)
      return;
    if (!this._padding)
      this._padding = new SpaceValue(this.elm, value, "padding");
    else
      this._padding.update(value);
  }
  getRenderer() {
    const renderer = {
      link(href, title, text) {
        return `<a target="_blank" href="${href}" ${title ? 'title="' + title + '"' : ""}>${text}</a>`;
      }
    };
    return renderer;
  }
  async getTokens(text) {
    if (!this.marked)
      this.marked = await this.loadLib();
    let tokens;
    try {
      tokens = this.marked.lexer(text, {
        breaks: true
      });
    } catch (e) {
    }
    return tokens;
  }
  async toPlainText(text) {
    if (!this.marked)
      this.marked = await this.loadLib();
    this.marked.use({
      gfm: true,
      renderer: TxtRenderer
    });
    const plainText = await this.marked.parse(text);
    return plainText;
  }
  async load(text) {
    if (!this.marked)
      this.marked = await this.loadLib();
    let renderer = this.getRenderer();
    this.marked.use({
      renderer
    });
    if (text) {
      const rows = text.split(/\n{2}|(?:\r\n){2}/);
      for (let i = 0; i < rows.length; i++) {
        rows[i] = rows[i] ? await this.preParse(rows[i]) : "";
      }
      text = rows.join("\n\n");
      text = await this.marked.parse(text, {
        breaks: true
      });
      text = await this.processText(text);
    } else {
      text = "";
    }
    ;
    if (!this.elm)
      this.elm = this.createElement("div", this);
    this.elm.innerHTML = text;
    if (!this._padding && this._space)
      this.padding = this._space;
    return this.elm.innerHTML;
  }
  async preParse(text) {
    const firstIndex = text.indexOf("|");
    const lastIndex2 = text.lastIndexOf("|");
    const tableMd = text.slice(firstIndex, lastIndex2 + 1);
    const tableMdRegex = /(?<=(\r\n){2}|^)([^\r\n]*\|[^\r\n]*(\r?\n)?)+(?=(\r?\n){2}|$)/gm;
    if (!tableMdRegex.test(tableMd))
      return text;
    const breakRegex = /\|(\s)*:?(-+):?(\s)*\|/gm;
    if (!breakRegex.test(tableMd))
      return text;
    const splittedArr = tableMd.split("|") || [];
    for (let i = 0; i < splittedArr.length; i++) {
      let child2 = splittedArr[i].trim() || "";
      if (child2) {
        if (/^(\s)*:?-*:?(\s)*$/g.test(child2))
          continue;
        child2 = await this.marked.parse(child2, {
          breaks: true
        });
        if (child2 !== "\n") {
          splittedArr[i] = child2.replace(/\n/g, "");
        }
      }
    }
    text = text.slice(0, firstIndex) + splittedArr.join("|");
    return text;
  }
  async beforeRender(text) {
    this.elm.innerHTML = text;
  }
  async processText(text) {
    if (this.gitbookProcess) {
      text = text.replace(/\*\*\*\*/g, "\n	").replace(/\\/g, "");
    }
    return text;
  }
  async loadLib() {
    return new Promise((resolve, reject) => {
      RequireJS.require(libs, async (marked) => {
        resolve(marked);
      });
    });
  }
  init() {
    super.init();
    this.elm = this.createElement("div", this);
    this.elm.classList.add("toastui-editor-contents");
    let padding = this.getAttribute("padding", true);
    if (padding) {
      this._padding = new SpaceValue(this.elm, padding, "padding");
    }
  }
};
Markdown = __decorateClass([
  customElements2("i-markdown", {
    icon: "spell-check",
    className: "Markdown",
    props: {
      theme: { type: "string" }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        theme: {
          type: "string",
          enum: ["light", "dark"],
          default: "light"
        }
      }
    }
  })
], Markdown);

// packages/markdown-editor/src/styles/index.css.ts
var Theme28 = theme_exports.ThemeVars;
cssRule("i-markdown-editor", {
  $nest: {
    ".ProseMirror .placeholder": {
      userSelect: "none",
      pointerEvents: "none"
    },
    ".overlay": {
      width: "100%",
      height: "100%",
      position: "absolute",
      top: 0,
      left: 0,
      zIndex: 999,
      display: "none",
      backgroundColor: "transparent",
      cursor: "pointer"
    }
  }
});

// packages/markdown-editor/src/markdown-editor.ts
var TOOLBAR_ITEMS_DEFAULT = [
  ["heading", "bold", "italic", "strike"],
  ["hr", "quote"],
  ["ul", "ol", "task", "indent", "outdent"],
  ["table", "image", "link"],
  ["code", "codeblock"]
];
RequireJS.config({
  paths: {
    "tui-color-picker": `${LibPath}lib/tui-editor/tui-color-picker.min.js`
  }
});
var libPlugins = [
  `${LibPath}lib/tui-editor/toastui-editor-all.min.js`,
  `${LibPath}lib/tui-editor/toastui-editor-plugin-color-syntax.min.js`,
  `${LibPath}lib/tui-editor/toastui-editor-plugin-table-merged-cell.min.js`,
  `${LibPath}lib/tui-editor/toastui-editor-plugin-uml.min.js`
];
var libSyntaxHighlightPlugin = [`${LibPath}lib/tui-editor/toastui-editor-plugin-code-syntax-highlight-all.min.js`];
var unSupportedLang = ["zh-TW", "zh-CN", "jp"];
var editorCSS = [
  { name: "toastui-editor", href: `${LibPath}lib/tui-editor/toastui-editor.css` },
  { name: "toastui-plugins", href: `${LibPath}lib/tui-editor/toastui-plugins.min.css` }
];
var MarkdownEditor = class extends Text {
  constructor(parent, options) {
    super(parent, options);
    this.editorPlugins = [];
    this._theme = "light";
    this._mode = "markdown";
    this._previewStyle = "vertical";
    this._value = "";
    this._viewer = false;
    this._heightValue = "500px";
    this._toolbarItems = TOOLBAR_ITEMS_DEFAULT;
    this._customPlugins = [];
    this._widgetRules = [];
    this._hideModeSwitch = false;
    this._placeholder = "";
    this._autoFocus = false;
  }
  setFocus() {
    var _a;
    if (this.editorObj) {
      (_a = this.editorObj.getCurrentModeEditor().el.querySelector(".toastui-editor-contents")) == null ? void 0 : _a.click();
      this.editorObj.getCurrentModeEditor().moveCursorToStart(true);
    }
  }
  get mode() {
    return this._mode;
  }
  set mode(value) {
    this._mode = value;
    if (this.viewer)
      return;
    if (this.editorObj) {
      this.editorObj.changeMode(value, false);
    }
  }
  get theme() {
    return this._theme;
  }
  set theme(value) {
    this._theme = value;
    if (!this.editor) {
      if (this.mdViewer) {
        this.mdViewer.theme = value;
      }
      return;
    }
    this.renderEditor(true);
  }
  get previewStyle() {
    return this._previewStyle;
  }
  set previewStyle(value) {
    this._previewStyle = value;
    if (this.viewer)
      return;
    if (this.editorObj) {
      this.editorObj.changePreviewStyle(value);
    }
  }
  get viewer() {
    return this._viewer;
  }
  set viewer(value) {
    if (this._viewer === value)
      return;
    this._viewer = value;
    if (!this.editor)
      return;
    this.renderEditor(true);
  }
  set designMode(value) {
    this._designMode = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    if (this.viewer) {
      this.mdViewer.load(value);
    } else if (!this.viewer && this.editorObj) {
      this.editorObj.setMarkdown(value);
    }
  }
  async setValue(value) {
    this._value = value;
    if (this.viewer) {
      await this.mdViewer.load(value);
    } else if (!this.viewer && this.editorObj) {
      this.editorObj.setMarkdown(value);
    }
  }
  get height() {
    return this._heightValue;
  }
  set height(value) {
    this._heightValue = getSpacingValue(value);
    if (this.viewer)
      return;
    if (this.editorObj) {
      this.editorObj.setHeight(this._heightValue);
    }
  }
  get toolbarItems() {
    return this._toolbarItems || TOOLBAR_ITEMS_DEFAULT;
  }
  set toolbarItems(items) {
    var _a;
    this._toolbarItems = items;
    const toolbar = this.querySelector(".toastui-editor-toolbar");
    if (toolbar && !((_a = this.toolbarItems) == null ? void 0 : _a.length))
      toolbar.style.display = "none";
    if (!this.editor)
      return;
    this.renderEditor(true);
  }
  get plugins() {
    return this._customPlugins || [];
  }
  set plugins(plugins) {
    this._customPlugins = plugins;
    if (!this.editor)
      return;
    this.renderEditor(true);
  }
  get widgetRules() {
    return this._widgetRules || [];
  }
  set widgetRules(rules) {
    this._widgetRules = rules;
    if (!this.editor)
      return;
    this.renderEditor(true);
  }
  get hideModeSwitch() {
    var _a;
    return (_a = this._hideModeSwitch) != null ? _a : false;
  }
  set hideModeSwitch(value) {
    this._hideModeSwitch = value != null ? value : false;
  }
  get autoFocus() {
    return this._autoFocus;
  }
  set autoFocus(value) {
    this._autoFocus = value != null ? value : false;
  }
  get placeholder() {
    var _a;
    return (_a = this._placeholder) != null ? _a : "";
  }
  set placeholder(value) {
    this._placeholder = value != null ? value : "";
    if (this.editorObj)
      this.renderEditor(true);
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (!this.elm)
      return;
    if (!this._padding)
      this._padding = new SpaceValue(this.elm, value, "padding");
    else
      this._padding.update(value);
    const { top = 0, right = 0, bottom = 0, left = 0 } = value;
    const padding = `${this._padding.getSpacingValue(top)} ${this._padding.getSpacingValue(right)} ${this._padding.getSpacingValue(bottom)} ${this._padding.getSpacingValue(left)}`;
    const ProseMirrors = this.querySelectorAll(".ProseMirror");
    for (let elm of ProseMirrors) {
      elm.style.padding = padding;
    }
    this.elm.style.padding = "";
  }
  get border() {
    return this._border;
  }
  set border(value) {
    if (!this.elm)
      return;
    this._border = new Border(this.elm, value);
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  async loadPlugin(plugin) {
    return new Promise((resolve, reject) => {
      RequireJS.require(plugin, async (editor, colorSyntax, tableMergedCell, uml) => {
        this.editor = editor;
        resolve([colorSyntax, tableMergedCell, uml]);
      });
    });
  }
  async loadSyntaxHighlightPlugin(plugin) {
    return new Promise((resolve, reject) => {
      RequireJS.require(plugin, async (codeSyntaxHighlight) => {
        resolve([codeSyntaxHighlight]);
      });
    });
  }
  async loadPlugins() {
    const plugins = await this.loadPlugin(libPlugins);
    let codeSyntaxHighlight = [];
    if (!unSupportedLang.some((v) => {
      var _a;
      return v.toLowerCase() === ((_a = navigator.language) == null ? void 0 : _a.toLowerCase());
    })) {
      codeSyntaxHighlight = await this.loadSyntaxHighlightPlugin(libSyntaxHighlightPlugin);
    }
    this.editorPlugins = plugins.concat(codeSyntaxHighlight);
  }
  addCSS(href, name) {
    const css = document.head.querySelector(`[name="${name}"]`);
    if (css)
      return;
    let link = document.createElement("link");
    link.setAttribute("type", "text/css");
    link.setAttribute("rel", "stylesheet");
    link.setAttribute("name", name);
    link.href = href;
    document.head.append(link);
  }
  async initEditor() {
    if (!this.viewer) {
      for (const item of editorCSS) {
        this.addCSS(item.href, item.name);
      }
      await this.loadPlugins();
    }
    try {
      this.renderEditor();
    } catch (e) {
    }
  }
  renderEditor(valueChanged) {
    var _a, _b, _c;
    const editorPlugins = [...this.editorPlugins].filter(Boolean);
    let padding = this.getAttribute("padding", true);
    let font = this.getAttribute("font", true);
    let border = this.getAttribute("border", true);
    if (this.viewer) {
      if (this.editorObj) {
        this.editorObj.destroy();
      }
      if (!this.elm) {
        this.elm = this.createElement("div", this);
      } else {
        this.elm.innerHTML = "";
        this.elm.style.height = "auto";
      }
      this.mdViewer = new Markdown();
      if (padding)
        this.mdViewer.padding = padding;
      if (font)
        this.mdViewer.font = font;
      this.mdViewer.theme = this.theme;
      this.elm.appendChild(this.mdViewer);
    } else {
      if (!this.elm) {
        this.elm = this.createElement("div", this);
      } else {
        this.elm.innerHTML = "";
      }
      this.overlayElm.style.display = this._designMode ? "block" : "none";
      const currentValue = valueChanged && this.editorObj ? this.editorObj.getMarkdown() : this.value;
      this.editorObj = new this.editor({
        el: this.elm,
        previewStyle: this.previewStyle,
        height: this.height,
        initialEditType: this.mode,
        initialValue: currentValue,
        theme: this.theme,
        toolbarItems: this.toolbarItems,
        plugins: [...editorPlugins, ...this.plugins],
        widgetRules: this.widgetRules,
        hideModeSwitch: this.hideModeSwitch,
        minHeight: (_a = this.minHeight) != null ? _a : "300px",
        placeholder: this.placeholder,
        autofocus: this._designMode ? false : this.autoFocus,
        events: {
          change: (event) => {
            if (this._designMode)
              return;
            if (this.onChanged)
              this.onChanged(this, event);
          },
          focus: (event, data) => {
            if (this._designMode)
              return;
            if (this.onFocus)
              this.onFocus(this, event);
          },
          blur: (event) => {
            if (this.onBlur)
              this.onBlur(this, event);
          },
          keydown: (target, event) => {
            if (this._designMode) {
              event.preventDefault();
              event.stopPropagation();
            }
          },
          keyup: (target, event) => {
            if (this._designMode) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      });
      if (this.autoFocus) {
        (_b = this.editorObj.getCurrentModeEditor().el.querySelector(".toastui-editor-contents")) == null ? void 0 : _b.click();
        this.editorObj.getCurrentModeEditor().moveCursorToStart(true);
      }
      if (this.theme === "light")
        this.elm.classList.remove("toastui-editor-dark");
      const toolbar = this.querySelector(".toastui-editor-toolbar");
      if (toolbar && !((_c = this.toolbarItems) == null ? void 0 : _c.length))
        toolbar.style.display = "none";
      if (!this._padding && padding)
        this.padding = padding;
    }
    this.elm.style.background = "inherit";
    this.elm.style.fontSize = "inherit";
    if (border) {
      this._border = new Border(this.elm, border);
      this.style.border = "none";
      this.style.borderRadius = "unset";
    }
  }
  getMarkdownValue() {
    if (this.editorObj && !this.viewer) {
      return this.editorObj.getMarkdown();
    }
    return "";
  }
  getEditorElm() {
    if (this.editorObj && !this.viewer) {
      return this.editorObj;
    }
    return null;
  }
  getViewerElm() {
    if (this.mdViewer)
      return this.mdViewer;
    return null;
  }
  async init() {
    super.init();
    this.onChanged = this.getAttribute("onChanged", true) || this.onChanged;
    this.onFocus = this.getAttribute("onFocus", true) || this.onFocus;
    this.onBlur = this.getAttribute("onBlur", true) || this.onBlur;
    this.overlayElm = this.createElement("div", this);
    this.overlayElm.classList.add("overlay");
    const mode = this.getAttribute("mode", true, "");
    if (mode) {
      this._mode = mode;
    }
    const previewStyle = this.getAttribute("previewStyle", true, "");
    if (previewStyle) {
      this._previewStyle = previewStyle;
    }
    const value = this.getAttribute("value", true, "");
    if (value) {
      this._value = value;
    }
    const viewer = this.getAttribute("viewer", true, null);
    if (viewer !== null) {
      this.viewer = viewer;
    }
    const height = this.getAttribute("height", true, "");
    if (height) {
      this._heightValue = height;
    }
    const width = this.getAttribute("width", true, "");
    if (width) {
      this.width = width;
    }
    const theme2 = this.getAttribute("theme", true, "");
    if (theme2) {
      this._theme = theme2;
    }
    const toolbarItems = this.getAttribute("toolbarItems", true, "");
    if (toolbarItems) {
      this._toolbarItems = toolbarItems;
    }
    const plugins = this.getAttribute("plugins", true, "");
    if (plugins) {
      this._customPlugins = plugins;
    }
    const widgetRules = this.getAttribute("widgetRules", true, "");
    if (widgetRules) {
      this._widgetRules = widgetRules;
    }
    this._placeholder = this.getAttribute("placeholder", true, "");
    this._hideModeSwitch = this.getAttribute("hideModeSwitch", true, false);
    this.autoFocus = this.getAttribute("autoFocus", true, false);
    this.initEditor();
  }
};
MarkdownEditor = __decorateClass([
  customElements2("i-markdown-editor", {
    icon: "pen-square",
    group: GroupType.FIELDS,
    className: "MarkdownEditor",
    props: {
      mode: { type: "string", default: "" },
      theme: { type: "string" },
      previewStyle: { type: "string" },
      hideModeSwitch: { type: "boolean", default: false },
      value: { type: "string" },
      viewer: { type: "boolean", default: false },
      toolbarItems: { type: "array" },
      plugins: { type: "array" },
      widgetRules: { type: "array" },
      placeholder: { type: "string", default: "" }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        value: {
          type: "string"
        },
        mode: {
          type: "string",
          enum: ["wysiwyg", "markdown"]
        },
        previewStyle: {
          type: "string",
          enum: ["tab", "vertical"]
        },
        hideModeSwitch: {
          type: "boolean",
          format: "boolean"
        },
        viewer: {
          type: "boolean",
          format: "boolean"
        },
        placeholder: {
          type: "string"
        }
      }
    }
  })
], MarkdownEditor);

// packages/menu/src/style/menu.css.ts
var Theme29 = theme_exports.ThemeVars;
cssRule("i-context-menu", {
  display: "none"
});
cssRule("i-menu", {
  display: "block"
});
var fadeInRight = keyframes({
  "0%": {
    opacity: 0,
    transform: "translate3d(100%, 0, 0)"
  },
  "100%": {
    opacity: 1,
    transform: "translate3d(0, 0, 0)"
  }
});
var menuStyle = style({
  fontFamily: Theme29.typography.fontFamily,
  fontSize: Theme29.typography.fontSize,
  color: Theme29.text.primary,
  position: "relative",
  $nest: {
    "*": {
      boxSizing: "border-box"
    },
    ".menu": {
      display: "block",
      margin: 0,
      padding: 0,
      listStyle: "none"
    },
    ".menu-horizontal": {
      display: "flex",
      flexWrap: "nowrap"
    },
    ".menu-inline": {
      $nest: {
        ".menu-item": {
          paddingLeft: "calc(1.5rem + var(--menu-item-level, 0) * 1rem)"
        },
        ".menu-item-arrow": {
          marginTop: "-14px",
          right: "6px",
          padding: "8px"
        },
        ".menu-item-arrow-active": {
          transform: "rotate(180deg)",
          transition: "transform 0.25s",
          fill: `${Theme29.text.primary} !important`
        },
        "li": {
          position: "relative",
          $nest: {
            "&:hover": {
              $nest: {
                ".menu-item": {
                  color: Theme29.colors.primary.main
                },
                ".menu-item-arrow-active": {
                  fill: "currentColor !important"
                }
              }
            }
          }
        }
      }
    }
  }
});
var meunItemStyle = style({
  position: "relative",
  display: "block",
  $nest: {
    ".menu-item": {
      position: "relative",
      display: "inline-flex",
      padding: "0 1.5rem",
      border: 0,
      borderRadius: 5,
      cursor: "pointer",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      lineHeight: "36px",
      width: "100%",
      justifyContent: "var(--custom-text-align, left)",
      alignItems: "center"
    },
    "&:not(.hide-arrow-icon) .menu-item.has-children": {
      paddingRight: "2.25rem"
    },
    ".menu-item.menu-active, .menu-item.menu-selected, .menu-item:hover": {
      background: Theme29.action.hoverBackground,
      color: Theme29.action.hover
    },
    ".menu-item.menu-active > .menu-item-arrow": {
      transform: "rotate(180deg)",
      transition: "transform 0.25s"
    },
    ".menu-item-arrow": {
      position: "absolute",
      top: "50%",
      right: 18,
      marginTop: -6,
      cursor: "pointer"
    },
    ".menu-item-icon": {
      display: "inline-block",
      verticalAlign: "middle",
      marginRight: "8px",
      textAlign: "center",
      fill: "currentColor",
      flexShrink: "0",
      $nest: {
        "> i-image": {
          display: "flex"
        }
      }
    },
    "i-link, a": {
      display: "block"
    },
    "i-link > a": {
      textDecoration: "unset"
    },
    "i-link:hover *": {
      color: "unset"
    },
    "li": {
      listStyle: "none"
    },
    "&.hide-arrow-icon .menu-item-arrow": {
      display: "none"
    }
  }
});
var modalStyle2 = style({
  $nest: {
    ".reverse-menu": {
      display: "flex",
      flexDirection: "column-reverse"
    },
    "> div": {
      transform: "unset",
      transition: "background 0.2s cubic-bezier(0.4, 0, 1, 1), color 0.2s cubic-bezier(0.4, 0, 1, 1)",
      overflow: "visible"
    },
    ".modal": {
      boxShadow: "rgb(0 0 0 / 10%) 0px 0px 5px 0px, rgb(0 0 0 / 10%) 0px 0px 1px 0px",
      minWidth: 0,
      padding: 0,
      borderRadius: "5px"
    }
  }
});

// packages/menu/src/menu.ts
var Theme30 = theme_exports.ThemeVars;
var menuPopupTimeout = 150;
var DEFAULT_VALUES13 = {
  mode: "horizontal"
};
var Menu = class extends Control {
  constructor() {
    super(...arguments);
    this._oldWidth = 0;
  }
  add(options) {
    const newItem = new MenuItem(this, { ...options || {}, linkTo: this, level: 0 });
    this.menuElm.appendChild(newItem);
    this._items.push(newItem);
    this._data.push(options || {});
    if (this._mode === "horizontal")
      this.handleResize();
    return newItem;
  }
  delete(item) {
    const index = this.items.findIndex((menu) => menu.isEqualNode(item));
    if (index !== -1) {
      this.menuElm.removeChild(item);
      this._items.splice(index, 1);
      this._data.splice(index, 1);
      item.remove();
      if (this._mode === "horizontal")
        this.handleResize();
    }
  }
  get mode() {
    return this._mode;
  }
  set mode(value) {
    if (this._mode === value)
      return;
    if (this._mode) {
      this.menuElm.classList.remove(`menu-${this._mode}`);
    }
    this._mode = value;
    this.menuElm.classList.add(`menu-${this._mode}`);
    this.handleUpdateMode(value);
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this.clear();
    this._data = value;
    this.renderItem(value);
  }
  get items() {
    return this._items;
  }
  set items(items) {
    this.clear();
    this._items = items;
    this.menuElm.innerHTML = "";
    if (items && items.length) {
      this.updateItemOptions(items);
      this.menuElm.append(...items);
      if (this._mode === "horizontal")
        this.handleResize();
    }
  }
  get selectedItem() {
    return this._selectedItem;
  }
  set selectedItem(item) {
    if (item == null) {
      if (this._selectedItem) {
        this._selectedItem.selected = false;
      }
      this._selectedItem = void 0;
    } else {
      this._selectedItem = item;
      this._selectedItem.selected = true;
    }
  }
  updateItemOptions(items, level = 0) {
    var _a;
    if (!items || !(items == null ? void 0 : items.length))
      return;
    for (let item of items) {
      item.linkTo = this;
      item.level = level;
      if ((_a = item.children) == null ? void 0 : _a.length) {
        let items2 = [];
        for (let child2 of item.children) {
          if (child2 instanceof MenuItem) {
            items2.push(child2);
          }
        }
        this.updateItemOptions(items2, level + 1);
        item.items = items2;
      }
    }
  }
  get menuItems() {
    var _a;
    if (this.moreItem) {
      return [...this.items, ...((_a = this.moreItem) == null ? void 0 : _a.items) || []];
    }
    return this.items;
  }
  clear() {
    this._items = [];
    this.itemsWidth = [];
    this.menuElm.innerHTML = "";
    if (this.moreItem)
      this.moreItem.items = [];
  }
  async renderItem(items) {
    const _items = [];
    const menuItemElm = [];
    for (const item of items) {
      const menuItem = await MenuItem.create({ ...item, linkTo: this, level: 0 }, this);
      menuItemElm.push(menuItem);
      _items.push(menuItem);
    }
    this.menuElm.innerHTML = "";
    ``;
    this.menuElm.append(...menuItemElm);
    this._items = _items;
    if (this._mode === "horizontal")
      this.handleResize();
  }
  async handleUpdateMode(mode) {
    if (this._mode === "horizontal") {
      if (!this.moreItem) {
        this.moreItem = await MenuItem.create({ title: "\u22EF", linkTo: this, level: 0 });
        this.moreItem.classList.add("more-menu-item", "hide-arrow-icon");
      }
      window.addEventListener("resize", this.handleResize);
    } else {
      window.removeEventListener("resize", this.handleResize);
      if (this.moreItem && this.menuElm.contains(this.moreItem))
        this.menuElm.removeChild(this.moreItem);
    }
    this.rerenderItems(this._items);
  }
  rerenderItems(items) {
    var _a;
    if (items == null ? void 0 : items.length) {
      for (let item of items) {
        if ((_a = item.items) == null ? void 0 : _a.length) {
          item.items = [...item.items];
          this.rerenderItems(item.items);
        }
      }
    }
  }
  onResize() {
    var _a, _b, _c;
    const newWidth = Math.ceil(window.innerWidth);
    let offsetWidth = Math.ceil(this.menuElm.offsetWidth);
    let scrollWidth = Math.ceil(this.menuElm.scrollWidth);
    if (this._oldWidth >= newWidth) {
      let i = this._items.length - 1;
      const tmpItems = [];
      while (scrollWidth > offsetWidth && i >= 0) {
        if (!this.menuElm.contains(this.moreItem)) {
          this.menuElm.appendChild(this.moreItem);
        }
        this.itemsWidth.push(this._items[i].offsetWidth);
        tmpItems.push(this._items[i]);
        this._items[i].level = 1;
        this.menuElm.removeChild(this._items[i]);
        this._items.splice(i, 1);
        offsetWidth = Math.ceil(this.menuElm.offsetWidth);
        scrollWidth = Math.ceil(this.menuElm.scrollWidth);
        i--;
      }
      if (tmpItems.length) {
        const moreItems = ((_a = this.moreItem) == null ? void 0 : _a.items) || [];
        this.moreItem.items = [...moreItems, ...tmpItems];
      }
    } else if (this._oldWidth <= newWidth && ((_c = (_b = this.moreItem) == null ? void 0 : _b.items) == null ? void 0 : _c.length)) {
      let i = this.moreItem.items.length - 1 || 0;
      let totalItemsWidth = this._items.reduce((prev, curr) => prev + Math.ceil(curr.offsetWidth), 0) + this.moreItem.offsetWidth + this.itemsWidth[0];
      let index = -1;
      while (totalItemsWidth <= offsetWidth && i >= 0) {
        index = i;
        const menuItem = this.moreItem.items[i];
        this.menuElm.insertBefore(menuItem, this.moreItem);
        this._items.push(menuItem);
        menuItem.level = 0;
        offsetWidth = Math.ceil(this.menuElm.offsetWidth);
        totalItemsWidth += this.itemsWidth.shift() || 0;
        i--;
      }
      if (index != -1) {
        this.moreItem.items = this.moreItem.items.slice(0, index);
      }
      if (!this.moreItem.items.length && this.menuElm.contains(this.moreItem)) {
        this.menuElm.removeChild(this.moreItem);
      }
    }
    this._oldWidth = newWidth;
  }
  handleResize() {
    clearTimeout(this.resizeTimeout);
    this.resizeTimeout = setTimeout(() => {
      this.onResize();
    }, 200);
  }
  init() {
    if (!this.initialized) {
      let menuItems = [];
      for (let i = 0; i < this.children.length; i++) {
        const child2 = this.children[i];
        if (child2 instanceof MenuItem) {
          menuItems.push(child2);
        } else {
          child2.remove();
        }
      }
      super.init();
      this.classList.add(menuStyle);
      this.itemsWidth = [];
      this.handleResize = this.handleResize.bind(this);
      this.onResize = this.onResize.bind(this);
      this.menuElm = this.createElement("ul", this);
      this.menuElm.classList.add("menu");
      this.mode = this.getAttribute("mode", true, DEFAULT_VALUES13.mode);
      this.data = this.getAttribute("data", true, []);
      const items = this.getAttribute("items", true, []);
      if (menuItems == null ? void 0 : menuItems.length)
        this.items = menuItems;
      else if (items == null ? void 0 : items.length)
        this.items = items;
    }
  }
  disconnectedCallback() {
    window.removeEventListener("resize", this.handleResize);
    super.disconnectedCallback();
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Menu = __decorateClass([
  customElements2("i-menu", {
    icon: "bars",
    group: GroupType.BASIC,
    className: "Menu",
    props: {
      mode: {
        type: "string",
        default: DEFAULT_VALUES13.mode
      },
      data: { type: "array", default: [] }
    },
    events: {
      onItemClick: [
        { name: "target", type: "Menu", isControl: true },
        { name: "item", type: "MenuItem", isControl: true }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        mode: {
          type: "string",
          enum: ["horizontal", "vertical", "inline"],
          default: DEFAULT_VALUES13.mode
        }
      }
    }
  })
], Menu);
var ContextMenu = class extends Menu {
  show(pos) {
    const { x, y } = pos;
    this.handleModalOpen(x, y);
  }
  hide() {
    clearTimeout(this.openTimeout);
    if (this.modal) {
      this.modal.visible = false;
    }
  }
  async renderItemModal(x, y) {
    const background = this.getAttribute("background", true);
    const font = this.getAttribute("font", true);
    const minWidth = this.getAttribute("minWidth", true);
    if (!this.modal) {
      this.modal = await Modal.create({
        showBackdrop: false,
        height: "auto",
        width: "auto",
        popupPlacement: "right",
        font: font || { color: Theme30.text.primary },
        minWidth: minWidth || "auto"
      });
      this.modal.classList.add(modalStyle2);
      this.modal.visible = false;
      this.getModalContainer().appendChild(this.modal);
      this.getModalContainer().style.position = "fixed";
    }
    if (background == null ? void 0 : background.color) {
      this.modal.background = background;
    }
    if (font) {
      this.modal.font = font;
    }
    this.getModalContainer().style.left = `${x}px`;
    this.getModalContainer().style.top = `${y}px`;
    this.getModalContainer().style.zIndex = `9999`;
    if (!this.itemPanel)
      this.itemPanel = await Panel.create();
    this.itemPanel.innerHTML = "";
    if (this.items && this.items.length) {
      if (font) {
        for (let item of this.items) {
          item.font = font;
        }
      }
      this.itemPanel.append(...this.items);
    }
    this.modal.item = this.itemPanel;
  }
  getModalContainer() {
    let span = document.getElementById("modal-context");
    if (!span) {
      span = this.createElement("span", document.body);
      span.id = "modal-context";
    }
    return span;
  }
  async handleModalOpen(x, y) {
    await this.renderItemModal(x, y);
    clearTimeout(this.openTimeout);
    this.openTimeout = setTimeout(() => {
      if (this.items && this.items.length)
        this.modal.visible = true;
    }, menuPopupTimeout);
  }
};
ContextMenu = __decorateClass([
  customElements2("i-context-menu")
], ContextMenu);
var DEFAULT_ITEM = {
  target: "_blank",
  textAlign: "left"
};
var MenuItem = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._level = 0;
    this._textAlign = DEFAULT_ITEM.textAlign;
  }
  add(options) {
    const newItem = new MenuItem(this, options);
    if (!this._items)
      this._items = [];
    this._items.push(newItem);
    newItem.level = this._level + 1;
    newItem.linkTo = this._linkTo;
    this.items = this._items;
    return newItem;
  }
  delete(item) {
    const index = this.items.findIndex((menu) => menu.isEqualNode(item));
    if (index !== -1) {
      let mode = this.menuMode();
      if (mode === "inline") {
        this.subMenu.removeChild(item);
      }
      this._items.splice(index, 1);
      item.remove();
    }
  }
  get title() {
    return this.captionElm.innerHTML;
  }
  set title(value) {
    this.captionElm.innerHTML = value || "";
  }
  set font(value) {
    if (!this.itemWrapperElm)
      return;
    this.itemWrapperElm.style.color = value.color || "";
    this.itemWrapperElm.style.fontSize = value.size || "";
    this.itemWrapperElm.style.fontFamily = value.name || "";
    this.itemWrapperElm.style.fontStyle = value.style || "";
    this.itemWrapperElm.style.textTransform = value.transform || "none";
    this.itemWrapperElm.style.fontWeight = value.bold ? "bold" : `${value.weight || ""}`;
    this.itemWrapperElm.style.textShadow = value.shadow || "none";
  }
  get font() {
    if (!this.itemWrapperElm)
      return {};
    return {
      color: this.itemWrapperElm.style.color,
      name: this.itemWrapperElm.style.fontFamily,
      size: this.itemWrapperElm.style.fontSize,
      bold: this.itemWrapperElm.style.fontStyle.indexOf("bold") >= 0,
      style: this.itemWrapperElm.style.fontStyle,
      transform: this.itemWrapperElm.style.textTransform,
      weight: this.itemWrapperElm.style.fontWeight,
      shadow: this.itemWrapperElm.style.textShadow
    };
  }
  get link() {
    var _a;
    if (!this._link) {
      this._link = Link.create({
        href: "#",
        target: "_self",
        font: this.font,
        designMode: (_a = this.linkTo) == null ? void 0 : _a.designMode
      }, this);
    }
    return this._link;
  }
  set link(value) {
    var _a;
    if (this._link) {
      this._link.prepend(this.itemWrapperElm);
      this._link.remove();
    }
    this._link = value;
    if (this._link) {
      this._link.designMode = (_a = this.linkTo) == null ? void 0 : _a.designMode;
      this._link.append(this.itemWrapperElm);
      this.itemElm.appendChild(this._link);
    } else {
      this.itemElm.appendChild(this.itemWrapperElm);
    }
  }
  get icon() {
    if (!this._icon) {
      this._icon = Icon.create({
        width: 16,
        height: 16
      }, this);
    }
    ;
    return this._icon;
  }
  set icon(elm) {
    if (this._icon)
      this.itemWrapperElm.removeChild(this._icon);
    this._icon = elm;
    if (this._icon) {
      this.icon.classList.add("menu-item-icon");
      this.itemWrapperElm.prepend(this._icon);
    }
  }
  get items() {
    return this._items;
  }
  set items(items) {
    this._items = items;
    for (let item of this._items) {
      item.remove();
      if (!item.linkTo)
        item.linkTo = this._linkTo;
      if (item._level == 0)
        item.level = (this._level || 0) + 1;
    }
    this.renderArrowIcon();
    this.renderSubMenuItem();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value;
    this.style.setProperty("--custom-text-align", value);
  }
  set level(value) {
    this.updateLevel(value);
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (!this.itemWrapperElm)
      return;
    if (!this._padding)
      this._padding = new SpaceValue(this.itemWrapperElm, value, "padding");
    else
      this._padding.update(value);
  }
  set selected(value) {
    if (value) {
      this.setSelectedItem();
    } else {
      this.isSelected = false;
      if (this.subMenu) {
        this.subMenu.style.display = "none";
      }
    }
  }
  get isSelected() {
    return this.itemWrapperElm.classList.contains("menu-selected");
  }
  set isSelected(value) {
    if (!this.itemWrapperElm)
      return;
    const isInline = this.menuMode() === "inline";
    if (value) {
      this.itemWrapperElm.classList.add("menu-selected");
      if (this.arrowIcon && isInline) {
        this.arrowIcon.classList.add("menu-item-arrow-active");
      }
    } else {
      this.itemWrapperElm.classList.remove("menu-selected");
      if (this.arrowIcon && isInline) {
        this.arrowIcon.classList.remove("menu-item-arrow-active");
      }
    }
  }
  updateLevel(level) {
    if (this._linkTo) {
      this._level = level;
      if (this.modal) {
        this.modal.popupPlacement = this.getModalPlacement();
        if (this._level > 0) {
          this.modal.position = "absolute";
          this.appendChild(this.modal);
        } else {
          this.modal.position = "fixed";
          this.getModalContainer().appendChild(this.modal);
        }
      }
    }
  }
  menuMode() {
    let mode = DEFAULT_VALUES13.mode;
    if (this._linkTo) {
      mode = this._linkTo.mode;
    }
    return mode;
  }
  async renderArrowIcon() {
    const isInline = this.menuMode() === "inline";
    if (!this.arrowIcon) {
      this.arrowIcon = await Icon.create({
        name: "chevron-down",
        fill: "currentColor"
      });
      this.arrowIcon.classList.add("menu-item-arrow");
    }
    this.arrowIcon.width = isInline ? 30 : 12;
    this.arrowIcon.height = isInline ? 30 : 12;
    if (this._items && this._items.length) {
      if (!isInline && !this.itemWrapperElm.contains(this.arrowIcon)) {
        this.itemWrapperElm.appendChild(this.arrowIcon);
      } else if (isInline && !this.itemElm.contains(this.arrowIcon)) {
        this.itemElm.appendChild(this.arrowIcon);
      }
      this.itemWrapperElm.classList.add("has-children");
    } else {
      if (!isInline && this.itemWrapperElm.contains(this.arrowIcon)) {
        this.itemWrapperElm.removeChild(this.arrowIcon);
      } else if (isInline && this.itemElm.contains(this.arrowIcon)) {
        this.itemElm.removeChild(this.arrowIcon);
      }
      this.itemWrapperElm.classList.remove("has-children");
    }
  }
  renderSubMenuItem() {
    let mode = this.menuMode();
    if (mode === "inline") {
      this.itemWrapperElm.style.setProperty("--menu-item-level", this._level.toString());
      if (!this._items.length && !this.subMenu)
        return;
      this.itemElm.removeEventListener("mouseenter", this.handleModalOpen);
      this.itemElm.removeEventListener("mouseleave", this.handleModalClose);
      if (this.modal) {
        this.modal.removeEventListener("mouseenter", this.handleModalOpen);
        this.modal.removeEventListener("mouseleave", this.handleModalClose);
        this.modal.remove();
      }
      if (!this.subMenu) {
        this.subMenu = this.createElement("div", this);
        this.subMenu.classList.add("sub-menu");
        this.subMenu.style.display = "none";
      }
      this.subMenu.append(...this.items);
    } else {
      if (this.items && this.items.length) {
        this.itemElm.addEventListener("mouseenter", this.handleModalOpen);
        this.itemElm.addEventListener("mouseleave", this.handleModalClose);
      } else {
        this.itemElm.removeEventListener("mouseenter", this.handleModalOpen);
        this.itemElm.removeEventListener("mouseleave", this.handleModalClose);
      }
      if (this.subMenu) {
        this.subMenu.remove();
      }
      this.itemWrapperElm.style.removeProperty("--menu-item-level");
    }
  }
  async renderItemModal() {
    var _a;
    if (!this.modal) {
      const placement = this.getModalPlacement();
      this.modal = await Modal.create({
        showBackdrop: false,
        height: "auto",
        width: "auto",
        popupPlacement: placement
      });
      this.modal.linkTo = this;
      this.modal.visible = false;
      this.modal.classList.add("menu-item-modal", modalStyle2);
      this.modal.addEventListener("mouseenter", this.handleModalOpen);
      this.modal.addEventListener("mouseleave", this.handleModalClose);
      if (this._level > 0) {
        this.appendChild(this.modal);
      } else {
        this.modal.position = "fixed";
        this.getModalContainer().appendChild(this.modal);
      }
    }
    if (!this.itemPanel) {
      this.itemPanel = await Panel.create();
      if (this.className.includes("more-menu-item")) {
        this.itemPanel.classList.add("reverse-menu");
      }
    }
    this.itemPanel.innerHTML = "";
    if ((_a = this._items) == null ? void 0 : _a.length) {
      this.itemPanel.append(...this._items);
    }
    this.modal.item = this.itemPanel;
  }
  getModalPlacement() {
    let mode = this.menuMode();
    let placement = "bottomLeft";
    switch (mode) {
      case "vertical":
        placement = "right";
        break;
      case "horizontal":
        placement = this._level > 0 ? "right" : "bottomLeft";
    }
    return placement;
  }
  getModalContainer() {
    let span = document.getElementById("modal-container");
    if (!span) {
      span = this.createElement("span", document.body);
      span.id = "modal-container";
    }
    return span;
  }
  setSelectedItem() {
    if (this._linkTo) {
      let mode = this._linkTo.mode;
      this.isSelected = this.items && this.items.length ? !this.isSelected : true;
      if (this.subMenu) {
        this.subMenu.style.display = this.isSelected ? "block" : "none";
      }
      this.handleSelectItem(this._linkTo.menuItems, mode);
    } else {
      this.isSelected = true;
    }
  }
  handleSelectItem(items, mode) {
    items.forEach((item) => {
      const isCurrItem = item.isSameNode(this);
      if (isCurrItem)
        return;
      const containsItem = item.contains(this);
      if (!isCurrItem)
        item.isSelected = containsItem ? this.isSelected : false;
      if (mode === "inline" && item.subMenu && !containsItem) {
        item.subMenu.style.display = "none";
      }
      if (item.items)
        this.handleSelectItem(item.items, mode);
    });
  }
  _handleClick(event) {
    var _a;
    if (this._designMode)
      return false;
    if (this._linkTo) {
      this._linkTo.selectedItem = this;
    } else {
      this.setSelectedItem();
    }
    if (((_a = this._linkTo) == null ? void 0 : _a.onItemClick) && typeof this._linkTo.onItemClick === "function")
      this._linkTo.onItemClick(this._linkTo, this);
    return super._handleClick(event, true);
  }
  async handleModalOpen(event) {
    if (this._designMode)
      return false;
    await this.renderItemModal();
    clearTimeout(this.closeTimeout);
    this.itemWrapperElm.classList.add("menu-active");
    this.openTimeout = setTimeout(() => {
      if (this._items && this._items.length)
        this.modal.visible = true;
    }, menuPopupTimeout);
  }
  handleModalClose(event) {
    if (this._designMode)
      return false;
    clearTimeout(this.openTimeout);
    this.itemWrapperElm.classList.remove("menu-active");
    this.closeTimeout = setTimeout(() => {
      if (this.modal)
        this.modal.visible = false;
    }, menuPopupTimeout);
  }
  init() {
    var _a, _b, _c;
    if (!this.initialized) {
      super.init();
      this.classList.add(meunItemStyle);
      this.handleModalOpen = this.handleModalOpen.bind(this);
      this.handleModalClose = this.handleModalClose.bind(this);
      this.itemElm = this.createElement("li", this);
      this.itemWrapperElm = this.createElement("div", this.itemElm);
      this.itemWrapperElm.classList.add("menu-item");
      if ((_a = this._linkTo) == null ? void 0 : _a.padding) {
        const padding = this._linkTo.padding;
        this._padding = new SpaceValue(this.itemWrapperElm, padding, "padding");
        this._linkTo.style.padding = "";
      }
      this.captionElm = this.createElement("span", this.itemWrapperElm);
      this.level = this.getAttribute("level", true, 0);
      this.title = this.getAttribute("title", true);
      const textAlign = this.getAttribute("textAlign", true);
      if (textAlign)
        this.textAlign = textAlign;
      const link = this.getAttribute("link", true);
      if (link == null ? void 0 : link.href) {
        link.target = link.target || "_self";
        this.link = new Link(this, { ...link, designMode: (_b = this.linkTo) == null ? void 0 : _b.designMode });
      }
      const icon = this.getAttribute("icon", true);
      if ((icon == null ? void 0 : icon.name) || ((_c = icon == null ? void 0 : icon.image) == null ? void 0 : _c.url)) {
        icon.height = icon.height || "16px";
        icon.width = icon.width || "16px";
        this.icon = new Icon(this, icon);
      }
      ;
      const _items = this.getAttribute("items", true, []);
      if (_items == null ? void 0 : _items.length) {
        let menuItems = [];
        for (const item of _items) {
          const menuItem = new MenuItem(void 0, { ...item, linkTo: this._linkTo, level: this._level + 1 });
          menuItems.push(menuItem);
        }
        this.items = menuItems;
      }
      const font = this.getAttribute("font", true);
      if (font)
        this.font = font;
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
MenuItem = __decorateClass([
  customElements2("i-menu-item", {
    icon: "bars",
    className: "MenuItem",
    props: {
      title: { type: "string", default: "" },
      link: {
        type: "object",
        default: { target: DEFAULT_ITEM.target }
      },
      items: { type: "array", default: [] },
      icon: { type: "object", default: {} },
      textAlign: { type: "string", default: DEFAULT_ITEM.textAlign }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        title: {
          type: "string"
        },
        icon: {
          type: "object",
          properties: {
            name: {
              type: "string"
            },
            width: {
              type: "number"
            },
            height: {
              type: "number"
            },
            fill: {
              type: "string",
              format: "color"
            },
            image: {
              type: "object",
              properties: {
                url: {
                  type: "string"
                }
              }
            }
          }
        },
        link: {
          type: "object",
          properties: {
            href: {
              type: "string"
            },
            target: {
              type: "string",
              enum: ["_blank", "_self", "_parent", "_top"],
              default: DEFAULT_ITEM.target
            }
          }
        },
        textAlign: {
          type: "string",
          enum: ["left", "right", "center"],
          default: DEFAULT_ITEM.textAlign
        }
      }
    }
  })
], MenuItem);

// packages/module/src/module.ts
function ProxySetter(obj, prop, value) {
  obj["__target"][prop] = value;
  return true;
}
function ProxyGetter(target, prop) {
  if (typeof target.__target[prop] == "function")
    return target.__target[prop].bind(target.__target);
  if (prop == "__target")
    return target["__target"];
  else if (prop == "__path")
    return target["__path"];
  else if (prop == "$renderElms" && target.__target)
    return target.__target["$renderElms"];
  let path;
  if (target.__root)
    path = [];
  else
    path = target.__path || [];
  path.push(prop);
  return ProxyObject({
    __target: target.__target,
    __path: path
  });
}
function ProxyObject(target, root) {
  if (target.__root)
    root = true;
  let path;
  if (root)
    path = [];
  else
    path = target.__path || [];
  if (target.__target)
    target = target.__target;
  return new Proxy({ __root: root, __target: target, __path: path }, {
    get: ProxyGetter,
    set: ProxySetter
  });
}
function getObservable(target, paths) {
  if (isObservable(target))
    return target;
  if (target === void 0 || target === null)
    return;
  let path = paths.shift();
  if (paths.length == 0) {
    if (typeof target["observables"] == "function")
      return target["observables"](path);
    else if (path && typeof target == "object")
      return target[path];
  } else
    return getObservable(target[path], paths);
}
function bindObservable(elm, prop) {
  return function(changes) {
    elm[prop] = changes[0].value;
  };
}
var Module = class extends Container {
  constructor(parent, options, defaults) {
    super(parent, options, defaults);
    this.$renderElms = [];
    let proxy = ProxyObject(this, true);
    this.$render = this._render.bind(proxy);
  }
  static async create(options, parent, defaults) {
    let self = new this(parent, options, defaults);
    await self.ready();
    return self;
  }
  init() {
    super.init();
    this.$renderElms = [];
    let proxy = ProxyObject(this, true);
    let render = this.render.bind(proxy);
    let r = window["Render"];
    window["Render"] = this._render.bind(proxy);
    render();
    for (let i = 0; i < this.$renderElms.length; i++) {
      let elm = this.$renderElms[i].elm;
      let options = this.$renderElms[i].options;
      for (let prop in options) {
        let value = options[prop];
        if (value == null ? void 0 : value.__target) {
          let target = value.__target;
          let paths = value.__path;
          let targetValue = this.getAttributeValue(target, paths);
          let observable3 = getObservable(target, paths);
          if (isObservable(observable3)) {
            if (paths.length > 0)
              Observe(observable3, bindObservable(elm, prop), { path: paths.join(".") });
            else {
              Observe(observable3, bindObservable(elm, prop));
            }
          }
          elm[prop] = targetValue;
        }
      }
    }
    this.$renderElms = [];
    window["Render"] = r;
  }
  flattenArray(arr) {
    return arr.reduce((result, item) => {
      if (Array.isArray(item)) {
        const temp = this.flattenArray(item);
        result = result.concat(temp);
      } else {
        result.push(item);
      }
      return result;
    }, []);
  }
  _render(...params) {
    let tag = params[0];
    let options = params[1];
    let elm = this.createElement(tag);
    if (options) {
      this.$renderElms.push({
        elm,
        options
      });
      elm.attrs = options;
      for (let v in options) {
        if (v == "id") {
          this[options[v]] = elm;
          elm.id = options[v];
        } else if (typeof options[v] == "function")
          elm[v] = options[v].bind(this);
        else if (typeof options[v] != "object")
          elm.setAttribute(v, options[v]);
      }
    }
    const newParams = this.flattenArray(params);
    for (let i = 2; i < newParams.length; i++) {
      elm.appendChild(newParams[i]);
    }
    this.appendChild(elm);
    return elm;
  }
  render() {
  }
  onLoad() {
  }
  onShow(options) {
  }
  onHide() {
  }
  disconnectedCallback() {
    delete Module._modalMap[this.uuid];
    super.disconnectedCallback();
  }
  openModal(options) {
    var _a, _b, _c;
    let modal = Module._modalMap[this.uuid];
    if (modal) {
      modal.title = (options == null ? void 0 : options.title) || "";
      modal.zIndex = (options == null ? void 0 : options.zIndex) || 10;
      if (options == null ? void 0 : options.linkTo)
        modal.linkTo = options.linkTo;
      modal.showBackdrop = (_a = options == null ? void 0 : options.showBackdrop) != null ? _a : true;
      modal.visible = true;
      document.body.appendChild(modal);
      Module._modalMap[this.uuid] = modal;
      return modal;
    }
    const showBackdrop = (_b = options == null ? void 0 : options.showBackdrop) != null ? _b : true;
    const modalOptions = {
      border: { radius: 10 },
      closeIcon: showBackdrop ? { name: "times" } : null,
      ...options
    };
    modal = new Modal(void 0, {
      ...modalOptions
    });
    document.body.appendChild(modal);
    Module._modalMap[this.uuid] = modal;
    modal.body = this;
    modal.zIndex = (options == null ? void 0 : options.zIndex) || 10;
    if (options == null ? void 0 : options.linkTo)
      modal.linkTo = options.linkTo;
    modal.showBackdrop = (_c = options == null ? void 0 : options.showBackdrop) != null ? _c : true;
    modal.visible = true;
    return modal;
  }
  closeModal() {
    let modal = Module._modalMap[this.uuid];
    if (modal) {
      modal.visible = false;
    }
  }
};
Module._modalMap = {};
Module = __decorateClass([
  customElements2("i-module")
], Module);

// packages/tree-view/src/style/treeView.css.ts
var Theme31 = theme_exports.ThemeVars;
cssRule("i-tree-view", {
  display: "block",
  overflowY: "auto",
  overflowX: "hidden",
  fontFamily: Theme31.typography.fontFamily,
  fontSize: Theme31.typography.fontSize,
  $nest: {
    ".i-tree-node_content": {
      display: "flex",
      alignItems: "center",
      paddingLeft: "1em",
      border: "1px solid transparent"
    },
    "> i-tree-node > .i-tree-node_content": {
      paddingLeft: 0
    },
    "i-tree-node": {
      display: "block",
      position: "relative"
    },
    "> i-tree-node:not(.has-children) .i-tree-node_icon:not(.custom-icon)": {
      display: "none"
    },
    "i-tree-node.is-checked > .i-tree-node_children": {
      display: "block"
    },
    "i-tree-node.is-checked > .i-tree-node_content > .i-tree-node_icon": {
      transform: "rotate(90deg)"
    },
    'input[type="checkbox"]': {
      position: "absolute",
      clip: "rect(0, 0, 0, 0)"
    },
    ".i-tree-node_children": {
      display: "none"
    },
    ".i-tree-node_label": {
      position: "relative",
      display: "inline-block",
      color: Theme31.text.primary,
      cursor: "pointer",
      fontSize: "inherit"
    },
    ".i-tree-node_icon": {
      display: "inline-block",
      transition: "all ease 0.4s",
      $nest: {
        "svg": {
          width: 14,
          height: 14
        },
        "i-image": {
          display: "flex"
        },
        "&:not(.custom-icon)": {
          display: "none"
        }
      }
    },
    "input ~ .i-tree-node_icon:not(.custom-icon), input ~ .is-right > .i-tree-node_icon:not(.custom-icon)": {
      display: "inline-block"
    },
    "input ~ .i-tree-node_label": {
      maxWidth: "calc(100% - 15px)"
    },
    ".i-tree-node_icon + .i-tree-node_label": {
      paddingLeft: "0.3em"
    },
    "&.i-tree-view": {
      padding: 0,
      position: "relative",
      $nest: {
        ".is-checked:before": {
          borderLeft: `1px solid ${Theme31.divider}`,
          height: "calc(100% - 1em)",
          top: "1em"
        },
        ".i-tree-node_children > .is-checked:before": {
          height: "calc(100% - 25px)",
          top: 25
        },
        "i-tree-node.active > .i-tree-node_content": {
          backgroundColor: Theme31.action.selectedBackground,
          color: Theme31.action.selected,
          $nest: {
            "> .i-tree-node_label": {
              color: Theme31.action.selected
            }
          }
        },
        ".i-tree-node_content:hover": {
          backgroundColor: Theme31.action.hoverBackground,
          color: Theme31.action.hover,
          $nest: {
            "> .is-right .button-group *": {
              display: "inline-flex"
            },
            ".hide-on-show": {
              display: "none !important"
            }
          }
        },
        'input[type="checkbox"]': {
          margin: 0
        },
        ".i-tree-node_label": {
          padding: ".2rem .3rem .2em 0",
          maxWidth: "calc(100% - 30px)",
          whiteSpace: "nowrap",
          overflow: "hidden",
          textOverflow: "ellipsis"
        }
      }
    },
    "&.shown-line": {
      $nest: {
        "> i-tree-node.has-children": {
          marginLeft: "1em"
        },
        "input ~ .i-tree-node_label:before": {
          background: Theme31.colors.primary.main,
          color: Theme31.colors.primary.contrastText,
          position: "relative",
          zIndex: "1",
          float: "left",
          margin: "0 1em 0 -2em",
          width: "1em",
          height: "1em",
          borderRadius: "0.2em",
          content: "'+'",
          textAlign: "center",
          lineHeight: ".9em"
        },
        "input:checked ~ .i-tree-node_label:before": {
          content: "'\u2013'"
        },
        "i-tree-node": {
          padding: "0 0 1em 1em",
          $nest: {
            "&.active": {
              $nest: {
                "> .i-tree-node_label": {
                  color: "#55f"
                }
              }
            }
          }
        },
        ".i-tree-node_children i-tree-node": {
          padding: ".5em 0 0 .9em"
        },
        "i-tree-node:last-of-type:before": {
          height: "1em",
          bottom: "auto"
        },
        " i-tree-node:before": {
          position: "absolute",
          top: "0",
          bottom: "0",
          left: "-.1em",
          display: "block",
          width: "1px",
          borderLeft: `1px solid ${Theme31.divider}`,
          content: "''"
        },
        ".i-tree-node_icon:not(.custom-icon)": {
          display: "none"
        },
        ".i-tree-node_content": {
          paddingLeft: `0 !important`
        },
        "i-tree-node .i-tree-node_label:after": {
          position: "absolute",
          top: ".25em",
          left: "-1em",
          display: "block",
          height: "0.5em",
          width: "1em",
          borderBottom: `1px solid ${Theme31.divider}`,
          borderLeft: `1px solid ${Theme31.divider}`,
          borderRadius: " 0 0 0 0",
          content: "''"
        },
        "i-tree-node input:checked ~ .i-tree-node_label:after": {
          borderRadius: "0 .1em 0 0",
          borderTop: `1px solid ${Theme31.divider}`,
          borderRight: `0.5px solid ${Theme31.divider}`,
          borderBottom: "0",
          borderLeft: "0",
          bottom: "0",
          height: "auto",
          top: ".5em"
        },
        ".i-tree-node_label": {
          overflow: "unset"
        }
      }
    },
    ".text-input": {
      border: "none",
      outline: "0",
      height: "100%",
      width: "100%",
      $nest: {
        "&:focus": {
          borderBottom: `2px solid ${Theme31.colors.primary.main}`
        }
      }
    },
    ".button-group": {
      display: "inline-flex",
      alignItems: "center",
      position: "relative",
      zIndex: 999,
      transition: ".3s all ease",
      gap: 5,
      cursor: "pointer",
      marginLeft: 5,
      $nest: {
        "*": {
          display: "none"
        }
      }
    },
    ".is-right": {
      marginLeft: "auto",
      width: "auto"
    }
  }
});

// packages/tree-view/src/treeView.ts
var Theme32 = theme_exports.ThemeVars;
var beforeExpandEvent = new Event("beforeExpand");
var defaultIcon2 = {
  name: "caret-right",
  fill: Theme32.text.secondary,
  width: "0.75rem",
  height: "0.75rem"
};
var TreeView = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      editable: false
    });
    this._items = [];
    this._alwaysExpanded = false;
    this._deleteNodeOnEmptyCaption = false;
  }
  get activeItem() {
    return this._activeItem;
  }
  set activeItem(value) {
    this._activeItem = value;
    const treeNodes = Array.from(this.querySelectorAll("i-tree-node"));
    treeNodes.forEach((treeNode) => treeNode.active = false);
    if (value)
      value.active = true;
  }
  get alwaysExpanded() {
    return this._alwaysExpanded;
  }
  set alwaysExpanded(value) {
    this._alwaysExpanded = value;
  }
  get data() {
    return this._items.map((node) => node.data);
  }
  set data(value) {
    this.clear();
    this.renderTree(value);
  }
  get items() {
    return this._items || [];
  }
  get editable() {
    return this._editable;
  }
  set editable(value) {
    this._editable = value;
  }
  get actionButtons() {
    var _a;
    return (_a = this._actionButtons) != null ? _a : [];
  }
  set actionButtons(value) {
    this._actionButtons = value != null ? value : [];
    const groups = Array.from(this.querySelectorAll(".button-group"));
    if (groups && groups.length) {
      groups.forEach((group) => {
        this.renderActions(group);
      });
    }
  }
  add(parentNode, caption) {
    const childData = { caption, children: [] };
    const childNode = new TreeNode(this, { ...childData });
    this.initNode(childNode);
    childNode.editable = this.editable;
    childNode.alwaysExpanded = this.alwaysExpanded;
    if (typeof this.onRenderNode === "function")
      this.onRenderNode(this, childNode);
    if (parentNode) {
      parentNode.appendNode(childNode);
      const parentContent = parentNode.querySelector(".i-tree-node_content");
      const childContent = childNode.querySelector(".i-tree-node_content");
      if (parentContent && childContent) {
        const parentLeft = parentContent.style.paddingLeft || 0;
        childContent.style.paddingLeft = parentLeft ? `calc(${parentLeft} + 1em)` : "1em";
      }
    } else {
      this.appendChild(childNode);
    }
    return childNode;
  }
  appendNode(childNode) {
    var _a;
    this.initNode(childNode);
    childNode.editable = this.editable;
    childNode.alwaysExpanded = this.alwaysExpanded;
    if (typeof this.onRenderNode === "function")
      this.onRenderNode(this, childNode);
    this.appendChild(childNode);
    if ((_a = childNode.children) == null ? void 0 : _a.length) {
      for (let child2 of childNode.children) {
        if (child2 instanceof TreeNode) {
          childNode.appendNode(child2);
        }
      }
    }
  }
  delete(node) {
    node.remove();
  }
  clear() {
    this.clearInnerHTML();
    this._items = [];
  }
  _setActiveItem(node, event) {
    const prevNode = this.activeItem;
    this.activeItem = node;
    if (event && typeof this.onActiveChange === "function") {
      this.onActiveChange(this, prevNode, event);
    }
    ;
  }
  handleMouseEnter(node) {
    const fn = this.onMouseEnterNode;
    if (fn && typeof fn === "function")
      fn(this, node);
  }
  handleMouseLeave(node) {
    const fn = this.onMouseLeaveNode;
    if (fn && typeof fn === "function")
      fn(this, node);
  }
  handleLazyLoad(node) {
    const fn = this.onLazyLoad;
    if (fn && typeof fn === "function")
      fn(this, node);
  }
  initNode(node) {
    this.registerEvents(node);
    const groupElm = node.querySelector(".button-group");
    if (this.actionButtons)
      this.renderActions(groupElm);
  }
  registerEvents(node) {
    node.addEventListener("mouseenter", () => this.handleMouseEnter(node));
    node.addEventListener("mouseleave", () => this.handleMouseLeave(node));
    node.addEventListener("beforeExpand", (event) => this.handleLazyLoad(node));
    if (typeof this.onRenderNode === "function")
      this.onRenderNode(this, node);
  }
  renderTreeNode(node, parent, paths = [], level) {
    const treeNode = new TreeNode(parent, node);
    treeNode.editable = this.editable;
    this.initNode(treeNode);
    const treeContent = treeNode.querySelector(".i-tree-node_content");
    treeContent && (treeContent.style.paddingLeft = `${level}em`);
    const name = node.caption || "";
    if (node.children) {
      paths.push({ name });
      if (!node.isLazyLoad) {
        for (const child2 of node.children) {
          const childWrapper = treeNode.querySelector(".i-tree-node_children");
          if (childWrapper) {
            const childNode = this.renderTreeNode(child2, parent, paths, level + 1);
            childWrapper && childWrapper.appendChild(childNode);
          }
        }
      }
    } else {
    }
    return treeNode;
  }
  renderTree(value) {
    if (!value || !value.length)
      return;
    for (const node of value) {
      let treeNode = this.renderTreeNode(node, this, [], 0);
      this.appendChild(treeNode);
      const activedNodes = treeNode.querySelectorAll(".active");
      if (activedNodes.length) {
        const activedNode = activedNodes[activedNodes.length - 1];
        treeNode.expanded = true;
        const treeNodes = Array.from(treeNode.querySelectorAll("i-tree-node.has-children"));
        treeNodes.forEach((treeNode2) => {
          if (treeNode2.contains(activedNode))
            treeNode2.expanded = true;
        });
        this.activeItem = activedNode;
      }
      this._items.push(treeNode);
    }
  }
  renderActions(group) {
    if (!group)
      return;
    group.innerHTML = "";
    this.actionButtons.forEach((button) => {
      const buttonElm = new Button(void 0, button);
      if (this.onActionButtonClick && typeof this.onActionButtonClick === "function")
        buttonElm.onClick = (source, event) => {
          var _a;
          event.preventDefault();
          event.stopImmediatePropagation();
          const node = buttonElm.closest("i-tree-node");
          if (node && !((_a = this.activeItem) == null ? void 0 : _a.isSameNode(node)))
            this.activeItem = node;
          this.onActionButtonClick(this, buttonElm, event);
        };
      group.appendChild(buttonElm);
    });
  }
  init() {
    var _a;
    if (!this.initialized) {
      let treeNodes = [];
      for (let i = 0; i < this.children.length; i++) {
        const child2 = this.children[i];
        if (child2 instanceof TreeNode) {
          treeNodes.push(child2);
        } else {
          child2.remove();
        }
      }
      super.init();
      this.classList.add("i-tree-view");
      if (typeof ((_a = this.options) == null ? void 0 : _a.onRenderNode) === "function")
        this.onRenderNode = this.options.onRenderNode;
      this.alwaysExpanded = this.getAttribute("alwaysExpanded", true, false);
      this.editable = this.getAttribute("editable", true, false);
      this.actionButtons = this.getAttribute("actionButtons", true);
      this.data = this.getAttribute("data", true);
      this._deleteNodeOnEmptyCaption = this.getAttribute("deleteNodeOnEmptyCaption", true);
      console.log("_deleteNodeOnEmptyCaption", this._deleteNodeOnEmptyCaption);
      const activeAttr = this.getAttribute("activeItem", true);
      activeAttr && (this.activeItem = activeAttr);
      if (treeNodes == null ? void 0 : treeNodes.length) {
        for (let node of treeNodes) {
          this.appendNode(node);
        }
      }
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
TreeView = __decorateClass([
  customElements2("i-tree-view", {
    icon: "stream",
    group: GroupType.BASIC,
    className: "TreeView",
    props: {
      activeItem: { type: "object" },
      data: { type: "array" },
      editable: { type: "boolean" },
      actionButtons: { type: "array" },
      alwaysExpanded: { type: "boolean" },
      deleteNodeOnEmptyCaption: { type: "boolean" }
    },
    events: {
      onActiveChange: [
        { name: "target", type: "TreeView", isControl: true },
        { name: "prevNode", type: "TreeNode", isControl: true },
        { name: "event", type: "Event" }
      ],
      onChange: [
        { name: "target", type: "TreeView", isControl: true },
        { name: "node", type: "TreeNode", isControl: true },
        { name: "oldValue", type: "string" },
        { name: "newValue", type: "string" }
      ],
      onRenderNode: [
        { name: "target", type: "TreeView", isControl: true },
        { name: "node", type: "TreeNode", isControl: true }
      ],
      onMouseEnterNode: [
        { name: "target", type: "TreeView", isControl: true },
        { name: "node", type: "TreeNode", isControl: true }
      ],
      onMouseLeaveNode: [
        { name: "target", type: "TreeView", isControl: true },
        { name: "node", type: "TreeNode", isControl: true }
      ],
      onLazyLoad: [
        { name: "target", type: "TreeView", isControl: true },
        { name: "node", type: "TreeNode", isControl: true }
      ],
      onActionButtonClick: [
        { name: "target", type: "TreeView", isControl: true },
        { name: "actionButton", type: "Button", isControl: true },
        { name: "event", type: "Event" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        editable: {
          type: "boolean"
        },
        actionButtons: {
          type: "array"
        },
        alwaysExpanded: {
          type: "boolean"
        },
        deleteNodeOnEmptyCaption: {
          type: "boolean"
        }
      }
    }
  })
], TreeView);
var TreeNode = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._editable = false;
    this._alwaysExpanded = false;
    options && (this.data = options);
    this.handleEdit = this.handleEdit.bind(this);
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
  }
  get caption() {
    return this._caption;
  }
  set caption(value) {
    this._caption = value;
    if (this._captionElm)
      this._captionElm.innerHTML = value;
  }
  get collapsible() {
    return this._collapsible;
  }
  set collapsible(value) {
    if (typeof value === "boolean") {
      this._collapsible = value;
    } else {
      this._collapsible = true;
    }
  }
  get expanded() {
    return this._expanded;
  }
  set expanded(value) {
    if (typeof value === "boolean") {
      this._expanded = value;
      if (this._expandElm)
        this._expandElm.checked = value;
      if (this._expanded)
        this.classList.add("is-checked");
      else
        this.classList.remove("is-checked");
    } else {
      this._expanded = false;
      if (this._expandElm)
        this._expandElm.checked = false;
      this.classList.remove("is-checked");
    }
  }
  get alwaysExpanded() {
    return this._alwaysExpanded;
  }
  set alwaysExpanded(value) {
    this._alwaysExpanded = value;
  }
  get active() {
    return this._active;
  }
  set active(value) {
    if (typeof value === "boolean") {
      this._active = value;
      this.active ? this.classList.add("active") : this.classList.remove("active");
    } else {
      this._active = false;
      this.classList.remove("active");
    }
  }
  get isLazyLoad() {
    return this._isLazyLoad;
  }
  set isLazyLoad(value) {
    this._isLazyLoad = value;
  }
  get editable() {
    return this._editable;
  }
  set editable(value) {
    this._editable = value;
  }
  get rootParent() {
    return this.closest("i-tree-view");
  }
  get icon() {
    if (!this._iconElm) {
      this._iconElm = Icon.create(defaultIcon2);
    }
    ;
    return this._iconElm;
  }
  get rightIcon() {
    if (!this._iconRightElm)
      this._iconRightElm = Icon.create(defaultIcon2);
    return this._iconRightElm;
  }
  get height() {
    return !isNaN(this._height) ? this._height : this.offsetHeight;
  }
  set height(value) {
    this._height = value;
    this._wrapperElm.style.height = typeof value === "string" ? value : `${value}px`;
  }
  handleChange(target, oldValue, newValue) {
    debugger;
    const fn = this.rootParent.onChange;
    if (fn && typeof fn === "function")
      fn(this.rootParent, target, oldValue, newValue);
  }
  renderEditMode() {
    const captionInput = this.createElement("input");
    captionInput.value = this.caption;
    captionInput.classList.add("text-input");
    this._captionElm.innerHTML = "";
    this._captionElm.appendChild(captionInput);
    captionInput.focus();
    this.click();
    let isUpdating = false;
    let isValid = true;
    const updateCaption = () => {
      const newValue = captionInput.value;
      console.log("rootparent deleteNodeOnEmptyCaption", this.rootParent._deleteNodeOnEmptyCaption);
      console.log("empty string", captionInput.value.replace(/\s+/g, "") === "");
      if (this.rootParent._deleteNodeOnEmptyCaption && captionInput.value.replace(/\s+/g, "") === "") {
        return this.remove();
      }
      if (newValue !== this.caption) {
        const fn = this.rootParent.onBeforeChange;
        if (fn && typeof fn === "function")
          isValid = fn(this.rootParent, this, this.caption, newValue);
        if (isValid) {
          this.handleChange(this, this.caption, newValue);
          this.caption = newValue;
        }
      } else {
        this.caption = this._caption;
      }
    };
    captionInput.addEventListener("blur", (event) => {
      event.preventDefault();
      if (isUpdating)
        return;
      if (!isValid) {
        captionInput.value = this._caption;
      }
      updateCaption();
    });
    captionInput.addEventListener("keyup", (event) => {
      event.preventDefault();
      if (event.key === "Enter" || event.keyCode === 13) {
        isUpdating = true;
        updateCaption();
        isUpdating = false;
      }
    });
  }
  handleEdit(event) {
    event.stopImmediatePropagation();
    event.preventDefault();
    this.renderEditMode();
  }
  edit() {
    this.editable = true;
    this.renderEditMode();
  }
  appendNode(childNode) {
    if (!this._childNodeElm)
      this.initChildNodeElm();
    this._childNodeElm.appendChild(childNode);
    if (!this.data.children)
      this.data.children = [];
    this.data.children.push(childNode.data);
    return childNode;
  }
  initChildNodeElm() {
    this.classList.add("has-children");
    this._expandElm = this.createElement("input", this._wrapperElm);
    this._expandElm.type = "checkbox";
    if (this.expanded)
      this._expandElm.checked = true;
    if (this._iconElm)
      this._wrapperElm.insertBefore(this._expandElm, this._iconElm);
    else
      this._wrapperElm.insertBefore(this._expandElm, this._captionElm);
    this._childNodeElm = this.createElement("div", this);
    this._childNodeElm.classList.add("i-tree-node_children");
  }
  _handleClick(event) {
    const target = event.target;
    if (this.collapsible && this._expandElm) {
      this._expandElm.checked = !this._expandElm.checked;
      if (this._expandElm.checked)
        this.classList.add("is-checked");
      else if (!this.alwaysExpanded)
        this.classList.remove("is-checked");
    }
    ;
    const parent = this._parent || target.closest("i-tree-view");
    if (parent instanceof TreeView) {
      parent._setActiveItem(this, event);
      if (parent.onClick)
        parent.onClick(parent, event);
    }
    if (this.isLazyLoad) {
      this.dispatchEvent(beforeExpandEvent);
    }
    return super._handleClick(event, true);
  }
  _handleDblClick(event) {
    const target = event.target;
    const parent = this._parent || target.closest("i-tree-view");
    if (this.editable) {
      this.handleEdit(event);
    } else if (parent instanceof TreeView) {
      if (parent.onDblClick)
        parent.onDblClick(parent, event);
    }
    ;
    return super._handleClick(event, true);
  }
  _handleContextMenu(event) {
    const target = event.target;
    const parent = this._parent || target.closest("i-tree-view");
    if (parent instanceof TreeView) {
      if (parent.onContextMenu)
        parent.onContextMenu(parent, event);
    }
    return super._handleClick(event, true);
  }
  init() {
    var _a, _b;
    if (!this._captionElm) {
      this.classList.add("i-tree-node");
      this.data = this.options;
      let caption = this.getAttribute("caption", true, "");
      let icon = this.getAttribute("icon", true);
      let rightIcon = this.getAttribute("rightIcon", true);
      let collapsible = this.getAttribute("collapsible", true);
      let expanded = this.getAttribute("expanded", true);
      let active = this.getAttribute("active", true, false);
      let isLazyLoad = this.getAttribute("isLazyLoad", true, false);
      this.collapsible = collapsible;
      this.expanded = expanded;
      this.active = active;
      this.isLazyLoad = isLazyLoad;
      this._wrapperElm = this.createElement("div", this);
      this._wrapperElm.classList.add("i-tree-node_content");
      const iconData = icon || defaultIcon2;
      iconData.height = iconData.height || "0.75rem";
      iconData.width = iconData.width || "0.75rem";
      this._iconElm = new Icon(void 0, iconData);
      this._iconElm.classList.add("i-tree-node_icon");
      icon && this._iconElm.classList.add("custom-icon");
      this._wrapperElm.appendChild(this._iconElm);
      this._captionElm = this.createElement("label", this._wrapperElm);
      this._captionElm.classList.add("i-tree-node_label");
      this.caption = caption;
      const rightWrap = this.createElement("div", this._wrapperElm);
      rightWrap.classList.add("is-right");
      const actionGroup = this.createElement("div", rightWrap);
      actionGroup.classList.add("button-group");
      const rightIconData = rightIcon || defaultIcon2;
      rightIconData.height = rightIconData.height || "0.75rem";
      rightIconData.width = rightIconData.width || "0.75rem";
      rightIconData.name = (rightIcon == null ? void 0 : rightIcon.name) || "";
      this._iconRightElm = new Icon(void 0, rightIconData);
      this._iconRightElm.classList.add("i-tree-node_icon");
      this._iconRightElm.classList.add("custom-icon");
      rightWrap.appendChild(this._iconRightElm);
      rightWrap.insertBefore(this._iconRightElm, actionGroup);
      if ((_b = (_a = this.data) == null ? void 0 : _a.children) == null ? void 0 : _b.length)
        this.initChildNodeElm();
    }
    super.init();
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
TreeNode = __decorateClass([
  customElements2("i-tree-node")
], TreeNode);

// packages/switch/src/style/switch.css.ts
var Theme33 = theme_exports.ThemeVars;
cssRule("i-switch", {
  display: "block",
  fontFamily: Theme33.typography.fontFamily,
  fontSize: Theme33.typography.fontSize,
  $nest: {
    ".wrapper": {
      width: "48px",
      height: "22px",
      position: "relative",
      display: "inline-flex",
      flexShrink: 0,
      overflow: "hidden",
      zIndex: 0,
      verticalAlign: "middle"
    },
    ".switch-base": {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      outline: 0,
      border: 0,
      margin: 0,
      cursor: "pointer",
      userSelect: "none",
      verticalAlign: "middle",
      textDecoration: "none",
      padding: "1px",
      borderRadius: "50%",
      position: "absolute",
      top: 0,
      bottom: 0,
      left: 0,
      zIndex: 1,
      color: "#fff",
      transition: "left 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,transform 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms",
      $nest: {
        "&.checked": {
          transform: "translateX(26px)",
          $nest: {
            ".thumb:before": {
              backgroundImage: "var(--checked-background)"
            },
            ".thumb-text:before": {
              content: "var(--thumb-checked-text)"
            },
            "+.track": {
              backgroundColor: "#1976d2",
              $nest: {
                "&::before": {
                  opacity: 1
                },
                "&::after": {
                  opacity: 0
                }
              }
            }
          }
        }
      }
    },
    input: {
      position: "absolute",
      top: 0,
      left: "-100%",
      width: "300%",
      height: "100%",
      opacity: 0,
      margin: 0,
      padding: 0,
      cursor: "inherit",
      zIndex: 1
    },
    ".thumb": {
      width: "16px",
      height: "16px",
      margin: "2px",
      backgroundColor: "currentColor",
      borderRadius: "50%",
      boxShadow: "none"
    },
    ".thumb:before": {
      content: '""',
      position: "absolute",
      width: "100%",
      height: "100%",
      left: 0,
      top: 0,
      backgroundRepeat: "no-repeat",
      backgroundPosition: "center",
      backgroundSize: "14px",
      backgroundImage: "var(--background)"
    },
    ".thumb.thumb-text:before": {
      content: "var(--thumb-text)",
      position: "absolute",
      width: "inherit",
      height: "inherit",
      top: "auto",
      left: "auto",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      color: "#fff"
    },
    ".track": {
      width: "100%",
      height: "100%",
      zIndex: -1,
      borderRadius: "11px",
      backgroundColor: "#000",
      transition: "opacity 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,background-color 150ms cubic-bezier(0.4, 0, 0.2, 1) 0ms",
      $nest: {
        "&::before": {
          content: "var(--checked-text)",
          position: "absolute",
          left: "4px",
          top: "calc(50% - 0.6px)",
          transform: "translateY(-50%)",
          fontSize: "10px",
          color: "white",
          opacity: 0
        },
        "&::after": {
          content: "var(--text)",
          position: "absolute",
          right: "6px",
          top: "calc(50% - 0.6px)",
          transform: "translateY(-50%)",
          fontSize: "10px",
          color: "white",
          opacity: 1
        }
      }
    }
  }
});

// packages/switch/src/switch.ts
var Switch = class extends Control {
  constructor(parent, options) {
    super(parent, options);
  }
  get checked() {
    return this._checked;
  }
  set checked(value) {
    if (this._checked === value)
      return;
    this._checked = value;
    this._checked ? this.switchBaseElm.classList.add("checked") : this.switchBaseElm.classList.remove("checked");
    if (this._checked) {
      if (this.checkedThumbColor)
        this.switchBaseElm.style.color = this.checkedThumbColor;
      if (this.checkedTrackColor)
        this.trackElm.style.backgroundColor = this.checkedTrackColor;
    } else {
      if (this.uncheckedThumbColor)
        this.switchBaseElm.style.color = this.uncheckedThumbColor;
      if (this.uncheckedTrackColor)
        this.trackElm.style.backgroundColor = this.uncheckedTrackColor;
    }
  }
  get checkedThumbColor() {
    return this._checkedThumbColor;
  }
  set checkedThumbColor(value) {
    if (this._checkedThumbColor === value)
      return;
    this._checkedThumbColor = value;
    if (this._checked) {
      this.switchBaseElm.style.color = this.checkedThumbColor;
    }
  }
  get uncheckedThumbColor() {
    return this._uncheckedThumbColor;
  }
  set uncheckedThumbColor(value) {
    if (this._uncheckedThumbColor === value)
      return;
    this._uncheckedThumbColor = value;
    if (!this._checked) {
      this.switchBaseElm.style.color = value;
    }
  }
  get checkedTrackColor() {
    return this._checkedTrackColor;
  }
  set checkedTrackColor(value) {
    if (this._checkedTrackColor === value)
      return;
    this._checkedTrackColor = value;
    if (this._checked) {
      this.trackElm.style.backgroundColor = value;
    }
  }
  get uncheckedTrackColor() {
    return this._uncheckedTrackColor;
  }
  set uncheckedTrackColor(value) {
    if (this._uncheckedTrackColor === value)
      return;
    this._uncheckedTrackColor = value;
    if (!this._checked) {
      this.trackElm.style.backgroundColor = value;
    }
  }
  get checkedText() {
    return this._checkedText;
  }
  set checkedText(value) {
    this._checkedText = value;
    this.trackElm.style.setProperty("--checked-text", `"${value}"`);
  }
  get uncheckedText() {
    return this._uncheckedText;
  }
  set uncheckedText(value) {
    this._uncheckedText = value;
    this.trackElm.style.setProperty("--text", `"${value}"`);
  }
  get checkedThumbText() {
    return this._checkedThumbText;
  }
  set checkedThumbText(value) {
    this._checkedThumbText = value;
    this.thumbElm.classList.add("thumb-text");
    this.thumbElm.style.setProperty("--thumb-text", `'${value || ""}'`);
  }
  get uncheckedThumbText() {
    return this._uncheckedThumbText;
  }
  set uncheckedThumbText(value) {
    this._uncheckedThumbText = value;
    this.thumbElm.classList.add("thumb-text");
    this.thumbElm.style.setProperty("--thumb-checked-text", `'${value || ""}'`);
  }
  setAttributeToProperty(propertyName) {
    const prop = this.getAttribute(propertyName, true);
    if (prop)
      this[propertyName] = prop;
  }
  _handleClick(event) {
    if (this._designMode)
      return false;
    if (!this.onClick) {
      this.checked = !this.checked;
      if (typeof this.onChanged === "function")
        this.onChanged(this, event);
    }
    return super._handleClick(event, true);
  }
  init() {
    if (!this.wrapperElm) {
      this.wrapperElm = this.createElement("div", this);
      this.wrapperElm.classList.add("wrapper");
      this.switchBaseElm = this.createElement("div");
      this.switchBaseElm.classList.add("switch-base");
      this.wrapperElm.appendChild(this.switchBaseElm);
      this.trackElm = this.createElement("div");
      this.trackElm.classList.add("track");
      this.wrapperElm.appendChild(this.trackElm);
      this.inputElm = this.createElement("input");
      this.inputElm.setAttribute("type", "checkbox");
      this.switchBaseElm.appendChild(this.inputElm);
      this.thumbElm = this.createElement("div");
      this.thumbElm.classList.add("thumb");
      this.switchBaseElm.appendChild(this.thumbElm);
      this.rippleElm = this.createElement("div");
      this.rippleElm.classList.add("ripple");
      this.switchBaseElm.appendChild(this.rippleElm);
      this.checked = this.getAttribute("checked", true) || false;
      this.setAttributeToProperty("checkedThumbColor");
      this.setAttributeToProperty("uncheckedThumbColor");
      this.setAttributeToProperty("checkedTrackColor");
      this.setAttributeToProperty("uncheckedTrackColor");
      this.setAttributeToProperty("checkedText");
      this.setAttributeToProperty("uncheckedText");
      this.setAttributeToProperty("checkedThumbText");
      this.setAttributeToProperty("uncheckedThumbText");
      super.init();
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Switch = __decorateClass([
  customElements2("i-switch", {
    icon: "toggle-on",
    group: GroupType.FIELDS,
    className: "Switch",
    props: {
      checkedThumbColor: { type: "string", default: "" },
      uncheckedThumbColor: { type: "string", default: "" },
      checkedThumbText: { type: "string", default: "" },
      uncheckedThumbText: { type: "string", default: "" },
      checkedTrackColor: { type: "string", default: "" },
      uncheckedTrackColor: { type: "string", default: "" },
      checkedText: { type: "string", default: "" },
      uncheckedText: { type: "string", default: "" },
      checked: { type: "boolean", default: false }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        checkedThumbColor: { type: "string", format: "color" },
        uncheckedThumbColor: { type: "string", format: "color" },
        checkedThumbText: { type: "string" },
        uncheckedThumbText: { type: "string" },
        checkedTrackColor: { type: "string", format: "color" },
        uncheckedTrackColor: { type: "string", format: "color" },
        checkedText: { type: "string" },
        uncheckedText: { type: "string" },
        checked: { type: "boolean", default: false }
      }
    }
  })
], Switch);

// packages/popover/src/style/popover.css.ts
var Theme34 = theme_exports.ThemeVars;
var getOverlayStyle2 = () => {
  return style({
    backgroundColor: "rgba(12, 18, 52, 0.7)",
    position: "fixed",
    left: 0,
    top: 0,
    width: "100%",
    height: "100%",
    opacity: 0,
    visibility: "hidden",
    zIndex: 1e3,
    transition: "visibility 0s linear .25s, opacity .25s",
    $nest: {
      "&.show": {
        opacity: "1",
        visibility: "visible",
        transition: "visibility 0s linear, opacity .25s"
      }
    }
  });
};
var getNoBackdropStyle2 = () => {
  return style({
    position: "inherit",
    top: 0,
    left: 0,
    opacity: 0,
    visibility: "hidden",
    transform: "scale(0.8)",
    transition: "visibility 0s linear .25s,opacity .25s 0s,transform .25s",
    zIndex: 1e3,
    maxWidth: "inherit",
    $nest: {
      ".popover": {
        margin: "0"
      },
      "&.show": {
        opacity: "1",
        visibility: "visible",
        transform: "scale(1)",
        transition: "visibility 0s linear 0s,opacity .25s 0s,transform .25s"
      }
    }
  });
};
var getAbsoluteWrapperStyle2 = (left, top) => {
  return style({
    left,
    top,
    width: "inherit",
    height: "inherit"
  });
};
var popoverMainContentStyle = style({
  fontFamily: "Helvetica",
  fontSize: "14px",
  padding: "10px 10px 5px 10px",
  backgroundColor: Theme34.background.modal,
  position: "relative",
  borderRadius: "2px",
  width: "inherit",
  maxWidth: "100%"
});
cssRule("i-popover", {
  position: "absolute",
  left: "0",
  top: "0"
});

// packages/popover/src/popover.ts
var Theme35 = theme_exports.ThemeVars;
var showEvent2 = new Event("show");
var Popover = class extends Container {
  constructor(parent, options) {
    super(parent, options, {
      placement: "center"
    });
    this._visible = false;
    this.boundHandlePopoverMouseDown = this.handlePopoverMouseDown.bind(this);
    this.boundHandlePopoverMouseUp = this.handlePopoverMouseUp.bind(this);
  }
  get visible() {
    return this._visible;
  }
  set visible(value) {
    if (value) {
      this._visible = true;
      this.style.display = "block";
      this.wrapperDiv.classList.add("show");
      this.dispatchEvent(showEvent2);
      document.addEventListener("mousedown", this.boundHandlePopoverMouseDown);
      document.addEventListener("mouseup", this.boundHandlePopoverMouseUp);
    } else {
      this._visible = false;
      this.style.display = "none";
      this.wrapperDiv.classList.remove("show");
      this.overlayDiv.classList.remove("show");
      this.onClose && this.onClose(this);
      document.removeEventListener("mousedown", this.boundHandlePopoverMouseDown);
      document.removeEventListener("mouseup", this.boundHandlePopoverMouseUp);
    }
  }
  get onOpen() {
    return this._onOpen;
  }
  set onOpen(callback) {
    this._onOpen = callback;
  }
  get placement() {
    return this._placement;
  }
  set placement(value) {
    this._placement = value;
  }
  get item() {
    return this.popoverDiv.children[0];
  }
  set item(value) {
    if (value instanceof Control) {
      this.popoverDiv.innerHTML = "";
      value && this.popoverDiv.appendChild(value);
    }
  }
  get position() {
    return this._wrapperPositionAt;
  }
  set position(value) {
    this._wrapperPositionAt = value;
  }
  _handleClick(event) {
    return true;
  }
  positionPopoverRelativeToParent(placement) {
    let parent = this._parent || this.linkTo || this.parentElement || document.body;
    let coords = this.calculatePopoverWrapperCoordinates(parent, placement);
    const wrapperPositionStyle = getAbsoluteWrapperStyle2(coords.left + "px", coords.top + "px");
    this.setTargetStyle(this.wrapperDiv, "wrapperPosition", wrapperPositionStyle);
  }
  calculatePopoverWrapperCoordinates(parent, placement) {
    var _a;
    const parentCoords = parent.getBoundingClientRect();
    let left = 0;
    let top = 0;
    let max;
    const isOutside = parent.style.position === "absolute" && !((_a = this.parent) == null ? void 0 : _a.contains(this));
    switch (placement) {
      case "center":
        left = (parentCoords.width - this.wrapperDiv.offsetWidth) / 2;
        top = (parentCoords.height - this.popoverDiv.offsetHeight) / 2;
        break;
      case "top":
      case "topLeft":
      case "topRight":
        if (parentCoords.top - this.popoverDiv.offsetHeight >= 0) {
          top = -this.popoverDiv.offsetHeight;
        } else {
          if (window.innerHeight < this.popoverDiv.offsetHeight + parentCoords.bottom) {
            max = window.innerHeight - this.popoverDiv.offsetHeight - parentCoords.y;
            top = (parentCoords.height - this.popoverDiv.offsetHeight) / 2;
            top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
          } else {
            top = parentCoords.height;
          }
        }
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        if (window.innerHeight < this.popoverDiv.offsetHeight + parentCoords.bottom) {
          if (parentCoords.y - this.popoverDiv.offsetHeight < 0) {
            max = window.innerHeight - this.popoverDiv.offsetHeight - parentCoords.y;
            top = (parentCoords.height - this.popoverDiv.offsetHeight) / 2;
            top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
          } else {
            top = -this.popoverDiv.offsetHeight;
          }
        } else {
          top = isOutside ? parentCoords.top - this.popoverDiv.offsetHeight : parentCoords.height;
        }
        break;
      case "rightTop":
        top = isOutside ? parentCoords.top - this.popoverDiv.offsetHeight : 0;
        left = isOutside ? parentCoords.left + parentCoords.width : parentCoords.width;
        if (left + this.popoverDiv.offsetWidth > document.documentElement.clientWidth) {
          left = document.documentElement.clientWidth - this.popoverDiv.offsetWidth;
        }
        if (top + this.popoverDiv.offsetHeight > document.documentElement.clientHeight) {
          top = document.documentElement.clientHeight - this.popoverDiv.offsetHeight;
        }
        break;
      case "left":
        max = window.innerHeight - this.popoverDiv.offsetHeight - parentCoords.y;
        if (isOutside) {
          top = parentCoords.top + parentCoords.height / 2 - this.popoverDiv.offsetHeight / 2;
          left = Math.max(parentCoords.left - this.popoverDiv.offsetWidth, 0);
        } else {
          top = (parentCoords.height - this.popoverDiv.offsetHeight) / 2;
          top = top < -parentCoords.y ? -parentCoords.y : top > max ? max : top;
          left = -this.wrapperDiv.offsetWidth - 8;
        }
        break;
    }
    if (placement === "topRight" || placement === "bottomRight") {
      if (parentCoords.right - this.wrapperDiv.offsetWidth >= 0) {
        left = parentCoords.width - this.wrapperDiv.offsetWidth;
      } else {
        left = -parentCoords.left;
      }
    } else if (["top", "topLeft", "bottom", "bottomLeft"].includes(placement)) {
      if (window.innerWidth >= parentCoords.left + this.wrapperDiv.offsetWidth) {
        left = 0;
      } else {
        if (parentCoords.right - this.wrapperDiv.offsetWidth >= 0) {
          left = Math.min(parentCoords.width - this.wrapperDiv.offsetWidth, window.innerWidth - parentCoords.left - this.wrapperDiv.offsetWidth);
        } else {
          left = Math.max(parentCoords.width - this.wrapperDiv.offsetWidth, window.innerWidth - parentCoords.left - this.wrapperDiv.offsetWidth);
        }
      }
    }
    return { top, left };
  }
  _handleOnShow(event) {
    if (this.placement && this.enabled)
      this.positionPopoverRelativeToParent(this.placement);
    if (this.enabled && this._onOpen) {
      event.preventDefault();
      this._onOpen(this);
    }
  }
  handlePopoverMouseDown(event) {
    this.insideClick = true;
    this.setInsideClick(event);
  }
  handlePopoverMouseUp(event) {
    if (!this.insideClick)
      this.visible = false;
  }
  setInsideClick(event) {
    const target = event.target;
    this.insideClick = this.popoverDiv.contains(target);
  }
  setPropertyValue(name, value) {
    if (!isNaN(Number(value)))
      this.popoverDiv.style[name] = value + "px";
    else
      this.popoverDiv.style[name] = value;
    this.style[name] = "";
  }
  refresh() {
    super.refresh(true);
    if (this.visible && this.placement) {
      this.positionPopoverRelativeToParent(this.placement);
    }
  }
  get background() {
    return this._background;
  }
  set background(value) {
    if (!this._background) {
      this._background = new Background(this.popoverDiv, value);
    } else {
      this._background.setBackgroundStyle(value);
    }
  }
  get width() {
    return !isNaN(this._width) ? this._width : this.offsetWidth;
  }
  set width(value) {
    this._width = value;
    this.setPropertyValue("width", value);
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    this.setPropertyValue("height", value);
  }
  get border() {
    return this._border;
  }
  set border(value) {
    this._border = new Border(this.wrapperDiv, value);
  }
  get padding() {
    return this._padding;
  }
  set padding(value) {
    if (!this._padding)
      this._padding = new SpaceValue(this.popoverDiv, value, "padding");
    else
      this._padding.update(value);
  }
  removeTargetStyle(target, propertyName) {
    let style2 = this.propertyClassMap[propertyName];
    if (style2)
      target.classList.remove(style2);
  }
  setTargetStyle(target, propertyName, value) {
    this.removeTargetStyle(target, propertyName);
    if (value) {
      this.propertyClassMap[propertyName] = value;
      target.classList.add(value);
    }
  }
  init() {
    var _a;
    if (!this.wrapperDiv) {
      if ((_a = this.options) == null ? void 0 : _a.onClose)
        this.onClose = this.options.onClose;
      this.placement = this.getAttribute("placement", true);
      this.wrapperDiv = this.createElement("div", this);
      this.popoverDiv = this.createElement("div", this.wrapperDiv);
      this.bodyDiv = this.createElement("div", this.popoverDiv);
      while (this.childNodes.length > 1) {
        this.bodyDiv.appendChild(this.childNodes[0]);
      }
      this.overlayDiv = this.createElement("div", this);
      this.prepend(this.overlayDiv);
      const overlayStyle = getOverlayStyle2();
      this.overlayDiv.classList.add(overlayStyle);
      this.popoverDiv.classList.add(popoverMainContentStyle);
      this.popoverDiv.classList.add("popover");
      this.addEventListener("show", this._handleOnShow.bind(this));
      window.addEventListener("keydown", (event) => {
        if (!this.visible)
          return;
        if (event.key === "Escape") {
          this.visible = false;
        }
      });
      const itemAttr = this.getAttribute("item", true);
      if (itemAttr)
        this.item = itemAttr;
      super.init();
      const maxWidth = this.getAttribute("maxWidth", true);
      if (maxWidth !== void 0)
        this.setPropertyValue("maxWidth", this.maxWidth);
      const minHeight = this.getAttribute("minHeight", true);
      if (minHeight !== void 0)
        this.setPropertyValue("minHeight", this.minHeight);
      const minWidth = this.getAttribute("minWidth", true);
      if (minWidth !== void 0)
        this.setPropertyValue("minWidth", this.minWidth);
      const height = this.getAttribute("height", true);
      if (height !== void 0)
        this.setPropertyValue("height", this.height);
      const maxHeight = this.getAttribute("maxHeight", true);
      if (maxHeight !== void 0)
        this.setPropertyValue("maxHeight", this.maxHeight);
      let border = this.getAttribute("border", true);
      if (border) {
        this._border = new Border(this.wrapperDiv, border);
        this.style.border = "none";
      }
      let padding = this.getAttribute("padding", true);
      if (padding) {
        this._padding = new SpaceValue(this.popoverDiv, padding, "padding");
      }
      const noBackdropStyle = getNoBackdropStyle2();
      this.setTargetStyle(this.wrapperDiv, "showBackdrop", noBackdropStyle);
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Popover = __decorateClass([
  customElements2("i-popover")
], Popover);

// packages/chart/src/chart.ts
var Chart = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._theme = "light";
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
    this.drawChart();
  }
  get theme() {
    return this._theme;
  }
  set theme(value) {
    this._theme = value;
    this._chartIns = null;
    if (this.hasChildNodes()) {
      this.removeChild(this._chartDom);
    }
    this.initChartDom();
    this.drawChart();
  }
  get dataObj() {
    if (typeof this.data === "object")
      return this.data;
    try {
      return JSON.parse(JSON.stringify(this.data));
    } catch (e) {
      return null;
    }
  }
  showLoading() {
    this._chartIns && this._chartIns.showLoading();
  }
  drawChart() {
    if (this._chartIns) {
      this.updateChartOptions();
      return;
    }
    if (this._echart) {
      this._drawChart();
      return;
    }
    RequireJS.require([`${LibPath}lib/echarts/echarts.min.js`], (echart) => {
      this._echart = echart;
      this._drawChart();
    });
  }
  _drawChart() {
    if (this._chartDom) {
      this._chartIns = this._echart.init(this._chartDom, this.theme);
      this.updateChartOptions();
    }
  }
  updateChartOptions() {
    this._chartIns.hideLoading();
    this.dataObj && this._chartIns.setOption(this.dataObj);
  }
  resize() {
    if (this.dataObj && this._chartIns) {
      this._chartIns.resize();
    }
  }
  initChartDom() {
    const captionDiv = this.createElement("div", this);
    captionDiv.id = `main-${Date.now()}`;
    captionDiv.style.display = "inline-block";
    captionDiv.style.height = "100%";
    captionDiv.style.width = "100%";
    this._chartDom = captionDiv;
  }
  init() {
    super.init();
    this.style.display = "inline-block";
    this.initChartDom();
    this._theme = this.getAttribute("theme", true, "light");
    this.data = this.getAttribute("data", true);
  }
};

// packages/chart/src/lineChart.ts
var LineChart = class extends Chart {
  constructor(parent, options) {
    super(parent, options);
  }
  init() {
    super.init();
  }
};
LineChart = __decorateClass([
  customElements2("i-line-chart")
], LineChart);

// packages/chart/src/barChart.ts
var BarChart = class extends Chart {
  constructor(parent, options) {
    super(parent, options);
  }
  init() {
    super.init();
  }
};
BarChart = __decorateClass([
  customElements2("i-bar-chart")
], BarChart);

// packages/chart/src/barStackChart.ts
var BarStackChart = class extends Chart {
  constructor(parent, options) {
    super(parent, options);
  }
  init() {
    super.init();
  }
};
BarStackChart = __decorateClass([
  customElements2("i-bar-stack-chart")
], BarStackChart);

// packages/chart/src/pieChart.ts
var PieChart = class extends Chart {
  constructor(parent, options) {
    super(parent, options);
  }
  init() {
    super.init();
  }
};
PieChart = __decorateClass([
  customElements2("i-pie-chart")
], PieChart);

// packages/chart/src/scatterChart.ts
var ScatterChart = class extends Chart {
  constructor(parent, options) {
    super(parent, options);
  }
  init() {
    super.init();
  }
};
ScatterChart = __decorateClass([
  customElements2("i-scatter-chart")
], ScatterChart);

// packages/chart/src/scatterLineChart.ts
var ScatterLineChart = class extends Chart {
  constructor(parent, options) {
    super(parent, options);
  }
  init() {
    super.init();
  }
};
ScatterLineChart = __decorateClass([
  customElements2("i-scatter-line-chart")
], ScatterLineChart);

// packages/iframe/src/style/iframe.css.ts
cssRule("i-iframe", {
  position: "relative",
  $nest: {
    ".overlay": {
      position: "absolute",
      top: "0px",
      left: "0px",
      width: "100%",
      height: "calc(100% - 3rem)",
      zIndex: 9999,
      display: "none"
    },
    "@media screen and (max-width: 767px)": {
      $nest: {
        ".overlay": {
          display: "block"
        }
      }
    }
  }
});

// packages/iframe/src/iframe.ts
var Iframe = class extends Control {
  constructor(parent, options) {
    super(parent, options, {});
    window.addEventListener("mousedown", () => {
      if (this.iframeElm)
        this.iframeElm.style.pointerEvents = "none";
    });
    window.addEventListener("mouseup", () => {
      if (this.iframeElm)
        this.iframeElm.style.pointerEvents = "auto";
    });
  }
  reload() {
    let iframe = this.iframeElm;
    return new Promise((resolve) => {
      iframe.src = iframe.src;
      iframe.onload = function() {
        resolve();
        iframe.onload = null;
      };
    });
  }
  postMessage(msg) {
    if (this.iframeElm && this.iframeElm.contentWindow) {
      this.iframeElm.contentWindow.postMessage(msg, "*");
    }
    ;
  }
  get url() {
    return this._url;
  }
  set url(value) {
    this._url = value;
    if (!this.iframeElm)
      this.iframeElm = this.createElement("iframe", this);
    if (this.allowFullscreen)
      this.iframeElm.allowFullscreen = true;
    if (value !== void 0) {
      this.iframeElm.src = value || "";
      this.iframeElm.width = "100%";
      this.iframeElm.height = "100%";
      this.iframeElm.setAttribute("frameBorder", "0");
    }
  }
  set designMode(value) {
    this._designMode = value;
    if (this.overlayElm) {
      this.overlayElm.style.height = value ? "100%" : "0px";
      this.overlayElm.style.display = value ? "block" : "none";
    }
  }
  init() {
    super.init();
    this.overlayElm = this.createElement("div", this);
    this.overlayElm.classList.add("overlay");
    this.overlayElm.style.height = this._designMode ? "100%" : "0px";
    this.overlayElm.style.display = this._designMode ? "block" : "none";
    this.allowFullscreen = this.getAttribute("allowFullscreen", true);
    const url = this.getAttribute("url", true);
    if (url !== void 0)
      this.url = url;
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Iframe = __decorateClass([
  customElements2("i-iframe", {
    icon: "border-all",
    group: GroupType.BASIC,
    className: "Iframe",
    props: {
      url: { type: "string", default: "" },
      allowFullscreen: { type: "boolean", default: false }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        url: {
          type: "string"
        },
        allowFullscreen: {
          type: "boolean",
          default: false
        }
      }
    }
  })
], Iframe);

// packages/pagination/src/style/pagination.css.ts
var Theme36 = theme_exports.ThemeVars;
cssRule("i-pagination", {
  display: "block",
  width: "100%",
  maxWidth: "100%",
  verticalAlign: "baseline",
  fontFamily: Theme36.typography.fontFamily,
  fontSize: Theme36.typography.fontSize,
  lineHeight: "25px",
  color: Theme36.text.primary,
  "$nest": {
    ".pagination": {
      display: "inline-flex",
      flexWrap: "wrap",
      justifyContent: "center"
    },
    ".pagination a": {
      color: Theme36.text.primary,
      float: "left",
      padding: "4px 8px",
      textAlign: "center",
      textDecoration: "none",
      transition: "background-color .3s",
      border: "1px solid #ddd",
      minWidth: 36
    },
    ".pagination a.active": {
      backgroundColor: "#4CAF50",
      color: "white",
      border: "1px solid #4CAF50",
      cursor: "default"
    },
    ".pagination a.disabled": {
      color: Theme36.text.disabled,
      pointerEvents: "none"
    }
  }
});

// packages/pagination/src/pagination.ts
var pagerCount = 7;
var pagerCountMobile = 5;
var defaultCurrentPage = 1;
var pageSize = 10;
var defaultTotalPage = 0;
var Pagination = class extends Control {
  constructor(parent, options) {
    super(parent, options, { pageSize });
    this._showPrevMore = false;
    this._showNextMore = false;
    this.pageItems = [];
    this.pagerCount = pagerCount;
  }
  get totalPages() {
    return this._totalPages;
  }
  set totalPages(value) {
    if (this._totalPages === value)
      return;
    this._totalPages = value;
    this.onDisablePrevNext();
    this.renderPageItem(value);
  }
  get currentPage() {
    return this._curPage;
  }
  set currentPage(value) {
    const oldData = this._curPage;
    this._curPage = value || defaultCurrentPage;
    const index = value - 1;
    this.pageItems[index] && this.onActiveItem(this.pageItems[index]);
    if (typeof this.onPageChanged === "function" && oldData !== this._curPage)
      this.onPageChanged(this, oldData);
  }
  get pageSize() {
    return this._pageSize || pageSize;
  }
  set pageSize(value) {
    this._pageSize = value;
  }
  onActiveItem(item) {
    if (this.activeItem) {
      this.activeItem.classList.remove("active");
    }
    if (item) {
      item.classList.add("active");
      this.activeItem = item;
    }
  }
  onDisablePrevNext() {
    if (this._prevElm)
      this.currentPage <= 1 ? this._prevElm.classList.add("disabled") : this._prevElm.classList.remove("disabled");
    if (this._nextElm)
      this.currentPage >= this.totalPages ? this._nextElm.classList.add("disabled") : this._nextElm.classList.remove("disabled");
  }
  _handleOnClickIndex(value, event) {
    if (!this.enabled)
      return;
    this.currentPage = value;
    this.onActiveItem(event.target);
    this.onDisablePrevNext();
  }
  _handleOnClickMore(value, event) {
    let _curPage = this.currentPage + value * (this.pagerCount - 2);
    if (_curPage > this.totalPages) {
      _curPage = this.totalPages;
    } else if (_curPage <= 0) {
      _curPage = 1;
    }
    this.currentPage = _curPage;
    this.onDisablePrevNext();
    this.renderPageItem(this.totalPages);
  }
  _handleOnNext(event) {
    if (!this.enabled || this.currentPage >= this.totalPages)
      return;
    const nextPage = Number(this._curPage) <= 0 ? 1 : Number(this._curPage) + 1;
    this.currentPage = nextPage;
    this.renderPageItem(this.totalPages);
    this.onDisablePrevNext();
  }
  _handleOnPrev(event) {
    if (!this.enabled || this.currentPage <= 1)
      return;
    const prevPage = Number(this._curPage) - 1;
    this.currentPage = prevPage;
    this.renderPageItem(this.totalPages);
    this.onDisablePrevNext();
  }
  onMouseenter(direction, event) {
    if (!this.enabled)
      return;
    const target = event.target;
    target.innerHTML = direction === -1 ? "&laquo;" : "&raquo;";
  }
  renderEllipsis(step) {
    let item = this.createElement("a", this._paginationDiv);
    item.id = step === -1 ? "prevMoreElm" : "nextMoreElm";
    item.setAttribute("href", "#");
    item.innerHTML = "...";
    item.classList.add("paginate_button");
    item.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (this._designMode)
        return;
      this._handleOnClickMore(step, e);
    });
    item.addEventListener("mouseenter", (e) => {
      e.preventDefault();
      if (this._designMode)
        return;
      this.onMouseenter(step, e);
    });
    item.addEventListener("mouseout", (e) => {
      e.preventDefault();
      if (this._designMode)
        return;
      item.innerHTML = "...";
    });
  }
  renderPage(index) {
    let item = this.createElement("a", this._paginationDiv);
    this.pageItems.push(item);
    item.setAttribute("href", "#");
    item.innerHTML = `${index}`;
    item.classList.add("paginate_button");
    item.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (this._designMode)
        return;
      this._handleOnClickIndex(index, e);
    });
    if (index === this.currentPage)
      this.onActiveItem(item);
  }
  updatePagers() {
    const halfPagerCount = (this.pagerCount - 1) / 2;
    const currentPage = Number(this.currentPage);
    const pageCount = Number(this.totalPages);
    let showPrevMore = false;
    let showNextMore = false;
    if (pageCount > this.pagerCount) {
      if (currentPage > this.pagerCount - halfPagerCount) {
        showPrevMore = true;
      }
      if (currentPage < pageCount - halfPagerCount) {
        showNextMore = true;
      }
    }
    const array = [];
    if (showPrevMore && !showNextMore) {
      const startPage = pageCount - (this.pagerCount - 2);
      for (let i = startPage; i < pageCount; i++) {
        array.push(i);
      }
    } else if (!showPrevMore && showNextMore) {
      for (let i = 2; i < this.pagerCount; i++) {
        array.push(i);
      }
    } else if (showPrevMore && showNextMore) {
      const offset = Math.floor(this.pagerCount / 2) - 1;
      for (let i = currentPage - offset; i <= currentPage + offset; i++) {
        array.push(i);
      }
    } else {
      for (let i = 2; i < pageCount; i++) {
        array.push(i);
      }
    }
    this.pagers = array;
    this._showPrevMore = showPrevMore;
    this._showNextMore = showNextMore;
  }
  renderPageItem(size) {
    if (!this._paginationDiv)
      return;
    this.visible = size > 0;
    this._paginationDiv.innerHTML = "";
    if (this._prevElm) {
      this._paginationDiv.appendChild(this._prevElm);
    }
    this.pageItems = [];
    if (size > 0) {
      if (size > this.pagerCount) {
        this.updatePagers();
        this.renderPage(1);
        this._showPrevMore && this.renderEllipsis(-1);
        for (let i = 0; i < this.pagers.length; i++) {
          this.renderPage(this.pagers[i]);
        }
        this._showNextMore && this.renderEllipsis(1);
        this.renderPage(size);
      } else {
        for (let i = 1; i <= size; i++) {
          this.renderPage(i);
        }
      }
    } else if (size < 0) {
      const _s = this.pageItems.length + size;
      for (let i = this.pageItems.length - 1; i >= _s; i--) {
        this._paginationDiv.removeChild(this.pageItems[i]);
        this.pageItems.pop();
      }
    }
    if (this._nextElm) {
      this._paginationDiv.append(this._nextElm);
    }
  }
  init() {
    this.pagerCount = window.innerWidth > 767 ? pagerCount : pagerCountMobile;
    if (!this._paginationDiv) {
      this.pageItems = [];
      this._paginationDiv = this.createElement("div", this);
      this._paginationDiv.classList.add("pagination", "pagination-main");
      this._prevElm = this.createElement("a", this._paginationDiv);
      this._prevElm.setAttribute("href", "#");
      this._prevElm.innerHTML = "&laquo;";
      this._prevElm.classList.add("paginate_button", "previous");
      this._prevElm.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this._designMode)
          return;
        this._handleOnPrev(e);
      });
      this.currentPage = +this.getAttribute("currentPage", true, defaultCurrentPage);
      this.totalPages = +this.getAttribute("totalPages", true, defaultTotalPage);
      this.pageSize = +this.getAttribute("pageSize", true, pageSize);
      this._nextElm = this.createElement("a", this._paginationDiv);
      this._nextElm.setAttribute("href", "#");
      this._nextElm.innerHTML = "&raquo;";
      this._nextElm.classList.add("paginate_button", "next");
      this._nextElm.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this._designMode)
          return;
        this._handleOnNext(e);
      });
      this.onDisablePrevNext();
    }
    super.init();
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Pagination = __decorateClass([
  customElements2("i-pagination", {
    icon: "ellipsis-h",
    group: GroupType.BASIC,
    className: "Pagination",
    props: {
      totalPages: { type: "number", default: defaultTotalPage },
      currentPage: { type: "number", default: defaultCurrentPage },
      pageSize: { type: "number", default: pageSize }
    },
    events: {
      onPageChanged: [
        { name: "target", type: "Pagination", isControl: true },
        { name: "lastActivePage", type: "number" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        totalPages: {
          type: "number",
          default: defaultTotalPage
        },
        currentPage: {
          type: "number",
          default: defaultCurrentPage
        },
        pageSize: {
          type: "number",
          default: pageSize
        }
      }
    }
  })
], Pagination);

// packages/table/src/style/table.css.ts
var Theme37 = theme_exports.ThemeVars;
var tableStyle = style({
  fontFamily: Theme37.typography.fontFamily,
  fontSize: Theme37.typography.fontSize,
  color: Theme37.text.primary,
  display: "block",
  $nest: {
    "> .i-table-container": {
      overflowX: "auto"
    },
    ".i-table-cell": {
      overflowWrap: "break-word",
      position: "relative",
      textOverflow: "ellipsis",
      whiteSpace: "normal"
    },
    "> .i-table-container > table": {
      width: "100%",
      textAlign: "left",
      borderCollapse: "separate",
      borderSpacing: 0
    },
    ".i-table-header>tr>th": {
      fontWeight: 600,
      transition: "background .3s ease",
      borderBottom: `1px solid ${Theme37.divider}`
    },
    ".i-table-body>tr>td": {
      borderBottom: `1px solid ${Theme37.divider}`,
      transition: "background .3s ease"
    },
    "tr:hover td": {
      background: Theme37.action.hoverBackground,
      color: Theme37.action.hover
    },
    "&.i-table--bordered": {
      $nest: {
        "> .i-table-container > table": {
          borderTop: `1px solid ${Theme37.divider}`,
          borderLeft: `1px solid ${Theme37.divider}`,
          borderRadius: "2px"
        },
        "> .i-table-container > table .i-table-cell": {
          borderRight: `1px solid ${Theme37.divider} !important`,
          borderBottom: `1px solid ${Theme37.divider}`
        }
      }
    },
    ".i-table-header i-table-column": {
      display: "inline-flex",
      gap: 10,
      alignItems: "center"
    },
    ".i-table-sort": {
      position: "relative",
      display: "inline-flex",
      flexDirection: "column",
      alignItems: "center",
      width: 20,
      $nest: {
        ".sort-icon": {
          display: "block",
          cursor: "pointer"
        },
        ".sort-icon.sort-icon--active > svg": {
          fill: Theme37.colors.primary.main
        },
        ".sort-icon.sort-icon--desc": {
          marginTop: -5
        }
      }
    },
    ".i-table-pagi": {
      display: "flex",
      width: "100%",
      $nest: {
        "&.is--left": {
          justifyContent: "flex-start"
        },
        "&.is--right": {
          justifyContent: "flex-end"
        },
        "&.is--center": {
          justifyContent: "center"
        }
      }
    },
    ".i-table-cell--expand": {
      cursor: "pointer",
      $nest: {
        "i-icon": {
          display: "inline-block"
        },
        "i-icon svg": {
          fill: Theme37.text.primary
        }
      }
    },
    ".i-table-row--child > td": {
      borderRight: `1px solid ${Theme37.divider}`
    },
    "@media (max-width: 767px)": {
      $nest: {
        ".hidden-mobile": {
          display: "none !important"
        }
      }
    },
    "@media (min-width: 768px)": {
      $nest: {
        ".hidden-desktop": {
          display: "none !important"
        }
      }
    }
  }
});
var getCustomStylesClass = (styles) => {
  var _a;
  let styleObj = {};
  const { padding, background, font, cursor, height } = styles || {};
  const { top = "1rem", right = "1rem", bottom = "1rem", left = "1rem" } = padding || {};
  styleObj.padding = `${getSpacingValue(top)} ${getSpacingValue(right)} ${getSpacingValue(bottom)} ${getSpacingValue(left)}`;
  if (font) {
    const { color = "", size = "", name = "", style: style2 = "", transform = "none", bold, weight = "" } = font;
    styleObj.color = color;
    styleObj.fontSize = size;
    styleObj.fontFamily = name;
    styleObj.fontStyle = style2;
    styleObj.textTransform = transform;
    styleObj.fontWeight = bold ? "bold" : `${weight}`;
  }
  if (background)
    styleObj.background = ((_a = getBackground(background)) == null ? void 0 : _a.background) || "";
  if (cursor)
    styleObj.cursor = cursor;
  if (height !== void 0 && height !== null) {
    styleObj.height = getSpacingValue(height);
  }
  return style(styleObj);
};
var getTableMediaQueriesStyleClass = (columns, mediaQueries) => {
  let styleObj = getControlMediaQueriesStyle(mediaQueries);
  for (let mediaQuery of mediaQueries) {
    let mediaQueryRule = getMediaQueryRule(mediaQuery);
    if (mediaQueryRule) {
      const ruleObj = styleObj["$nest"][mediaQueryRule];
      styleObj["$nest"][mediaQueryRule] = {
        ...ruleObj,
        $nest: {}
      };
      const {
        fieldNames,
        expandable
      } = mediaQuery.properties || {};
      if (fieldNames) {
        for (let column of columns) {
          const fieldName = column.fieldName || "action";
          if (!fieldNames.includes(column.fieldName)) {
            styleObj["$nest"][mediaQueryRule]["$nest"][`[data-fieldname="${fieldName}"]`] = {
              display: "none"
            };
          } else if (column.visible === false) {
            styleObj["$nest"][mediaQueryRule]["$nest"][`[data-fieldname="${fieldName}"]`] = {
              display: "table-cell !important"
            };
            styleObj["$nest"][mediaQueryRule]["$nest"][`[data-fieldname="${fieldName}"]`] = {
              display: "table-cell !important",
              $nest: {
                "> i-table-column": {
                  display: "table-cell !important"
                }
              }
            };
          }
        }
      }
      if (expandable) {
        styleObj["$nest"][mediaQueryRule]["$nest"][".i-table-row--child"] = {
          display: expandable.rowExpandable ? "none" : "none !important"
        };
      }
    }
  }
  return style(styleObj);
};

// packages/table/src/tableColumn.ts
var Theme38 = theme_exports.ThemeVars;
var TableColumn = class extends Control {
  constructor(parent, options) {
    super(parent, options);
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
    this.columnElm.innerHTML = `${value}`;
  }
  get rowData() {
    return this._rowData;
  }
  set rowData(value) {
    this._rowData = value;
  }
  get sortOrder() {
    return this._sortOrder;
  }
  set sortOrder(value) {
    this._sortOrder = value;
    if (value === "asc") {
      this.ascElm && this.ascElm.classList.add("sort-icon--active");
      this.descElm && this.descElm.classList.remove("sort-icon--active");
    } else if (value === "desc") {
      this.ascElm && this.ascElm.classList.remove("sort-icon--active");
      this.descElm && this.descElm.classList.add("sort-icon--active");
    } else {
      this.ascElm && this.ascElm.classList.remove("sort-icon--active");
      this.descElm && this.descElm.classList.remove("sort-icon--active");
    }
    if (value && this.onSortChange)
      this.onSortChange(this, this.fieldName, value);
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value) {
    this._textAlign = value || "left";
    this.style.textAlign = value;
  }
  renderSort() {
    if (!this.sortable) {
      this.sortElm && (this.sortElm.style.display = "none");
      return;
    }
    if (!this.sortElm) {
      this.sortElm = this.createElement("div", this);
      this.sortElm.classList.add("i-table-sort");
      this.ascElm = new Icon(this, {
        name: "caret-up",
        width: 14,
        height: 14,
        fill: Theme38.text.primary
      });
      this.ascElm.classList.add("sort-icon", "sort-icon--asc");
      this.ascElm.onClick = () => this.sortOrder = this.sortOrder === "asc" ? "none" : "asc";
      this.descElm = new Icon(this, {
        name: "caret-down",
        width: 14,
        height: 14,
        fill: Theme38.text.primary
      });
      this.descElm.classList.add("sort-icon", "sort-icon--desc");
      this.descElm.onClick = () => this.sortOrder = this.sortOrder === "desc" ? "none" : "desc";
      this.sortElm.appendChild(this.ascElm);
      this.sortElm.appendChild(this.descElm);
    }
    this.sortElm.style.display = "block";
  }
  async appendNode(params) {
    if (!params)
      return;
    const { tdElm, rowData, rowIndex, cell } = params;
    this.rowData = rowData;
    if (!this.columnElm || !this.onRenderCell)
      return;
    let node = await this.onRenderCell(this, this.data, rowData, rowIndex, cell);
    if (!node)
      return;
    if (cell.rowSpan === 0 || cell.columnSpan === 0) {
      this.remove();
      tdElm.remove();
      return;
    }
    cell.columnSpan > 1 && tdElm.setAttribute("colspan", cell.columnSpan + "");
    cell.rowSpan > 1 && tdElm.setAttribute("rowspan", cell.rowSpan + "");
    if (typeof node === "string" || typeof node === "number") {
      this.columnElm.innerHTML = node + "";
    } else {
      this.columnElm.innerHTML = "";
      this.columnElm.appendChild(node);
    }
  }
  init() {
    if (!this.columnElm) {
      this.caption = this.options.title;
      this.fieldName = this.options.fieldName;
      if (this.options.key)
        this.key = this.options.key;
      if (this.options.onRenderCell)
        this.onRenderCell = this.options.onRenderCell.bind(this);
      if (this.options.textAlign)
        this.textAlign = this.options.textAlign;
      this.setAttributeToProperty("grid");
      this.setAttributeToProperty("display");
      this.isHeader = this.options.header || false;
      this.visible = typeof this.options.visible === "boolean" ? this.options.visible : true;
      this.columnElm = this.createElement("div", this);
      this.data = this.getAttribute("data", true);
      if (this.isHeader) {
        this.columnElm.innerHTML = this.caption;
        this.sortable = this.getAttribute("sortable", true, false);
        if (this.options.onSortChange)
          this.onSortChange = this.options.onSortChange;
        if (this.options.sorter)
          this.sorter = this.options.sorter;
        this.renderSort();
        const sortOrder = this.getAttribute("sortOrder", true);
        if (sortOrder)
          this.sortOrder = sortOrder;
      }
    }
  }
};
TableColumn = __decorateClass([
  customElements2("i-table-column")
], TableColumn);

// packages/table/src/utils.ts
var paginate = (array, pageSize2, pageNumber) => {
  return array.slice((pageNumber - 1) * pageSize2, pageNumber * pageSize2);
};
var getSorter = (columns, key2) => {
  const findedColumn = columns.find((column) => column.fieldName === key2);
  return findedColumn ? findedColumn.sorter : null;
};
var orderBy = (list, sortConfig, columns) => {
  if (!sortConfig.length)
    return list;
  const sortFn = (a, b) => {
    let sorterCond;
    for (const config of sortConfig) {
      const { key: key2, direction } = config;
      const sortDirection = direction === "asc" ? 1 : -1;
      const sorter = getSorter(columns, key2);
      const value = sorter ? sorter(a, b) * sortDirection : (a[key2] > b[key2] ? 1 : a[key2] < b[key2] ? -1 : 0) * sortDirection;
      sorterCond = sorterCond || value;
    }
    return sorterCond || 0;
  };
  return list.sort((a, b) => sortFn(a, b));
};

// packages/table/src/tableRow.ts
var TableRow = class {
  constructor(cells) {
    this.cells = cells;
  }
  get cells() {
    return this._cells;
  }
  set cells(value) {
    this._cells = value;
  }
};

// packages/table/src/tableCell.ts
var TableCell = class {
  constructor(options) {
    this.rowSpan = options.rowSpan;
    this.columnSpan = options.columnSpan;
    this.value = options.value;
  }
  get rowSpan() {
    return this._rowSpan;
  }
  set rowSpan(value) {
    this._rowSpan = value;
  }
  get columnSpan() {
    return this._columnSpan;
  }
  set columnSpan(value) {
    this._columnSpan = value;
  }
  get value() {
    return this._value;
  }
  set value(data) {
    this._value = data;
  }
};

// packages/table/src/table.ts
var Table = class extends Control {
  constructor(parent, options) {
    super(parent, options, {
      heading: true
    });
    this._rows = [];
    this.firstLoad = true;
    this._sortConfig = {};
    this._bodyStyle = "";
    this._headingStyle = "";
  }
  get data() {
    return this._data;
  }
  set data(value) {
    this._data = value;
    this.filteredData = value;
    if (this.pagination)
      this.pagination.totalPages = Math.ceil(value.length / this.pagination.pageSize);
    this.renderBody && this.renderBody();
  }
  get filteredData() {
    return this.sortFn(this._filteredData);
  }
  set filteredData(value) {
    this._filteredData = value;
  }
  get hasData() {
    return this.filteredData && this.filteredData.length;
  }
  get sortConfig() {
    if (!this._sortConfig || !Object.keys(this._sortConfig).length)
      return [];
    const list = [];
    for (const col of this.columns) {
      const direction = this._sortConfig[col.fieldName];
      if (direction && direction !== "none") {
        list.push({ key: col.fieldName, direction });
      }
    }
    return list;
  }
  sortFn(list) {
    if (!list)
      return [];
    if (this.sortConfig.length) {
      return orderBy([...list], this.sortConfig, this.columns);
    }
    return list;
  }
  get columns() {
    return this._columns || [];
  }
  set columns(value) {
    this._columns = value;
    this._heading && this.renderHeader();
    !this.firstLoad && this.renderBody && this.renderBody();
  }
  get rows() {
    return this._rows;
  }
  get pagination() {
    return this._pagination;
  }
  set pagination(value) {
    if (typeof value === "string") {
      const elm = document.querySelector(`#${value}`);
      if (elm instanceof Pagination)
        this._pagination = elm;
    } else if (value) {
      this._pagination = value;
      this.pagingElm.innerHTML = "";
      this.pagingElm.appendChild(this.pagination);
    }
    if (this._pagination) {
      this.pagingElm.style.display = "flex";
      if (this.data)
        this._pagination.totalPages = Math.ceil(this.data.length / this._pagination.pageSize);
      this._pagination.onPageChanged = this.onPageChanged.bind(this);
      this.renderBody();
    } else {
      this.pagingElm.style.display = "none";
    }
  }
  get expandable() {
    return this._expandable;
  }
  set expandable(value) {
    this._expandable = value;
  }
  get hasExpandColumn() {
    return this.expandable && !!this.expandable.onRenderExpandIcon;
  }
  get columnLength() {
    return this.columns.length;
  }
  get mediaQueries() {
    return this._mediaQueries;
  }
  set mediaQueries(value) {
    this._mediaQueries = value;
    const style2 = getTableMediaQueriesStyleClass(this.columns, this._mediaQueries);
    this._mediaStyle && this.classList.remove(this._mediaStyle);
    this._mediaStyle = style2;
    this.classList.add(style2);
  }
  get headingStyles() {
    return this._headingStyles;
  }
  set headingStyles(value) {
    this._headingStyles = value;
    const newStyle = getCustomStylesClass(value);
    if (this._headingStyle) {
      const ths = this.querySelectorAll("th.i-table-cell");
      for (let th of ths) {
        if (th.classList.contains(this._headingStyle)) {
          th.classList.remove(this._headingStyle);
          th.classList.add(newStyle);
        }
      }
    }
    this._headingStyle = newStyle;
  }
  get bodyStyles() {
    return this._bodyStyles;
  }
  set bodyStyles(value) {
    this._bodyStyles = value;
    const newStyle = getCustomStylesClass(value);
    if (this._bodyStyle) {
      const tds = this.querySelectorAll("td.i-table-cell");
      for (let td of tds) {
        if (td.classList.contains(this._bodyStyle)) {
          td.classList.remove(this._bodyStyle);
          td.classList.add(newStyle);
        }
      }
    }
    this._bodyStyle = newStyle;
  }
  onPageChanged(source, value) {
    this.renderBody();
  }
  onSortChange(source, key2, value) {
    this._sortConfig = this._sortConfig || {};
    this._sortConfig[key2] = value;
    if (this.filteredData)
      this.renderBody();
    if (this.onColumnSort)
      this.onColumnSort(this, key2, value);
  }
  renderHeader() {
    this._headingStyle = getCustomStylesClass(this.headingStyles);
    this.tHeadElm.innerHTML = "";
    const rowElm = this.createElement("tr", this.tHeadElm);
    if (this.hasExpandColumn) {
      const thElm = this.createElement("th", rowElm);
      thElm.classList.add("i-table-cell", "i-table-cell--expand", "text-center", this._headingStyle);
    }
    this.columns.forEach((column, colIndex) => {
      const thElm = this.createElement("th", rowElm);
      column.visible === false && (thElm.style.display = "none");
      thElm.classList.add("i-table-cell", this._headingStyle);
      thElm.setAttribute("data-fieldname", column.fieldName || "action");
      if (column.width)
        thElm.style.width = typeof column.width === "number" ? `${column.width}px` : column.width;
      column.textAlign && (thElm.style.textAlign = column.textAlign);
      const columnElm = new TableColumn(void 0, { ...column, header: true });
      columnElm.onSortChange = this.onSortChange.bind(this);
      thElm.appendChild(columnElm);
      rowElm.appendChild(thElm);
    });
  }
  _handleClick(event) {
    const target = event.target;
    if (target && this.hasData) {
      const rowElm = target.closest(".i-table-row");
      let colElm = target.closest("i-table-column");
      if (!colElm)
        colElm = target.firstChild;
      const tdElm = target.closest("td");
      const rowData = colElm ? colElm.rowData : null;
      const rowIndex = (rowElm == null ? void 0 : rowElm.getAttribute("data-index")) || -1;
      const colIndex = (tdElm == null ? void 0 : tdElm.getAttribute("data-index")) || -1;
      if (this.onCellClick && rowIndex !== -1)
        this.onCellClick(this, +rowIndex, +colIndex, rowData);
      if (this.expandable && rowElm) {
        const expandTd = rowElm.querySelector(".i-table-cell--expand");
        this.expandRow(rowElm, expandTd);
      }
    }
    return super._handleClick(event, true);
  }
  expandRow(rowElm, expandTd) {
    rowElm.classList.toggle("is--expanded");
    const expandElm = rowElm.nextElementSibling;
    if (expandElm) {
      const hidden = expandElm.style.display === "none";
      if (expandTd && this.expandable.onRenderExpandIcon) {
        expandTd.innerHTML = "";
        expandTd.appendChild(this.expandable.onRenderExpandIcon(this, hidden));
      }
      expandElm.style.display = hidden ? "table-row" : "none";
    }
  }
  async renderRow(rowElm, rowData, rowIndex) {
    if (this.expandable) {
      const expandIcon = this.expandable.onRenderExpandIcon;
      if (expandIcon) {
        const expandTd = this.createElement("td", rowElm);
        expandTd.appendChild(expandIcon(this, false));
        expandTd.classList.add("i-table-cell", "i-table-cell--expand", "text-center", this._bodyStyle);
      }
    }
    let row = [];
    for (let colIndex = 0; colIndex < this.columns.length; colIndex++) {
      const column = this.columns[colIndex];
      const columnData = rowData[column.fieldName];
      const cell = new TableCell({
        columnSpan: 1,
        rowSpan: 1,
        value: columnData != null ? columnData : "--"
      });
      const tdElm = this.createElement("td", rowElm);
      column.visible === false && (tdElm.style.display = "none");
      tdElm.classList.add("i-table-cell", this._bodyStyle);
      tdElm.setAttribute("data-index", colIndex.toString());
      tdElm.setAttribute("data-fieldname", column.fieldName || "action");
      if (column.width)
        tdElm.style.width = typeof column.width === "number" ? `${column.width}px` : column.width;
      column.textAlign && (tdElm.style.textAlign = column.textAlign);
      const columnElm = new TableColumn(this, {
        ...column,
        data: columnData != null ? columnData : "--"
      });
      tdElm.appendChild(columnElm);
      await columnElm.appendNode({ tdElm, rowData, rowIndex, cell });
      row.push(cell);
    }
    if (this._rows)
      this._rows[rowIndex] = new TableRow(row);
  }
  renderBody() {
    var _a, _b;
    if (!this.tBodyElm)
      return;
    this._bodyStyle = getCustomStylesClass(this.bodyStyles);
    this.tBodyElm.innerHTML = "";
    if (this.hasData) {
      const currentPage = ((_a = this.pagination) == null ? void 0 : _a.currentPage) || 1;
      const pageSize2 = ((_b = this.pagination) == null ? void 0 : _b.pageSize) || 10;
      const dataList = this.pagination ? paginate(this.filteredData, pageSize2, currentPage) : this.filteredData;
      dataList.forEach(async (row, rowIndex) => {
        const rowElm = this.createElement("tr", this.tBodyElm);
        rowElm.classList.add("i-table-row");
        const orderClass = (rowIndex + 1) % 2 === 0 ? "even" : "odd";
        rowElm.classList.add(orderClass);
        const rIndex = rowIndex + (currentPage - 1) * pageSize2;
        rowElm.setAttribute("data-index", rIndex.toString());
        this.renderRow(rowElm, row, rowIndex);
        if (this.expandable && this.expandable.onRenderExpandedRow) {
          const childElm = this.createElement("tr", this.tBodyElm);
          childElm.classList.add("i-table-row--child");
          childElm.style.display = "none";
          const tdChild = this.createElement("td", childElm);
          tdChild.setAttribute("colspan", `${this.columnLength + (this.hasExpandColumn ? 1 : 0)}`);
          const expandElm = await this.expandable.onRenderExpandedRow(row);
          if (typeof expandElm === "string")
            tdChild.innerHTML = expandElm;
          else
            tdChild.appendChild(expandElm);
          const hideExpanded = this.expandable.rowExpandable === false;
          if (hideExpanded)
            childElm.classList.add("hidden-desktop");
        }
      });
    } else {
      const rowElm = this.createElement("tr", this.tBodyElm);
      const tdElm = this.createElement("td", rowElm);
      tdElm.setAttribute("colspan", `${this.columnLength + (this.hasExpandColumn ? 1 : 0)}`);
      tdElm.classList.add("i-table-cell", "text-center", this._bodyStyle);
      if (this.onRenderEmptyTable) {
        this.onRenderEmptyTable(this);
      } else {
        const label = this.createElement("span");
        label.textContent = "No data";
        tdElm.appendChild(label);
      }
    }
    this.firstLoad = false;
  }
  createTable() {
    const tableID = "TTable_" + Date.now();
    this._tableID = tableID;
    this.tableElm = this.createElement("table", this.wrapperElm);
    this.tableElm.id = tableID;
    this.tableElm.style.width = "100%";
    if (this._heading) {
      this.tHeadElm = this.createElement("thead", this.tableElm);
      this.tHeadElm.classList.add("i-table-header");
    }
    this.tBodyElm = this.createElement("tbody", this.tableElm);
    this.tBodyElm.classList.add("i-table-body");
  }
  filter(predicate) {
    const dataList = [...this.data];
    this.filteredData = dataList.filter(predicate);
    this.renderBody();
  }
  init() {
    var _a, _b, _c;
    if (!this.tableElm) {
      this.classList.add("i-table", tableStyle);
      if ((_a = this.options) == null ? void 0 : _a.onRenderEmptyTable)
        this.onRenderEmptyTable = this.options.onRenderEmptyTable;
      if ((_b = this.options) == null ? void 0 : _b.onColumnSort)
        this.onColumnSort = this.options.onColumnSort;
      if ((_c = this.options) == null ? void 0 : _c.onCellClick)
        this.onCellClick = this.options.onCellClick;
      this.headingStyles = this.getAttribute("headingStyles", true);
      this.bodyStyles = this.getAttribute("bodyStyles", true);
      this.wrapperElm = this.createElement("div", this);
      this.wrapperElm.classList.add("i-table-container");
      this._heading = this.getAttribute("heading", true, false);
      this.createTable();
      this.expandable = this.getAttribute("expandable", true);
      const columnsAttr = this.getAttribute("columns", true);
      columnsAttr && (this.columns = columnsAttr);
      this.pagingElm = this.createElement("div", this.wrapperElm);
      this.pagingElm.classList.add("i-table-pagi");
      this.pagingElm.style.display = "none";
      const paginationAttr = this.getAttribute("pagination");
      paginationAttr && (this.pagination = paginationAttr);
      const dataAttr = this.getAttribute("data", true);
      dataAttr && (this.data = dataAttr);
      const mediaQueries = this.getAttribute("mediaQueries", true);
      if (mediaQueries)
        this.mediaQueries = mediaQueries;
      super.init();
    }
  }
  connectedCallback() {
    super.connectedCallback();
    if (!this.pagination) {
      const pagination = this.getAttribute("pagination");
      pagination && (this.pagination = pagination);
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Table = __decorateClass([
  customElements2("i-table")
], Table);

// packages/carousel/src/style/carousel.css.ts
var Theme39 = theme_exports.ThemeVars;
var sliderStyle = style({
  display: "flex",
  flexDirection: "column",
  position: "relative",
  width: "100%",
  overflow: "hidden",
  margin: 0,
  padding: 0,
  $nest: {
    ".hidden": {
      display: "none !important"
    },
    "> div": {
      flexGrow: 1
    },
    "i-carousel-item": {
      height: "100%"
    },
    ".wrapper-slider": {
      display: "flex",
      alignItems: "center"
    },
    ".wrapper-slider-list": {
      display: "block",
      width: "100%",
      height: "100%",
      overflow: "hidden"
    },
    ".slider-arrow": {
      width: 28,
      height: 28,
      fill: Theme39.colors.primary.main,
      cursor: "pointer"
    },
    ".slider-arrow-hidden": {
      visibility: "hidden"
    },
    ".slider-list": {
      display: "flex",
      position: "relative",
      transition: "transform 500ms ease",
      height: "100%",
      touchAction: "none"
    },
    ".slider-list > *": {
      flexShrink: "0"
    },
    ".dots-pagination": {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: 0,
      marginBlock: "1rem",
      listStyle: "none",
      gap: "0.4rem",
      position: "absolute",
      bottom: "0px",
      left: "50%",
      transform: "translateX(-50%)",
      $nest: {
        ".--dot": {
          display: "flex",
          cursor: "pointer"
        },
        ".--dot > span": {
          display: "inline-block",
          minWidth: "0.8rem",
          minHeight: "0.8rem",
          backgroundColor: "transparent",
          border: `2px solid ${Theme39.colors.primary.main}`,
          borderRadius: "50%",
          transition: "background-color 0.35s ease-in-out",
          textAlign: "center",
          fontSize: ".75rem",
          width: "auto",
          whiteSpace: "nowrap",
          overflow: "hidden",
          textOverflow: "ellipsis"
        },
        ".--active > span": {
          backgroundColor: Theme39.colors.primary.main
        }
      }
    }
  }
});
var getCarouselMediaQueriesStyleClass = (mediaQueries) => {
  let styleObj = getControlMediaQueriesStyle(mediaQueries);
  for (let mediaQuery of mediaQueries) {
    let mediaQueryRule = getMediaQueryRule(mediaQuery);
    if (mediaQueryRule) {
      styleObj["$nest"][mediaQueryRule] = styleObj["$nest"][mediaQueryRule] || {};
      const ruleObj = styleObj["$nest"][mediaQueryRule];
      const nestObj = styleObj["$nest"][mediaQueryRule]["$nest"] || {};
      styleObj["$nest"][mediaQueryRule] = {
        ...ruleObj,
        $nest: {
          ...nestObj,
          ".dots-pagination": {}
        }
      };
      const {
        indicators
      } = mediaQuery.properties || {};
      if (indicators !== void 0 && indicators !== null) {
        styleObj["$nest"][mediaQueryRule]["$nest"][".dots-pagination"]["display"] = indicators ? `flex !important` : "none !important";
      }
    }
  }
  return style(styleObj);
};

// packages/carousel/src/carousel.ts
var DEFAULT_VALUES14 = {
  slidesToShow: 1,
  transitionSpeed: 500,
  autoplay: false,
  autoplaySpeed: 3e3,
  activeSlide: 0,
  type: "dot",
  indicators: true,
  swipe: false
};
var CarouselSlider = class extends Control {
  constructor(parent, options) {
    super(parent, options, { activeSlide: DEFAULT_VALUES14.activeSlide });
    this._type = DEFAULT_VALUES14.type;
    this._items = [];
    this._slider = [];
    this.pos1 = { x: 0, y: 0 };
    this.pos2 = { x: 0, y: 0 };
    this.threshold = 30;
    this.isHorizontalSwiping = false;
    this.dragStartHandler = this.dragStartHandler.bind(this);
    this.dragHandler = this.dragHandler.bind(this);
    this.dragEndHandler = this.dragEndHandler.bind(this);
  }
  get slidesToShow() {
    return this._slidesToShow;
  }
  set slidesToShow(value) {
    this._slidesToShow = value;
    this.renderItems(this.items);
    if (this.isArrow) {
      this.renderArrows();
    } else {
      this.renderDotPagination();
    }
  }
  get transitionSpeed() {
    return this._transitionSpeed;
  }
  set transitionSpeed(value) {
    this._transitionSpeed = value;
    this.sliderListElm.style.transitionDuration = value + "ms";
  }
  get autoplay() {
    return this._autoplay;
  }
  set autoplay(value) {
    this._autoplay = value;
    this.setAutoplay();
  }
  get autoplaySpeed() {
    return this._autoplaySpeed;
  }
  set autoplaySpeed(value) {
    this._autoplaySpeed = value;
    this.setAutoplay();
  }
  get activeSlide() {
    return this._activeSlide || DEFAULT_VALUES14.activeSlide;
  }
  set activeSlide(value) {
    var _a;
    if (this.isArrow) {
      this.updateSliderByArrows(value);
      return;
    }
    const validValue = value >= 0 && value < this.dotsElm.length ? value : 0;
    this._activeSlide = validValue;
    const currentActive = this.dotPagination.querySelector("li.--active");
    const dot = this.dotsElm[this._activeSlide];
    currentActive && currentActive.classList.remove("--active");
    dot && dot.classList.add("--active");
    if (this._slider && this._slider.length) {
      const min = this.slidesToShow * validValue;
      const max = this.slidesToShow * (validValue + 1);
      for (let i = 0; i < this._slider.length; i++) {
        if (i >= min && i < max)
          this._slider[i].classList.add("is-actived");
        else
          this._slider[i].classList.remove("is-actived");
      }
    }
    const fixedWidth = this.slidesToShow === 1 && this._slider && ((_a = this._slider[0]) == null ? void 0 : _a.offsetWidth) && this._slider[0].offsetWidth !== this.offsetWidth;
    const tx = fixedWidth ? -this._slider[0].offsetWidth * this._activeSlide : -this.offsetWidth * this._activeSlide;
    this.sliderListElm.style.transform = `translateX(${tx}px)`;
  }
  get items() {
    return this._items;
  }
  set items(nodes) {
    this.renderItems(nodes);
    if (this.isArrow) {
      this.renderArrows();
    } else {
      this.renderDotPagination();
    }
    this.setAutoplay();
  }
  add(control) {
    const options = { name: "", controls: [control] };
    this.items.push(options);
    const carouselItem = new CarouselItem(this, options);
    carouselItem.style.width = 100 / this.slidesToShow + "%";
    this._slider.push(carouselItem);
    this.sliderListElm.appendChild(carouselItem);
    if (this.isArrow) {
      this.renderArrows();
    } else {
      this.renderDotPagination();
    }
    return control;
  }
  get type() {
    return this._type;
  }
  set type(value) {
    this._type = value;
    this.updateWrapperClass();
    if (this.isArrow) {
      this.renderArrows();
    } else {
      this.renderDotPagination();
    }
    if (this.arrowPrev)
      this.arrowPrev.visible = this.isArrow;
    if (this.arrowNext)
      this.arrowNext.visible = this.isArrow;
  }
  get swipe() {
    return this._swipe;
  }
  set swipe(value) {
    this._swipe = value;
  }
  get mediaQueries() {
    return this._mediaQueries;
  }
  set mediaQueries(value) {
    this._mediaQueries = value;
    let style2 = getCarouselMediaQueriesStyleClass(this._mediaQueries);
    this._mediaStyle && this.classList.remove(this._mediaStyle);
    this._mediaStyle = style2;
    this.classList.add(style2);
  }
  _handleMouseDown(event, stopPropagation) {
    const result = super._handleMouseDown(event, stopPropagation);
    if (result !== void 0) {
      const target = event.target;
      const sliderList = target.closest(".slider-list");
      if (sliderList && this.swipe) {
        this.dragStartHandler(event);
        return true;
      }
    }
    return false;
  }
  _handleMouseMove(event, stopPropagation) {
    const result = super._handleMouseMove(event, stopPropagation);
    if (result !== void 0) {
      const target = event.target;
      const sliderList = target.closest(".slider-list");
      if (sliderList && this.swipe) {
        this.dragHandler(event);
        return this.isHorizontalSwiping;
      }
    }
    return false;
  }
  _handleMouseUp(event, stopPropagation) {
    const result = super._handleMouseUp(event, stopPropagation);
    if (result !== void 0) {
      const target = event.target;
      const sliderList = target.closest(".slider-list");
      if (sliderList && this.swipe) {
        this.dragEndHandler(event);
        return true;
      }
    }
    return false;
  }
  get indicators() {
    return this._indicators;
  }
  set indicators(value) {
    this._indicators = value;
    if (this.dotPagination) {
      value ? this.dotPagination.classList.remove("hidden") : this.dotPagination.classList.add("hidden");
    }
  }
  get isArrow() {
    return this.type === "arrow";
  }
  updateArrows(prev, next) {
    if (this.arrowPrev && this.arrowNext) {
      if (prev) {
        this.arrowPrev.classList.remove("slider-arrow-hidden");
      } else {
        this.arrowPrev.classList.add("slider-arrow-hidden");
      }
      if (next) {
        this.arrowNext.classList.remove("slider-arrow-hidden");
      } else {
        this.arrowNext.classList.add("slider-arrow-hidden");
      }
    }
  }
  updateSliderByArrows(value) {
    var _a;
    if (!this._slider)
      return;
    const lastIdx = value + this.slidesToShow;
    const validValue = value >= 0 && lastIdx <= this._slider.length ? value : 0;
    this.updateArrows(validValue > 0, lastIdx < this._slider.length);
    this._activeSlide = validValue;
    const fixedWidth = this.slidesToShow === 1 && this._slider && ((_a = this._slider[0]) == null ? void 0 : _a.offsetWidth) && this._slider[0].offsetWidth !== this.offsetWidth - 50;
    const itemWidth = this._slider && this._slider[0] ? this._slider[0].offsetWidth : (this.offsetWidth - 50) / this.slidesToShow;
    const tx = fixedWidth ? -this._slider[0].offsetWidth * this._activeSlide : -itemWidth * this._activeSlide;
    this.sliderListElm.style.transform = `translateX(${tx}px)`;
    if (this._slider && this._slider.length) {
      const min = validValue;
      const max = this.slidesToShow + validValue;
      for (let i = 0; i < this._slider.length; i++) {
        if (i >= min && i < max)
          this._slider[i].classList.add("is-actived");
        else
          this._slider[i].classList.remove("is-actived");
      }
    }
  }
  updateWrapperClass() {
    if (!this.wrapperSliderElm)
      return;
    if (this.isArrow) {
      this.wrapperSliderElm.classList.add("wrapper-slider");
    } else {
      this.wrapperSliderElm.classList.remove("wrapper-slider");
    }
  }
  renderItems(items) {
    if (!this.sliderListElm)
      return;
    this._items = items;
    this.sliderListElm.innerHTML = "";
    if (!items)
      return;
    let list = [];
    const min = this.slidesToShow * this.activeSlide;
    const max = this.slidesToShow * (this.activeSlide + 1);
    for (let index = 0; index < items.length; index++) {
      const carouselItem = new CarouselItem(this, items[index]);
      carouselItem.style.width = 100 / this.slidesToShow + "%";
      if (index >= min && index < max)
        carouselItem.classList.add("is-actived");
      list.push(carouselItem);
      this._slider = list;
      this.sliderListElm.appendChild(carouselItem);
    }
  }
  renderDotPagination() {
    var _a, _b;
    if (!this.dotPagination)
      return;
    this.dotPagination.innerHTML = "";
    this.dotsElm = [];
    if (this.isArrow) {
      this.dotPagination.classList.add("hidden");
      return;
    }
    const isShownIndicators = this.indicators && ((_a = this.items) == null ? void 0 : _a.length) > 1;
    isShownIndicators ? this.dotPagination.classList.remove("hidden") : this.dotPagination.classList.add("hidden");
    if ((_b = this.items) == null ? void 0 : _b.length) {
      const childLength = this.items.length;
      const totalDots = this.slidesToShow > 0 ? Math.ceil(childLength / this.slidesToShow) : childLength;
      for (let i = 0; i < totalDots; i++) {
        const dotElm = this.createElement("li", this.dotPagination);
        dotElm.classList.add("--dot");
        if (this.activeSlide === i)
          dotElm.classList.add("--active");
        this.createElement("span", dotElm);
        dotElm.addEventListener("click", () => {
          if (this._designMode)
            return;
          this.onDotClick(i);
          this.setAutoplay();
        });
        this.dotsElm.push(dotElm);
      }
    }
  }
  renderArrows() {
    if (!this.arrowPrev || !this.arrowNext)
      return;
    if (this.dotPagination) {
      this.dotPagination.innerHTML = "";
      this.dotPagination.classList.add("hidden");
      this.dotsElm = [];
    }
    if (this.hasChildNodes() && this.sliderListElm.childNodes.length) {
      const childLength = this.sliderListElm.childNodes.length;
      const isArrowShown = childLength > this.slidesToShow && this.isArrow;
      this.updateArrows(isArrowShown, isArrowShown);
    } else {
      this.updateArrows(false, false);
    }
  }
  onDotClick(index) {
    this.activeSlide = index;
    if (typeof this.onSlideChange === "function")
      this.onSlideChange(index);
  }
  setAutoplay() {
    if (this.timer) {
      clearInterval(this.timer);
    }
    if (this.autoplay) {
      if (!this.isArrow && this.dotsElm.length > 1) {
        this.timer = setInterval(() => {
          const index = this.activeSlide + 1 >= this.dotsElm.length ? 0 : this.activeSlide + 1;
          this.onDotClick(index);
        }, this.autoplaySpeed);
      } else if (this.isArrow) {
        this.timer = setInterval(() => {
          if (this._slider && this._slider.length > this.slidesToShow) {
            let idx = 0;
            if (this._slider) {
              idx = this.activeSlide + this.slidesToShow >= this._slider.length ? 0 : this.activeSlide + 1;
            }
            this.updateSliderByArrows(idx);
          }
        }, this.autoplaySpeed);
      }
    }
  }
  prev() {
    const index = this.activeSlide - 1 < 0 ? this.activeSlide : this.activeSlide - 1;
    this.activeSlide = index;
    this.setAutoplay();
    if (typeof this.onSlideChange === "function")
      this.onSlideChange(index);
  }
  next() {
    let index;
    if (!this.isArrow) {
      const total = this.slidesToShow > 0 ? Math.ceil(this._slider.length / this.slidesToShow) : this._slider.length;
      index = this.activeSlide + 1 >= total ? this.activeSlide : this.activeSlide + 1;
    } else {
      index = this.activeSlide + this.slidesToShow >= this._slider.length ? this.activeSlide : this.activeSlide + 1;
    }
    this.activeSlide = index;
    this.setAutoplay();
    if (typeof this.onSlideChange === "function")
      this.onSlideChange(index);
  }
  refresh() {
    super.refresh();
    if (this._slider && this._slider.length) {
      if (this.isArrow) {
        this.updateSliderByArrows(this.activeSlide);
        return;
      }
      const fixedWidth = this.slidesToShow === 1 && this._slider[0] && this._slider[0].offsetWidth && this._slider[0].offsetWidth !== this.offsetWidth;
      const tx = fixedWidth ? -this._slider[0].offsetWidth * this._activeSlide : -this.offsetWidth * this._activeSlide;
      this.sliderListElm.style.transform = `translateX(${tx}px)`;
    }
  }
  dragStartHandler(event) {
    if (event instanceof TouchEvent) {
      this.pos1 = {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY
      };
      this.pos2 = {
        x: 0,
        y: 0
      };
    } else {
      event.preventDefault();
      this.pos1 = {
        x: event.clientX,
        y: event.clientY
      };
      this.pos2 = {
        x: 0,
        y: 0
      };
    }
    this.isSwiping = false;
    this.isHorizontalSwiping = false;
    if (typeof this.onSwipeStart === "function")
      this.onSwipeStart();
  }
  dragHandler(event) {
    if (event instanceof TouchEvent) {
      this.pos2.x = this.pos1.x - event.touches[0].clientX;
      this.pos2.y = this.pos1.y - event.touches[0].clientY;
    } else {
      this.pos2.x = this.pos1.x - event.clientX;
      this.pos2.y = this.pos1.y - event.clientY;
    }
    this.isSwiping = Math.abs(this.pos2.x) > this.threshold;
    this.isHorizontalSwiping = this.isSwiping && Math.abs(this.pos2.x) > Math.abs(this.pos2.y);
  }
  dragEndHandler(event) {
    if (this.isHorizontalSwiping) {
      if (this.pos2.x < -this.threshold) {
        this.prev();
      } else if (this.pos2.x > this.threshold) {
        this.next();
      } else {
        this.refresh();
      }
    }
    if (typeof this.onSwipeEnd === "function")
      this.onSwipeEnd(this.isSwiping);
  }
  init() {
    const children = [];
    this.childNodes.forEach((node) => {
      if (node instanceof Control) {
        children.push(node);
      } else {
        node.remove();
      }
    });
    super.init();
    this.classList.add(sliderStyle);
    this.type = this.getAttribute("type", true, DEFAULT_VALUES14.type);
    this.indicators = this.getAttribute("indicators", true, DEFAULT_VALUES14.indicators);
    this.wrapperSliderElm = this.createElement("div", this);
    this.updateWrapperClass();
    const wrapper = this.createElement("div", this.wrapperSliderElm);
    wrapper.classList.add("wrapper-slider-list");
    this.slidesToShow = this.getAttribute("slidesToShow", true, DEFAULT_VALUES14.slidesToShow);
    this.sliderListElm = this.createElement("div", wrapper);
    this.sliderListElm.classList.add("slider-list");
    this.transitionSpeed = this.getAttribute("transitionSpeed", true, DEFAULT_VALUES14.transitionSpeed);
    this.arrowPrev = new Icon(void 0, { name: "angle-left", visible: this.isArrow });
    this.arrowNext = new Icon(void 0, { name: "angle-right", visible: this.isArrow });
    this.arrowPrev.classList.add("slider-arrow");
    this.arrowNext.classList.add("slider-arrow");
    this.arrowPrev.onClick = () => {
      if (this._designMode)
        return;
      this.prev();
    };
    this.arrowNext.onClick = () => {
      if (this._designMode)
        return;
      this.next();
    };
    this.wrapperSliderElm.prepend(this.arrowPrev);
    this.wrapperSliderElm.append(this.arrowNext);
    this.renderArrows();
    this.dotPagination = this.createElement("ul", this);
    this.dotPagination.classList.add("dots-pagination");
    this.renderDotPagination();
    this.autoplaySpeed = this.getAttribute("autoplaySpeed", true, DEFAULT_VALUES14.autoplaySpeed);
    this.autoplay = this.getAttribute("autoplay", true);
    if (children == null ? void 0 : children.length) {
      children.forEach((child2) => {
        this.add(child2);
      });
    } else {
      this.items = this.getAttribute("items", true, []);
    }
    this.activeSlide = this.getAttribute("activeSlide", true, DEFAULT_VALUES14.activeSlide);
    this.swipe = this.getAttribute("swipe", true, DEFAULT_VALUES14.swipe);
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
CarouselSlider = __decorateClass([
  customElements2("i-carousel-slider", {
    icon: "sliders-h",
    group: GroupType.BASIC,
    className: "CarouselSlider",
    props: {
      slidesToShow: { type: "number", default: DEFAULT_VALUES14.slidesToShow },
      transitionSpeed: { type: "number", default: DEFAULT_VALUES14.transitionSpeed },
      autoplay: { type: "boolean", default: DEFAULT_VALUES14.autoplay },
      autoplaySpeed: { type: "number", default: DEFAULT_VALUES14.autoplaySpeed },
      activeSlide: { type: "number", default: DEFAULT_VALUES14.activeSlide },
      type: { type: "string", default: DEFAULT_VALUES14.type },
      indicators: { type: "boolean", default: DEFAULT_VALUES14.indicators },
      swipe: { type: "boolean", default: DEFAULT_VALUES14.swipe },
      items: { type: "array", default: [] }
    },
    events: {
      onSwipeStart: [],
      onSwipeEnd: [
        { name: "isSwiping", type: "boolean" }
      ],
      onSlideChange: [
        { name: "index", type: "number" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        type: {
          type: "string",
          enum: ["dot", "arrow"],
          default: DEFAULT_VALUES14.type
        },
        slidesToShow: {
          type: "number",
          default: DEFAULT_VALUES14.slidesToShow
        },
        transitionSpeed: {
          type: "number",
          default: DEFAULT_VALUES14.transitionSpeed
        },
        autoplay: {
          type: "boolean",
          default: DEFAULT_VALUES14.autoplay
        },
        autoplaySpeed: {
          type: "number",
          default: DEFAULT_VALUES14.autoplaySpeed
        },
        activeSlide: {
          type: "number",
          default: DEFAULT_VALUES14.activeSlide
        },
        indicators: {
          type: "boolean",
          default: DEFAULT_VALUES14.indicators
        },
        swipe: {
          type: "boolean",
          default: DEFAULT_VALUES14.swipe
        }
      }
    }
  })
], CarouselSlider);
var CarouselItem = class extends Container {
  constructor(parent, options) {
    super(parent, options);
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  addChildControl(control) {
    this.appendChild(control);
  }
  removeChildControl(control) {
    if (this.contains(control))
      this.removeChild(control);
  }
  init() {
    this.name = this.options.name;
    this._controls = this.options.controls || [];
    super.init();
    this._controls.forEach((child2) => {
      this.addChildControl(child2);
    });
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
CarouselItem = __decorateClass([
  customElements2("i-carousel-item")
], CarouselItem);

// packages/video/src/style/video.css.ts
cssRule("i-video", {
  position: "relative",
  $nest: {
    ".video-js  .vjs-big-play-button": {
      top: "50%",
      left: "50%",
      transform: "translate(-50%, -50%)"
    },
    ".overlay": {
      position: "absolute",
      top: "0px",
      left: "0px",
      width: "100%",
      height: "calc(100% - 3rem)",
      zIndex: 9999,
      display: "none"
    },
    "@media screen and (max-width: 767px)": {
      $nest: {
        ".overlay": {
          display: "block"
        }
      }
    }
  }
});

// packages/video/src/video.ts
var reqs = ["video-js"];
function loadCss() {
  const cssId = "videoCss";
  if (!document.getElementById(cssId)) {
    const head = document.getElementsByTagName("head")[0];
    const link = document.createElement("link");
    link.id = cssId;
    link.rel = "stylesheet";
    link.type = "text/css";
    link.href = `${LibPath}lib/video-js/video-js.css`;
    link.media = "all";
    head.appendChild(link);
  }
}
var Video = class extends Container {
  constructor() {
    super(...arguments);
    this._isPlayed = false;
  }
  get url() {
    return this._url;
  }
  set url(value) {
    this._url = value;
    if (!this.sourceElm)
      this.sourceElm = this.createElement("source", this.videoElm);
    this.sourceElm.src = value;
    if (this.player) {
      if (value) {
        this.sourceElm.type = "application/x-mpegURL";
        this.player.src({
          src: value,
          type: "application/x-mpegURL"
        });
      } else {
        this.player.reset();
      }
    } else {
      const videoEl = this.videoElm;
      if (videoEl == null ? void 0 : videoEl.load)
        videoEl.load();
    }
  }
  get border() {
    return this._border;
  }
  set border(value) {
    var _a;
    const video = (_a = this.videoElm) == null ? void 0 : _a.querySelector("video");
    if (!video)
      return;
    this._border = new Border(video, value);
  }
  set designMode(value) {
    this._designMode = value;
    if (this.overlayElm) {
      this.overlayElm.style.height = value ? "100%" : "calc(100% - 3rem)";
      this.overlayElm.style.display = value ? "block" : "none";
    }
  }
  getPlayer() {
    if (this.player)
      return this.player;
    return new Promise((resolve, reject) => {
      const interval = setInterval(() => {
        if (this.player) {
          clearInterval(interval);
          resolve(this.player);
        }
      }, 100);
    });
  }
  getVideoTypeFromExtension(url) {
    if (!url)
      return null;
    let videoType;
    let ext = url.split(".").pop();
    switch (ext) {
      case "mp4":
        videoType = "video/mp4";
        break;
      case "webm":
        videoType = "video/webm";
        break;
      case "ogg":
        videoType = "video/ogg";
        break;
      default:
        videoType = "video/mp4";
        break;
    }
    return videoType;
  }
  init() {
    if (!this.initialized) {
      super.init();
      loadCss();
      this.overlayElm = this.createElement("div", this);
      this.overlayElm.classList.add("overlay");
      this.overlayElm.style.height = this._designMode ? "100%" : "calc(100% - 3rem)";
      this.overlayElm.style.display = this._designMode ? "block" : "none";
      const self = this;
      const isStreaming = this.getAttribute("isStreaming", true);
      if (isStreaming) {
        let id = `video-${new Date().getTime()}`;
        this.videoElm = this.createElement("video-js", this);
        this.videoElm.id = id;
        this.videoElm.setAttribute("controls", "true");
        this.videoElm.setAttribute("preload", "auto");
        this.videoElm.classList.add("vjs-default-skin");
        this.overlayElm.addEventListener("click", (event) => {
          if (this._designMode)
            return;
          event.preventDefault();
          event.stopPropagation();
          if (this.player.paused()) {
            this.player.play();
          } else {
            this.player.pause();
          }
        });
        const src = this.getAttribute("url", true);
        const border = this.getAttribute("border", true);
        RequireJS.config({
          baseUrl: `${LibPath}lib/video-js`,
          paths: {
            "video-js": "video-js"
          }
        });
        RequireJS.require(reqs, function(videojs) {
          self.player = videojs(id, {
            playsinline: true,
            autoplay: false,
            controls: true,
            fluid: true,
            responsive: true,
            inactivityTimeout: 500,
            preload: "auto",
            techOrder: ["html5"],
            plugins: {},
            height: "100%",
            width: "100%"
          });
          if (src) {
            self.sourceElm = self.createElement("source", self.videoElm);
            self.sourceElm.type = "application/x-mpegURL";
            self.sourceElm.src = src;
            self.player.src({
              src,
              type: "application/x-mpegURL"
            });
          }
          const video = self.videoElm.querySelector("video");
          if (video) {
            self.videoElm.insertBefore(self.overlayElm, video);
            if (border)
              self._border = new Border(video, border);
          }
        });
      } else {
        this.videoElm = this.createElement("video", this);
        this.videoElm.setAttribute("controls", "true");
        this.videoElm.setAttribute("width", "100%");
        this.insertBefore(this.overlayElm, this.videoElm);
        this.overlayElm.addEventListener("click", (event) => {
          if (this._designMode)
            return;
          event.preventDefault();
          event.stopPropagation();
          if (this._isPlayed) {
            const video = this.videoElm;
            if (video.paused) {
              video.play();
            } else {
              video.pause();
            }
          }
        });
        this.videoElm.addEventListener("canplay", () => {
          this._isPlayed = true;
        });
        this.sourceElm = this.createElement("source", this.videoElm);
        this.url = this.getAttribute("url", true);
        let videoType = this.getVideoTypeFromExtension(this.url);
        if (videoType) {
          this.sourceElm.type = videoType;
        }
      }
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Video = __decorateClass([
  customElements2("i-video", {
    icon: "play-circle",
    group: GroupType.BASIC,
    className: "Video",
    props: {
      url: { type: "string", default: "" },
      isStreaming: { type: "boolean", default: false }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        url: { type: "string" },
        isStreaming: { type: "boolean", default: false }
      }
    }
  })
], Video);

// packages/schema-designer/src/uiSchema.ts
var Theme40 = theme_exports.ThemeVars;
var dataUITypes = [
  { label: "VerticalLayout", value: "VerticalLayout" },
  { label: "HorizontalLayout", value: "HorizontalLayout" },
  { label: "Group", value: "Group" },
  { label: "Categorization", value: "Categorization" },
  { label: "Category", value: "Category" },
  { label: "Control", value: "Control" }
];
var SchemaDesignerUI = class extends Container {
  constructor(parent, options) {
    super(parent, options);
  }
  init() {
    super.init();
    this.initUI();
    this.createUISchema(this.pnlUISchemaBuilder);
    this.updateJsonUISchema();
  }
  refresh() {
    super.refresh();
  }
  getUISchema() {
    return this.uiSchema;
  }
  updateJsonUISchema() {
    this.uiSchema = this.pnlUISchemaBuilder.firstChild.getData();
    this.txtUISchema.value = JSON.stringify(this.uiSchema, null, 4);
  }
  async getUISchemaMap(_schema, _options) {
    var _a, _b;
    let data = _schema || this.schema;
    data = { ...data };
    const { _scope, _name, _scopeArr, _isRule, _getScope } = _options || {};
    if (_scopeArr) {
      const scopes = _scopeArr.split("/");
      scopes.splice(0, 1);
      for (const item of scopes) {
        data = data[item];
      }
      data = data.items;
    }
    let mapSchema = [];
    const props = data.properties;
    for (const prop in props) {
      const { type, items, oneOf } = props[prop];
      const scope = `${_scope || "#"}/properties/${prop}`;
      const name = _name ? `${_name}/${prop}` : prop;
      const isArrItems = type === "array" && items.type === "object";
      if (_isRule) {
        if (type !== "object" && type !== "array" && !this.pnlUISchemaBuilder.querySelector(`[scope-rule='${scope}']`)) {
          mapSchema.push({ label: name, value: scope, type });
        }
      } else {
        if (_getScope && scope === _getScope) {
          return [{ label: name, value: scope, type, hasItems: isArrItems, isOneOf: oneOf == null ? void 0 : oneOf.lenght, isEnum: (_a = props[prop].enum) == null ? void 0 : _a.length }];
        }
        if (!this.pnlUISchemaBuilder.querySelector(`[scope-element='${scope}']`)) {
          mapSchema.push({ label: name, value: scope, type, hasItems: isArrItems, isOneOf: oneOf == null ? void 0 : oneOf.lenght, isEnum: (_b = props[prop].enum) == null ? void 0 : _b.length });
        } else {
          continue;
        }
      }
      if (type === "object") {
        mapSchema.push(...await this.getUISchemaMap(props[prop], { _scope: scope, _name: name, _isRule }));
      } else if (isArrItems) {
        mapSchema.push(...await this.getUISchemaMap(items, { _scope: scope, _name: name, _isRule }));
      }
    }
    return mapSchema;
  }
  getScopeByFields(fields) {
    let _fields = [];
    for (const fld of fields) {
      if (_fields[_fields.length - 1] !== this.uuid && fld === "items") {
        continue;
      }
      _fields.push(fld);
    }
    return _fields;
  }
  async updateActionsItems() {
    const arrCbb = this.pnlUISchemaBuilder.querySelectorAll("[cbb-property]");
    const items = await this.getUISchemaMap(this.schema);
    for (const cbb of arrCbb) {
      const scopeArr = cbb.getAttribute("cbb-property-array");
      if (scopeArr) {
        cbb.items = await this.getUISchemaMap(this.schema, { _scopeArr: scopeArr });
      } else {
        cbb.items = items;
      }
    }
  }
  async updateActionsRules() {
    const arrCbb = this.pnlUISchemaBuilder.querySelectorAll("[cbb-rule]");
    const items = await this.getUISchemaMap(this.schema, { _isRule: true });
    for (const cbb of arrCbb) {
      cbb.items = items;
    }
  }
  async updateUISchemaItemsByRename(fields, newFields) {
    var _a;
    const _fields = this.getScopeByFields(fields);
    const _newFields = this.getScopeByFields(newFields);
    const regexUUID = new RegExp(this.uuid, "g");
    const scope = `#/${_fields.join("/").replace(regexUUID, "properties")}`;
    const newScope = `#/${_newFields.join("/").replace(regexUUID, "properties")}`;
    const picked = this.pnlUISchemaBuilder.querySelector(`[scope-element='${scope}']`);
    const childPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-element*='${scope}/']`);
    const rulePicked = this.pnlUISchemaBuilder.querySelector(`[scope-rule='${scope}']`);
    const ruleChildPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-rule*='${scope}/']`);
    const arrPicked = this.pnlUISchemaBuilder.querySelector(`[cbb-property-array='${scope}']`);
    const arrChildPicked = this.pnlUISchemaBuilder.querySelectorAll(`[full-scope-element*='${scope}']`);
    const items = await this.getUISchemaMap(this.schema);
    const ruleItems = await this.getUISchemaMap(this.schema, { _isRule: true });
    const regexLabel = new RegExp(`${this.uuid}/`, "g");
    const label = `${_fields.join("/").replace(regexLabel, "")}`;
    const newLabel = `${_newFields.join("/").replace(regexLabel, "")}`;
    if (picked) {
      picked.setAttribute("scope-element", newScope);
      picked.options["scope-element"] = newScope;
      picked.items = items;
      picked.selectedItem = { label: newLabel, value: newScope };
    }
    for (const _picked of childPicked) {
      const childScope = _picked.getAttribute("scope-element") || "";
      const newChildScope = childScope.replace(scope, newScope);
      const currentLabel = _picked.selectedItem.label || "";
      const _newLb = currentLabel.replace(label, newLabel);
      _picked.setAttribute("scope-element", newChildScope);
      _picked.options["scope-element"] = newChildScope;
      _picked.items = items;
      _picked.selectedItem = { label: _newLb, value: newChildScope };
    }
    if (arrPicked) {
      arrPicked.setAttribute("cbb-property-array", newScope);
      arrPicked.options["cbb-property-array"] = newScope;
    }
    for (const _itemPick of arrChildPicked) {
      const fullScope = _itemPick.getAttribute("full-scope-element") || "";
      if (fullScope === scope) {
        _itemPick.setAttribute("full-scope-element", newScope);
        _itemPick.options["full-scope-element"] = newScope;
        const scopeLength = (_itemPick.getAttribute("scope-element") || "").split("/").length - 1;
        const arrNewScope = newScope.split("/");
        arrNewScope.splice(0, arrNewScope.length - scopeLength);
        const list = await this.getUISchemaMap(this.schema, { _scopeArr: _itemPick.getAttribute("cbb-property-array") || "" });
        _itemPick.items = list;
        _itemPick.setAttribute("scope-element", `#/${arrNewScope.join("/")}`);
        _itemPick.options["scope-element"] = `#/${arrNewScope.join("/")}`;
        _itemPick.clear();
        _itemPick.selectedItem = { label: ((_a = list.find((v) => v.value === `#/${arrNewScope.join("/")}`)) == null ? void 0 : _a.label) || "", value: `#/${arrNewScope.join("/")}` };
      } else if (fullScope.includes(`${scope}/`)) {
        _itemPick.setAttribute("full-scope-element", fullScope.replace(scope, newScope));
        _itemPick.options["full-scope-element"] = fullScope.replace(scope, newScope);
      }
    }
    if (rulePicked) {
      rulePicked.setAttribute("scope-rule", newScope);
      rulePicked.options["scope-rule"] = newScope;
      rulePicked.items = ruleItems;
      rulePicked.selectedItem = { label: newLabel, value: newScope };
    }
    for (const _rulePicked of ruleChildPicked) {
      const childScope = _rulePicked.getAttribute("scope-rule") || "";
      const newChildScope = childScope.replace(scope, newScope);
      const currentLabel = _rulePicked.selectedItem.label || "";
      const _newLb = currentLabel.replace(label, newLabel);
      _rulePicked.setAttribute("scope-rule", newChildScope);
      _rulePicked.options["scope-rule"] = newChildScope;
      _rulePicked.items = ruleItems;
      _rulePicked.selectedItem = { label: _newLb, value: newChildScope };
    }
    await this.updateActionsItems();
    await this.updateActionsRules();
    this.updateJsonUISchema();
  }
  async updateUISchemaByType(fields, isOption) {
    const _fields = this.getScopeByFields(fields);
    const regexUUID = new RegExp(this.uuid, "g");
    const scope = `#/${_fields.join("/").replace(regexUUID, "properties")}`;
    if (isOption) {
      const picked = this.pnlUISchemaBuilder.querySelector(`[scope-element='${scope}']`);
      if (picked) {
        const parentPicked = picked.closest("[item-element]");
        parentPicked == null ? void 0 : parentPicked.resetOptions();
      }
    }
    const rulePicked = this.pnlUISchemaBuilder.querySelector(`[scope-rule='${scope}']`);
    if (rulePicked) {
      const ruleItems = await this.getUISchemaMap(this.schema, { _isRule: true });
      const currentItem = ruleItems.find((v) => v.value === scope);
      if (currentItem) {
        rulePicked.selectedItem = currentItem;
        const parentPicked = rulePicked.closest("[item-element]");
        parentPicked == null ? void 0 : parentPicked.initRule();
      }
    }
    this.updateActionsItems();
    this.updateActionsRules();
    this.updateJsonUISchema();
  }
  deleteUISchema(fields, onlyChild) {
    var _a, _b, _c, _d, _e, _f, _g;
    const _fields = this.getScopeByFields(fields);
    const regexUUID = new RegExp(this.uuid, "g");
    const scope = `#/${_fields.join("/").replace(regexUUID, "properties")}`;
    const picked = this.pnlUISchemaBuilder.querySelector(`[scope-element='${scope}']`);
    if (!onlyChild) {
      if (picked) {
        (_a = picked.closest("[item-element]")) == null ? void 0 : _a.deleteElement();
      } else {
        const fullPicked = this.pnlUISchemaBuilder.querySelector(`[full-scope-element='${scope}']`);
        (_b = fullPicked == null ? void 0 : fullPicked.closest("[item-element]")) == null ? void 0 : _b.deleteElement();
      }
    } else {
      (_c = picked == null ? void 0 : picked.closest("[item-element]")) == null ? void 0 : _c.resetOptions();
    }
    const childPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-element*='${scope}/']`);
    const childPickedArr = this.pnlUISchemaBuilder.querySelectorAll(`[cbb-property-array='${scope}']`);
    for (const _picked of childPicked) {
      (_d = _picked.closest("[item-element]")) == null ? void 0 : _d.deleteElement();
    }
    for (const _picked of childPickedArr) {
      (_e = _picked.closest("[item-element]")) == null ? void 0 : _e.deleteElement();
    }
    const rulePicked = this.pnlUISchemaBuilder.querySelector(`[scope-rule='${scope}']`);
    if (rulePicked) {
      (_f = rulePicked.closest("[item-element]")) == null ? void 0 : _f.resetRule();
    }
    const ruleChildPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-rule*='${scope}/']`);
    for (const _rulePicked of ruleChildPicked) {
      (_g = _rulePicked.closest("[item-element]")) == null ? void 0 : _g.resetRule();
    }
    this.updateActionsRules();
  }
  createUISchema(parent, parentType, isChildren, scopeArr) {
    const pnlUISchema = new Panel();
    pnlUISchema.setAttribute("item-element", "true");
    parent.append(pnlUISchema);
    const pnlUIElements = new Panel(void 0, {
      padding: { top: 10, bottom: 10, left: 10, right: 10 }
    });
    const btnAddElement = new Button(void 0, {
      caption: "Add Element",
      padding: { top: 6, bottom: 6, left: 16, right: 16 },
      margin: { top: 8 },
      maxWidth: 150,
      visible: !isChildren
    });
    btnAddElement.prepend(new Icon(void 0, {
      name: "plus",
      width: "1em",
      height: "1em",
      fill: Theme40.colors.primary.contrastText
    }));
    btnAddElement.onClick = () => {
      this.createUISchema(pnlUIElements, currentLayout, true);
      this.updateJsonUISchema();
    };
    btnAddElement.setAttribute("add-element", "true");
    let currentLayout = "VerticalLayout";
    let useRule = false;
    let effect = "HIDE";
    let ruleScope = void 0;
    let cbbRuleScope;
    let ruleNegative = false;
    let ruleConst = void 0;
    let ruleMinimum = void 0;
    let ruleMaximum = void 0;
    let listEnum = [];
    const listEffect = [
      { label: "HIDE", value: "HIDE" },
      { label: "SHOW", value: "SHOW" },
      { label: "DISABLE", value: "DISABLE" },
      { label: "ENABLE", value: "ENABLE" }
    ];
    const pnlRule = new Panel(void 0, {
      margin: { top: 10 },
      visible: false
    });
    if (isChildren) {
      const ckbRule = new Checkbox(pnlRule, {
        caption: "Rule",
        checked: false
      });
      ckbRule.onChanged = () => {
        const checked = ckbRule.checked;
        if (checked === useRule)
          return;
        if (checked) {
          createRuleSchemaUI();
        } else {
          deleteRuleSchemaUI();
        }
        pnlRuleForm.visible = checked;
        useRule = checked;
        this.updateJsonUISchema();
      };
      const pnlRuleForm = new Panel(pnlRule, { visible: false });
      pnlRuleForm.classList.add("cs-ui--schema");
      const createRuleSchemaUI = async () => {
        pnlRuleForm.clearInnerHTML();
        const pnlFormGroup = new Panel(pnlRuleForm, {
          width: "calc(50% - 5px)"
        });
        pnlFormGroup.classList.add("form-group");
        new Label(pnlFormGroup, { caption: "Effect" });
        const pnlFormControl = new Panel(pnlFormGroup);
        pnlFormControl.classList.add("form-control");
        const cbbEffect = new ComboBox(pnlFormControl, {
          items: listEffect,
          selectedItem: listEffect[0],
          icon: { name: "caret-down", width: "16px", height: "16px" }
        });
        cbbEffect.onChanged = () => {
          effect = cbbEffect.selectedItem.value;
          this.updateJsonUISchema();
        };
        cbbRuleScope = new ComboBox(void 0, {
          items: await this.getUISchemaMap(this.schema, { _isRule: true }),
          icon: { name: "caret-down", width: "16px", height: "16px" }
        });
        const initRule = (ignoreValue) => {
          const selectedItem = cbbRuleScope == null ? void 0 : cbbRuleScope.selectedItem;
          if (!ignoreValue && ruleScope === selectedItem.value)
            return;
          createRuleFormSchemaUI(selectedItem);
          ruleScope = selectedItem.value;
          iconRemoveRuleScope.visible = true;
          cbbRuleScope.setAttribute("scope-rule", ruleScope);
          cbbRuleScope.options["scope-rule"] = ruleScope;
          this.updateJsonUISchema();
          this.updateActionsRules();
        };
        pnlUISchema.initRule = () => initRule(true);
        cbbRuleScope.setAttribute("cbb-rule", "true");
        cbbRuleScope.onChanged = () => initRule();
        const iconRemoveRuleScope = new Icon(void 0, {
          name: "times-circle",
          visible: false,
          width: 12,
          height: 12,
          fill: Theme40.colors.secondary.main,
          tooltip: {
            content: "Remove this property",
            trigger: "hover"
          }
        });
        iconRemoveRuleScope.onClick = () => {
          iconRemoveRuleScope.visible = false;
          resetRule();
          this.updateJsonUISchema();
        };
        const pnlRuleFormGroup = new Panel(pnlRuleForm, {
          width: "calc(50% - 5px)"
        });
        pnlRuleFormGroup.classList.add("form-group");
        new Label(pnlRuleFormGroup, { caption: "Scope" });
        const pnlRuleFormControl = new Panel(pnlRuleFormGroup);
        pnlRuleFormControl.classList.add("form-control");
        const hStackRule = new HStack(pnlRuleFormControl, {
          gap: 4,
          verticalAlignment: "center"
        });
        hStackRule.appendChild(cbbRuleScope);
        hStackRule.appendChild(iconRemoveRuleScope);
        const pnlRuleSchema = new Panel(pnlRuleForm, { width: "100%" });
        pnlRuleSchema.classList.add("cs-ui--schema");
        const createRuleFormSchemaUI = (item) => {
          pnlRuleSchema.clearInnerHTML();
          const inputType = item.type === "string" ? "text" : "number";
          let controlConst = [];
          let iconRemoveConst = [];
          ruleConst = void 0;
          ruleNegative = false;
          ruleScope = void 0;
          ruleMinimum = void 0;
          ruleMaximum = void 0;
          listEnum = [];
          if (item.type === "boolean") {
            controlConst = new ComboBox(void 0, {
              items: [
                { label: "true", value: "true" },
                { label: "false", value: "false" }
              ],
              icon: { name: "caret-down", width: "16px", height: "16px" }
            });
            controlConst.onChanged = () => {
              iconRemoveConst.visible = true;
              ruleConst = controlConst.selectedItem.value === "true" ? true : false;
              this.updateJsonUISchema();
            };
            iconRemoveConst = new Icon(void 0, {
              name: "times-circle",
              visible: false,
              width: 12,
              height: 12,
              fill: Theme40.colors.secondary.main,
              tooltip: {
                content: "Remove this property",
                trigger: "hover"
              }
            });
            iconRemoveConst.onClick = () => {
              controlConst.clear();
              ruleConst = void 0;
              iconRemoveConst.visible = false;
              this.updateJsonUISchema();
            };
          }
          const pnlFormGroup2 = new Panel(pnlRuleSchema, { width: "calc(50% - 5px)" });
          pnlFormGroup2.classList.add("form-group");
          new Label(pnlFormGroup2, { caption: "Const" });
          const pnlFormControl2 = new Panel(pnlFormGroup2);
          pnlFormControl2.classList.add("form-control");
          if (item.type === "boolean") {
            const hStack2 = new HStack(pnlFormControl2, {
              gap: 4,
              verticalAlignment: "center"
            });
            hStack2.appendChild(controlConst);
            hStack2.appendChild(iconRemoveConst);
          } else {
            const inputConst = new Input(pnlFormControl2, { inputType });
            inputConst.onChanged = () => {
              const val = inputConst.value;
              if (inputType === "text") {
                ruleConst = val;
              } else {
                ruleConst = val === "" || isNaN(val) ? "" : Number(val);
              }
              this.updateJsonUISchema();
            };
          }
          if (["number", "integer"].includes(item.type)) {
            const pnlFormGroupMin = new Panel(pnlRuleSchema, { width: "calc(50% - 5px)" });
            new Label(pnlFormGroupMin, { caption: "Minimum" });
            const pnlFormControlMin = new Panel(pnlFormGroupMin);
            pnlFormControlMin.classList.add("form-control");
            const inputMin = new Input(pnlFormControlMin, { inputType });
            inputMin.onChanged = () => {
              ruleMinimum = inputMin.value;
              this.updateJsonUISchema();
            };
            const pnlFormGroupMax = new Panel(pnlRuleSchema, { width: "calc(50% - 5px)" });
            new Label(pnlFormGroupMax, { caption: "Exclusive Maximum" });
            const pnlFormControlMax = new Panel(pnlFormGroupMax);
            pnlFormControlMax.classList.add("form-control");
            const inputMax = new Input(pnlFormControlMax, { inputType });
            inputMax.onChanged = () => {
              ruleMaximum = inputMax.value;
              this.updateJsonUISchema();
            };
          }
          const pnlFormGroupNegative = new Panel(pnlRuleSchema, { width: "calc(50% - 5px)", display: "flex" });
          const pnlFormControlNegative = new Panel(pnlFormGroupNegative, { margin: { top: "auto" } });
          pnlFormControlNegative.classList.add("form-control");
          const ckbNegative = new Checkbox(pnlFormControlNegative, {
            caption: "Negative",
            checked: false
          });
          ckbNegative.onChanged = () => {
            ruleNegative = ckbNegative.checked;
            this.updateJsonUISchema();
          };
          if (["string", "number", "integer"].includes(item.type)) {
            const hStackEnum = new HStack(void 0, {
              gap: 8,
              verticalAlignment: "center",
              wrap: "wrap"
            });
            const btnAdd = new Button(void 0, {
              caption: "Add",
              enabled: false,
              padding: { top: 6, bottom: 6, left: 16, right: 16 }
            });
            const inputEnum = new Input(void 0, {
              inputType
            });
            inputEnum.classList.add("cs-width--input");
            inputEnum.onChanged = () => {
              const val = inputEnum.value;
              if (item.type === "string") {
                btnAdd.enabled = val && !listEnum.some((v) => v.toString().toLowerCase() === val.toString().toLowerCase());
              } else {
                btnAdd.enabled = val !== "" && !isNaN(Number(val)) && !listEnum.some((v) => v === Number(val));
              }
            };
            btnAdd.onClick = () => {
              const val = inputEnum.value;
              if ((inputType === "number" && !isNaN(val) || inputType === "text" && val) && !listEnum.some((v) => v.toString().toLowerCase() === val.toString().toLowerCase())) {
                listEnum.push(inputType === "number" ? Number(val) : val);
                inputEnum.value = "";
                btnAdd.enabled = false;
                const pnlEnum = new Panel(hStackEnum, {
                  position: "relative",
                  display: "flex",
                  padding: { top: 8, bottom: 8, left: 16, right: 16 },
                  border: { radius: 8 },
                  background: { color: Theme40.action.selected }
                });
                const iconTimesEnum = new Icon(pnlEnum, {
                  name: "times",
                  width: 14,
                  height: 14,
                  fill: Theme40.colors.secondary.main,
                  position: "absolute",
                  right: 2,
                  top: 2
                });
                iconTimesEnum.onClick = () => {
                  const idx = listEnum.findIndex((v) => v.toString().toLowerCase() === val.toString().toLowerCase());
                  listEnum.splice(idx, 1);
                  iconRemove.visible = !!listEnum.length;
                  hStackEnum.removeChild(pnlEnum);
                  this.updateJsonUISchema();
                };
                const lbVal = new Label(pnlEnum, {
                  caption: val,
                  font: { size: "12px" },
                  minWidth: 20,
                  padding: { top: 0, bottom: 0, left: 0, right: 0 }
                });
                lbVal.classList.add("cs-enum--value");
                iconRemove.visible = true;
                this.updateJsonUISchema();
              }
            };
            let iconRemove = [];
            iconRemove = new Icon(void 0, {
              name: "times-circle",
              visible: false,
              width: 12,
              height: 12,
              position: "absolute",
              top: 5,
              right: 5,
              fill: Theme40.colors.secondary.main,
              tooltip: {
                content: "Remove this property",
                trigger: "hover"
              }
            });
            iconRemove.onClick = () => {
              hStackEnum.clearInnerHTML();
              listEnum.splice(0, listEnum.length);
              iconRemove.visible = false;
              this.updateJsonUISchema();
            };
            const pnlFormGroupEnum = new Panel(pnlRuleSchema, { width: "calc(50% - 5px)" });
            pnlFormGroupEnum.classList.add("form-group", "cs-box--enum");
            pnlFormGroupEnum.appendChild(iconRemove);
            const lbEnum = new Label(pnlFormGroupEnum, { caption: "Enum" });
            lbEnum.classList.add("form-label");
            const pnlFormControlEnum = new Panel(pnlFormGroupEnum);
            pnlFormControlEnum.classList.add("form-control");
            pnlFormControlEnum.appendChild(hStackEnum);
            const hStackInputEnum = new HStack(pnlFormControlEnum, {
              gap: 8,
              wrap: "wrap",
              verticalAlignment: "center"
            });
            hStackInputEnum.appendChild(inputEnum);
            hStackInputEnum.appendChild(btnAdd);
          }
        };
      };
      const deleteRuleSchemaUI = () => {
        ruleConst = void 0;
        effect = "HIDE";
        ruleScope = void 0;
        ruleNegative = false;
        ruleMinimum = void 0;
        ruleMaximum = void 0;
        listEnum = [];
        pnlRuleForm.clearInnerHTML();
      };
      const resetRule = () => {
        deleteRuleSchemaUI();
        createRuleSchemaUI();
        this.updateActionsRules();
        this.updateJsonUISchema();
      };
      pnlUISchema.resetRule = () => resetRule();
    }
    const getRule = () => {
      var _a;
      let condition = {
        scope: ruleScope ? (_a = cbbRuleScope.selectedItem) == null ? void 0 : _a.value : "",
        schema: {}
      };
      let _schema = {};
      if (ruleConst !== void 0 && ruleConst !== "") {
        _schema.const = ruleConst;
      }
      if (ruleMinimum !== "" && !isNaN(Number(ruleMinimum))) {
        _schema.minimum = Number(ruleMinimum);
      }
      if (ruleMaximum !== "" && !isNaN(Number(ruleMaximum))) {
        _schema.exclusiveMaximum = Number(ruleMaximum);
      }
      if (listEnum.length) {
        _schema.enum = listEnum;
      }
      if (ruleNegative) {
        condition.schema.not = _schema;
      } else {
        condition.schema = _schema;
      }
      return {
        effect,
        condition
      };
    };
    let useOptions = false;
    let isItemsArray = false;
    let optionReadonly = false;
    let optionRadio = false;
    let currentOptions = "DEFAULT";
    let currentOptionsLayout = "VerticalLayout";
    let formOptionsDetail;
    const pnlArrayOption = new Panel(void 0, {
      margin: { top: 10 },
      visible: false
    });
    const createOptionsUI = (_scopeArr, _isItemsArray, _showRadio) => {
      isItemsArray = _isItemsArray;
      useOptions = false;
      optionReadonly = false;
      optionRadio = false;
      const pnlOptions = new Panel();
      pnlArrayOption.clearInnerHTML();
      pnlArrayOption.appendChild(pnlOptions);
      currentOptions = "DEFAULT";
      const checkboxOptions = new Checkbox(pnlOptions, {
        caption: "Options",
        checked: false
      });
      checkboxOptions.onChanged = () => {
        if (checkboxOptions.checked) {
          pnlOptions.appendChild(pnlFormOptions);
          useOptions = true;
        } else {
          pnlOptions.removeChild(pnlFormOptions);
          useOptions = false;
        }
        this.updateJsonUISchema();
      };
      const pnlFormOptions = new Panel();
      pnlFormOptions.classList.add("cs-ui--schema");
      if (!isItemsArray) {
        const pnlFormGroupReadOnly = new Panel(pnlFormOptions, { margin: { top: 5 } });
        pnlFormOptions.classList.add("form-group");
        const pnlFormControlReadOnly = new Panel(pnlFormGroupReadOnly);
        pnlFormControlReadOnly.classList.add("form-control");
        const ckbReadOnly = new Checkbox(pnlFormControlReadOnly, {
          caption: "Read Only",
          checked: false
        });
        ckbReadOnly.onChanged = () => {
          optionReadonly = ckbReadOnly.checked;
          this.updateJsonUISchema();
        };
        if (_showRadio) {
          const pnlFormGroupRadio = new Panel(pnlFormOptions, { margin: { top: 5 } });
          pnlFormOptions.classList.add("form-group");
          const pnlFormControlRadio = new Panel(pnlFormGroupRadio);
          pnlFormControlRadio.classList.add("form-control");
          const ckbRadio = new Checkbox(pnlFormControlRadio, {
            caption: "Radio",
            checked: false
          });
          ckbRadio.onChanged = () => {
            optionRadio = ckbRadio.checked;
            this.updateJsonUISchema();
          };
        }
        return;
      }
      const listOptions = [
        { label: "DEFAULT", value: "DEFAULT" },
        { label: "GENERATED", value: "GENERATED" },
        { label: "REGISTERED", value: "REGISTERED" },
        { label: "INLINED", value: "INLINED" }
      ];
      const pnlSelectOpt = new Panel(pnlFormOptions, { width: "100%" });
      const pnlFormGroupOpt = new Panel(pnlSelectOpt);
      pnlFormGroupOpt.classList.add("form-group");
      const lbOpt = new Label(pnlFormGroupOpt, { caption: "Options" });
      lbOpt.classList.add("form-label");
      const pnlFormControlOpt = new Panel(pnlFormGroupOpt);
      pnlFormControlOpt.classList.add("form-control");
      const cbbOpt = new ComboBox(pnlFormControlOpt, {
        items: listOptions,
        selectedItem: listOptions[0],
        icon: { name: "caret-down", width: "16px", height: "16px" }
      });
      cbbOpt.onChanged = () => {
        const value = cbbOpt.selectedItem.value;
        if (value === currentOptions)
          return;
        if (value === "INLINED") {
          pnlSelectOpt.width = "calc(50% - 5px)";
          pnlFormOptions.appendChild(pnlType);
          pnlFormOptions.appendChild(pnlDetail);
        } else if (currentOptions === "INLINED") {
          pnlSelectOpt.width = "100%";
          pnlFormDetail.clearInnerHTML();
          pnlFormOptions.removeChild(pnlType);
          pnlFormOptions.removeChild(pnlDetail);
        }
        currentOptions = value;
        this.updateJsonUISchema();
      };
      const listItems = dataUITypes.filter((v) => ["VerticalLayout", "HorizontalLayout"].includes(v.value));
      currentOptionsLayout = "VerticalLayout";
      const pnlType = new Panel(void 0, { width: "calc(50% - 5px)" });
      const pnlFormGroupType = new Panel(pnlType);
      pnlFormGroupType.classList.add("form-group");
      const lbType2 = new Label(pnlFormGroupType, { caption: "Type" });
      lbType2.classList.add("form-label");
      const pnlFormControlType = new Panel(pnlFormGroupType);
      pnlFormControlType.classList.add("form-control");
      const cbbType2 = new ComboBox(pnlFormControlType, {
        items: listItems,
        selectedItem: listItems[0],
        icon: { name: "caret-down", width: "16px", height: "16px" }
      });
      cbbType2.onChanged = () => {
        const value = cbbType2.selectedItem.value;
        if (value === currentOptionsLayout)
          return;
        currentOptionsLayout = value;
        this.updateJsonUISchema();
      };
      const btnAddElement2 = new Button(void 0, {
        caption: "Add Element",
        padding: { top: 6, bottom: 6, left: 16, right: 16 },
        margin: { top: 8 },
        maxWidth: 150
      });
      btnAddElement2.prepend(new Icon(void 0, {
        name: "plus",
        width: "1em",
        height: "1em",
        fill: Theme40.colors.primary.contrastText
      }));
      const pnlFormDetail = new Panel(void 0, {
        padding: { top: 10, bottom: 10, left: 10, right: 10 }
      });
      formOptionsDetail = pnlFormDetail;
      btnAddElement2.onClick = () => {
        var _a, _b;
        let scopeArr2 = _scopeArr;
        if (scopeArr2) {
          scopeArr2 = ((_b = (_a = pnlProperty.querySelector("[cbb-property]")) == null ? void 0 : _a.selectedItem) == null ? void 0 : _b.value) || "";
        }
        this.createUISchema(pnlFormDetail, currentOptionsLayout, true, scopeArr2);
        this.updateJsonUISchema();
      };
      const pnlDetail = new Panel(void 0, { width: "100%" });
      pnlDetail.appendChild(btnAddElement2);
      pnlDetail.appendChild(pnlFormDetail);
    };
    const deleteOptionsUI = () => {
      useOptions = false;
      formOptionsDetail = null;
      pnlArrayOption.clearInnerHTML();
    };
    const getOptionsUI = () => {
      if (!useOptions)
        return void 0;
      if (!isItemsArray) {
        let options = {};
        if (optionReadonly) {
          options.readonly = optionReadonly;
        }
        if (optionRadio) {
          options.format = "radio";
        }
        return options;
      }
      if (currentOptions !== "INLINED") {
        return {
          detail: currentOptions
        };
      }
      let elements = [];
      const arrElm = (formOptionsDetail == null ? void 0 : formOptionsDetail.childNodes) || [];
      for (const subElm of arrElm) {
        elements.push(subElm.getData());
      }
      return {
        detail: {
          type: currentOptionsLayout,
          elements
        }
      };
    };
    let typeOptions = [];
    if (isChildren) {
      if (parentType === "Categorization") {
        typeOptions = dataUITypes.filter((v) => v.value === "Category");
        currentLayout = "Category";
      } else {
        typeOptions = dataUITypes.filter((v) => v.value !== "Categorization" && v.value !== "Category");
      }
    } else {
      typeOptions = dataUITypes.filter((v) => v.value !== "Control" && v.value !== "Category");
    }
    const pnlCbb = new Panel(void 0, {
      width: currentLayout === "Category" ? "calc(50% - 5px)" : "100%",
      minWidth: 100
    });
    pnlCbb.classList.add("form-group");
    const lbType = new Label(pnlCbb, {
      caption: "Type"
    });
    lbType.classList.add("form-label");
    const pnlCbbType = new Panel(pnlCbb);
    pnlCbbType.classList.add("form-control");
    const cbbType = new ComboBox(pnlCbbType, {
      items: typeOptions,
      selectedItem: typeOptions.find((v) => v.value === currentLayout),
      icon: { name: "caret-down", width: "16px", height: "16px" }
    });
    cbbType.onChanged = () => {
      const selectedItem = cbbType.selectedItem;
      const value = selectedItem.value;
      if (value === currentLayout)
        return;
      if (value === "Control") {
        pnlUIElements.clearInnerHTML();
        if (!pnlLabelWrapper.hasChildNodes()) {
          pnlLabelWrapper.append(pnlLabel);
        }
        pnlLabelWrapper.visible = true;
        inputLabel.value = "";
        initInputProperty();
        pnlProperty.visible = true;
        pnlProperty.width = "calc(33.33% - 7px)";
        pnlCbb.width = "calc(33.33% - 7px)";
        pnlLabelWrapper.width = "calc(33.33% - 7px)";
        btnAddElement.visible = false;
        btnAddElement.enabled = false;
      } else {
        if (!isChildren && (currentLayout === "Categorization" || value === "Categorization")) {
          pnlUIElements.clearInnerHTML();
        }
        if (["Group", "Category"].includes(value)) {
          if (!pnlLabelWrapper.hasChildNodes()) {
            pnlLabelWrapper.append(pnlLabel);
          }
          if (!["Group", "Category"].includes(currentLayout)) {
            inputLabel.value = value;
          }
          if (!inputLabel.value) {
            inputLabel.value = value;
          }
          pnlLabelWrapper.visible = true;
          pnlLabelWrapper.width = "calc(50% - 5px)";
          pnlCbb.width = "calc(50% - 5px)";
        } else {
          pnlLabelWrapper.clearInnerHTML();
          pnlLabelWrapper.visible = false;
          pnlCbb.width = "100%";
        }
        pnlProperty.clearInnerHTML();
        pnlProperty.visible = false;
        const hasProperties = true;
        btnAddElement.visible = hasProperties && isExpanded || !isChildren;
        btnAddElement.enabled = hasProperties;
        if (currentLayout === "Control") {
          this.updateActionsItems();
        }
      }
      currentLayout = value;
      pnlArrayOption.clearInnerHTML();
      this.updateJsonUISchema();
    };
    const pnlLabelWrapper = new Panel(void 0, {
      width: "calc(50% - 5px)",
      minWidth: 100
    });
    pnlLabelWrapper.visible = currentLayout === "Category";
    const pnlLabel = new Panel();
    pnlLabel.classList.add("form-group");
    const lbLabel = new Label(pnlLabel, {
      caption: "Label"
    });
    lbLabel.classList.add("form-label");
    const inputLabel = new Input(void 0, { inputType: "text" });
    inputLabel.onChanged = () => {
      this.updateJsonUISchema();
    };
    const pnlInputLabel = new Panel(pnlLabel);
    pnlInputLabel.classList.add("form-control");
    pnlInputLabel.appendChild(inputLabel);
    if (currentLayout === "Category") {
      pnlLabelWrapper.append(pnlLabel);
    }
    let currentProperty = "";
    const pnlProperty = new Panel(void 0, {
      width: "calc(50% - 5px)",
      minWidth: 100
    });
    pnlProperty.visible = false;
    pnlProperty.classList.add("form-group");
    const initInputProperty = async () => {
      var _a, _b, _c;
      currentProperty = "";
      pnlProperty.clearInnerHTML();
      const lbProperty = new Label(pnlProperty, {
        caption: "Property"
      });
      lbProperty.classList.add("form-label");
      let scopeArrInput = scopeArr;
      if (scopeArrInput) {
        scopeArrInput = ((_c = (_b = (_a = parent.closest("[item-element]")) == null ? void 0 : _a.querySelector("[cbb-property]")) == null ? void 0 : _b.selectedItem) == null ? void 0 : _c.value) || "";
      }
      const cbbProperty = new ComboBox(void 0, {
        items: await this.getUISchemaMap(this.schema, { _scopeArr: scopeArrInput }),
        icon: { name: "caret-down", width: "16px", height: "16px" }
      });
      cbbProperty.setAttribute("cbb-property", "true");
      if (scopeArrInput) {
        cbbProperty.setAttribute("cbb-property-array", scopeArrInput);
      }
      cbbProperty.onChanged = () => {
        var _a2, _b2, _c2, _d;
        const selectedItem = cbbProperty.selectedItem;
        const value = selectedItem.value;
        if (currentProperty === value)
          return;
        iconClear.visible = true;
        deleteOptionsUI();
        createOptionsUI(value, !!(selectedItem.type === "array" && selectedItem.hasItems), !!(selectedItem.isEnum || selectedItem.isOneOf));
        cbbProperty.setAttribute("scope-element", value);
        cbbProperty.options["scope-element"] = value;
        if (scopeArr) {
          const parentScope = ((_c2 = (_b2 = (_a2 = parent.closest("[item-element]")) == null ? void 0 : _a2.querySelector("[cbb-property]")) == null ? void 0 : _b2.selectedItem) == null ? void 0 : _c2.value) || "";
          cbbProperty.setAttribute("full-scope-element", `${parentScope}${value.substring(1, value.length)}`);
          cbbProperty.options["full-scope-element"] = `${parentScope}${value.substring(1, value.length)}`;
        }
        currentProperty = value;
        const childPicked = this.pnlUISchemaBuilder.querySelectorAll(`[scope-element*='${value}/']`);
        for (const _picked of childPicked) {
          (_d = _picked.closest("[item-element]")) == null ? void 0 : _d.initInputProperty();
        }
        this.updateActionsItems();
        this.updateJsonUISchema();
      };
      const iconClear = new Icon(void 0, {
        name: "times-circle",
        width: 12,
        height: 12,
        fill: Theme40.colors.secondary.main,
        visible: false
      });
      iconClear.onClick = () => {
        iconClear.visible = false;
        deleteOptionsUI();
        initInputProperty();
        this.updateJsonUISchema();
      };
      const resetOptions = async () => {
        const selectedItem = cbbProperty.selectedItem;
        const value = selectedItem.value;
        const newSelectedItem = (await this.getUISchemaMap(this.schema, { _scopeArr: scopeArrInput, _getScope: value }))[0];
        if (newSelectedItem) {
          cbbProperty.selectedItem = newSelectedItem;
          const { type, hasItems, isOneOf, isEnum } = newSelectedItem;
          deleteOptionsUI();
          createOptionsUI(value, !!(type === "array" && hasItems), !!(isEnum || isOneOf));
        }
        this.updateActionsRules();
        this.updateJsonUISchema();
      };
      pnlUISchema.resetOptions = () => resetOptions();
      const hStackProperty = new HStack(pnlProperty, {
        gap: 4,
        verticalAlignment: "center"
      });
      hStackProperty.classList.add("form-control");
      hStackProperty.appendChild(cbbProperty);
      hStackProperty.appendChild(iconClear);
    };
    const getData = () => {
      var _a, _b, _c, _d;
      let data = {
        type: currentLayout
      };
      if (currentLayout === "Control") {
        const _scp = ((_b = (_a = pnlProperty.querySelector("[cbb-property]")) == null ? void 0 : _a.selectedItem) == null ? void 0 : _b.value) || "";
        if (!_scp)
          return null;
        data.scope = ((_d = (_c = pnlProperty.querySelector("[cbb-property]")) == null ? void 0 : _c.selectedItem) == null ? void 0 : _d.value) || "";
        if (inputLabel.value) {
          data.label = inputLabel.value;
        }
        if (useOptions) {
          const options = getOptionsUI();
          if (options && Object.keys(options).length) {
            data.options = options;
          }
        }
      } else {
        if (["Group", "Category"].includes(currentLayout)) {
          data.label = inputLabel.value || currentLayout;
        }
        let elements = [];
        const arrElm = pnlUISchema.querySelectorAll(":scope > i-panel > i-panel > [item-element]");
        for (const subElm of arrElm) {
          const data2 = subElm.getData();
          if (data2 !== null) {
            elements.push(data2);
          }
        }
        data.elements = elements;
      }
      if (useRule) {
        data.rule = getRule();
      }
      return data;
    };
    const deleteElement = () => {
      parent.removeChild(pnlUISchema);
      this.updateActionsItems();
      this.updateActionsRules();
      this.updateJsonUISchema();
    };
    pnlUISchema.getData = () => getData();
    pnlUISchema.deleteElement = () => deleteElement();
    pnlUISchema.initInputProperty = () => initInputProperty();
    pnlUISchema.deleteOptionsUI = () => deleteOptionsUI();
    let btnDelete = [];
    let btnExpand = [];
    let iconExpand = [];
    let isExpanded = false;
    const onExpand = () => {
      isExpanded = !isExpanded;
      pnlArrayOption.visible = isExpanded;
      pnlRule.visible = isExpanded;
      btnAddElement.visible = currentLayout !== "Control" && isExpanded;
      btnExpand.caption = isExpanded ? "Hide" : "Show";
      iconExpand.name = isExpanded ? "angle-up" : "angle-down";
    };
    if (isChildren) {
      btnDelete = new Button(void 0, {
        caption: "Delete",
        background: { color: `${Theme40.colors.secondary.main} !important` },
        display: "flex",
        width: "100%",
        height: 28,
        padding: { top: 6, bottom: 6, left: 12, right: 12 }
      });
      btnDelete.prepend(new Icon(void 0, {
        name: "trash",
        width: "1em",
        height: "1em",
        fill: Theme40.colors.primary.contrastText
      }));
      btnDelete.onClick = () => {
        deleteElement();
      };
      btnExpand = new Button(void 0, {
        caption: "Show",
        width: "100%",
        padding: { top: 6, bottom: 6, left: 12, right: 12 }
      });
      iconExpand = new Icon(void 0, {
        name: "angle-down",
        width: "1.125em",
        height: "1.125em",
        fill: Theme40.colors.primary.contrastText
      });
      btnExpand.prepend(iconExpand);
      btnExpand.onClick = onExpand;
    }
    const pnlDataSchema = new Panel(pnlUISchema, {
      border: { width: 1, style: "solid", color: "#DADDE1", radius: "1em" },
      padding: { top: 10, bottom: 10, left: 10, right: 10 },
      margin: { top: isChildren ? 10 : 0, bottom: isChildren ? 10 : 0 }
    });
    pnlDataSchema.classList.add("data-schema");
    const vStack = new VStack(pnlDataSchema, {
      gap: 10,
      width: "100%",
      verticalAlignment: "center"
    });
    const hStack = new HStack(vStack, {
      gap: 10,
      verticalAlignment: "center"
    });
    const vStackItem = new VStack(hStack, {
      gap: 10,
      width: isChildren ? "calc(100% - 120px)" : "100%",
      verticalAlignment: "center"
    });
    const pnlItem = new Panel(vStackItem);
    pnlItem.classList.add("cs-ui--schema");
    pnlItem.appendChild(pnlCbb);
    if (isChildren) {
      pnlItem.appendChild(pnlProperty);
      const hStackButtons = new HStack(hStack, {
        gap: 10,
        wrap: "wrap",
        width: 100
      });
      hStackButtons.appendChild(btnDelete);
      hStackButtons.appendChild(btnExpand);
    }
    pnlItem.appendChild(pnlLabelWrapper);
    pnlDataSchema.appendChild(pnlRule);
    pnlDataSchema.appendChild(pnlArrayOption);
    pnlDataSchema.appendChild(btnAddElement);
    pnlDataSchema.appendChild(pnlUIElements);
    return pnlUISchema;
  }
  initUI() {
    const gridLayout = new GridLayout(this, {
      position: "relative",
      width: "100%",
      height: "100%",
      templateColumns: ["5.5fr", "4.5fr"],
      gap: { column: 10, row: 10 }
    });
    this.pnlUISchemaBuilder = new Panel(gridLayout, {
      height: "100%",
      overflow: "auto"
    });
    this.pnlUISchemaBuilder.classList.add("cs-webkit--scrollbar");
    const pnlJsonUI = new Panel(gridLayout, { height: "100%" });
    this.txtUISchema = new Input(pnlJsonUI, {
      inputType: "textarea",
      rows: 10,
      readOnly: true,
      width: "100%"
    });
    this.txtUISchema.classList.add("cs-json--text");
  }
};
SchemaDesignerUI = __decorateClass([
  customElements2("i-schema-designer-ui")
], SchemaDesignerUI);

// packages/schema-designer/src/style/schema-designer.css.ts
var Theme41 = theme_exports.ThemeVars;
var scrollBar = {
  "&::-webkit-scrollbar-track": {
    borderRadius: "12px",
    border: "1px solid transparent",
    background: Theme41.action.hover
  },
  "&::-webkit-scrollbar": {
    width: "8px",
    backgroundColor: "unset"
  },
  "&::-webkit-scrollbar-thumb": {
    borderRadius: "12px",
    background: Theme41.action.active
  }
};
cssRule("i-schema-designer", {
  $nest: {
    "i-label": {
      padding: "5px 0"
    },
    "i-tabs": {
      $nest: {
        ".cs-webkit--scrollbar": {
          $nest: scrollBar
        }
      }
    },
    "i-input": {
      height: "30px !important",
      width: "calc(100% - 15px) !important",
      $nest: {
        'input[type="color"]': {
          width: "60px !important"
        },
        "input": {
          height: "30px !important",
          width: "100% !important",
          border: 0,
          borderBottom: `0.5px solid ${Theme41.divider}`,
          background: "transparent"
        },
        "textarea": {
          height: "100% !important",
          border: `0.5px solid ${Theme41.divider}`,
          borderRadius: "1em",
          background: "transparent",
          $nest: scrollBar
        },
        "&.cs-json--text": {
          height: "100% !important"
        }
      }
    },
    "i-combo-box": {
      height: "30px !important",
      width: "calc(100% - 15px)",
      $nest: {
        "input": {
          background: "transparent !important",
          height: "30px !important",
          border: "0 !important",
          borderBottom: `0.5px solid ${Theme41.divider} !important`
        },
        ".selection": {
          background: "transparent",
          padding: 0,
          border: 0
        },
        "span.icon-btn": {
          border: "0",
          borderBottom: `0.5px solid ${Theme41.divider}`,
          borderRadius: "0",
          height: "30px !important",
          width: "32px !important",
          padding: "3px",
          $nest: {
            "i-icon": {
              padding: "5px",
              height: "100% !important",
              width: "100% !important"
            }
          }
        }
      }
    },
    "i-grid-layout": {
      alignItems: "center"
    },
    "i-icon": {
      cursor: "pointer",
      $nest: {
        "&.disabled": {
          cursor: "default"
        }
      }
    },
    "i-button": {
      background: Theme41.colors.primary.main,
      color: Theme41.colors.primary.contrastText
    },
    ".cs-wrapper--header": {
      padding: "5px 10px",
      borderRadius: 10
    },
    ".cs-width--input": {
      width: "calc(100% - 65px) !important",
      minWidth: 100
    },
    ".cs-prefix--items": {
      $nest: {
        ".cs-box--shadow": {
          boxShadow: Theme41.shadows[2]
        }
      }
    },
    ".cs-box--enum": {
      boxShadow: Theme41.shadows[2],
      padding: "8px 16px",
      borderRadius: 8,
      minWidth: 100,
      $nest: {
        ".cs-width--input": {
          width: "calc(100% - 70px) !important"
        }
      }
    },
    ".cs-enum--value": {
      textAlign: "center",
      wordBreak: "break-word"
    },
    ".cs-ui--schema": {
      display: "flex",
      flexWrap: "wrap",
      gap: 10,
      $nest: {
        "&> i-panel": {
          minWidth: 150
        }
      }
    },
    "i-panel.invalid": {
      $nest: {
        "i-label": {
          color: "red"
        }
      }
    }
  }
});

// packages/schema-designer/src/schemaDesigner.ts
var Theme42 = theme_exports.ThemeVars;
var dataTypes = [
  { label: "string", value: "string" },
  { label: "number", value: "number" },
  { label: "integer", value: "integer" },
  { label: "boolean", value: "boolean" },
  { label: "object", value: "object" },
  { label: "array", value: "array" }
];
var formatTypes = [
  { label: "text", value: "text" },
  { label: "date", value: "date" },
  { label: "time", value: "time" },
  { label: "date-time", value: "date-time" },
  { label: "color", value: "color" },
  { label: "wallet-address", value: "wallet-address" },
  { label: "cid", value: "cid" },
  { label: "cid-v0", value: "cid-v0" },
  { label: "cid-v1", value: "cid-v1" },
  { label: "uuid", value: "uuid" }
];
var objectSchema = [
  { field: "title", type: "string" },
  { field: "description", type: "string" },
  { field: "const", type: "string" },
  { field: "default", type: "string" },
  { field: "minProperties", type: "number" },
  { field: "maxProperties", type: "number" },
  { field: "additionalProperties", type: "boolean" },
  { field: "deprecated", type: "boolean" },
  { field: "readOnly", type: "boolean" },
  { field: "writeOnly", type: "boolean" }
];
var arraySchema = [
  { field: "title", type: "string" },
  { field: "const", type: "string" },
  { field: "default", type: "string" },
  { field: "minItems", type: "number" },
  { field: "maxItems", type: "number" },
  { field: "uniqueItems", type: "boolean" },
  { field: "deprecated", type: "boolean" },
  { field: "readOnly", type: "boolean" },
  { field: "writeOnly", type: "boolean" }
];
var stringSchema = [
  { field: "pattern", type: "string" },
  { field: "format", type: "string", options: formatTypes },
  { field: "title", type: "string" },
  { field: "const", type: "string" },
  { field: "default", type: "string" },
  { field: "minLength", type: "number" },
  { field: "maxLength", type: "number" },
  { field: "deprecated", type: "boolean" },
  { field: "readOnly", type: "boolean" },
  { field: "writeOnly", type: "boolean" }
];
var numberSchema = [
  { field: "title", type: "string" },
  { field: "const", type: "number" },
  { field: "default", type: "number" },
  { field: "multipleOf", type: "number" },
  { field: "minimum", type: "number" },
  { field: "maximum", type: "number" },
  { field: "exclusiveMinimum", type: "number" },
  { field: "exclusiveMaximum", type: "number" },
  { field: "deprecated", type: "boolean" },
  { field: "readOnly", type: "boolean" },
  { field: "writeOnly", type: "boolean" }
];
var booleanSchema = [
  { field: "title", type: "string" },
  { field: "const", type: "boolean", options: [{ label: "true", value: true }, { label: "false", value: false }] },
  { field: "default", type: "boolean", options: [{ label: "true", value: true }, { label: "false", value: false }], defaultValue: { label: "", value: false } },
  { field: "deprecated", type: "boolean" },
  { field: "readOnly", type: "boolean" },
  { field: "writeOnly", type: "boolean" }
];
var controls = {};
var SchemaDesigner = class extends Container {
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  constructor(parent, options) {
    super(parent, options);
  }
  refresh() {
    super.refresh();
  }
  init() {
    super.init();
    this.initUI();
  }
  getJsonData() {
    return this.schema || {};
  }
  getJsonUI() {
    var _a;
    return ((_a = this.uiSchemaPanel) == null ? void 0 : _a.getUISchema()) || {};
  }
  async getJSON(_controls) {
    var _a;
    if (_controls === void 0)
      return void 0;
    if (_controls instanceof Control) {
      const control = _controls;
      if (control.getAttribute("ignore-field"))
        return void 0;
      if (control.tagName === "I-CHECKBOX")
        return control.checked;
      if (control.tagName === "I-COMBO-BOX") {
        return (_a = control.value) == null ? void 0 : _a.value;
      }
      if (control.tagName === "I-INPUT") {
        const inputType = control.inputType;
        if (inputType === "text")
          return control.value;
        if (inputType === "number") {
          const value = parseInt(control.value);
          return isNaN(value) ? void 0 : value;
        }
        return control.value;
      }
      return control.value;
    }
    if (_controls instanceof Array || typeof _controls !== "object") {
      return _controls;
    }
    let data = {};
    const keys = Object.keys(_controls).sort(function(a, b) {
      return _controls[a].itemIdx - _controls[b].itemIdx;
    });
    for (const key2 of keys) {
      const value = await this.getJSON(_controls[key2]);
      if (key2 === "itemIdx" && typeof value === "number") {
        continue;
      }
      if (key2 === this.uuid) {
        data["properties"] = value;
      } else if (value instanceof Array) {
        if (key2 === "prefixItems") {
          data[key2] = value.map((v) => {
            if (v.type) {
              return { type: v.type };
            }
            return { enum: v.enum };
          });
        } else if (value.length) {
          data[key2] = value;
        }
      } else if (value !== "" && value !== void 0) {
        data[key2] = value;
      }
    }
    return data;
  }
  async updateJsonData() {
    let schema = {
      type: "object",
      required: controls["required"],
      properties: await this.getJSON(controls[this.uuid])
    };
    for (const obj of objectSchema) {
      const value = await this.getJSON(controls[obj.field]);
      if (value !== "" && value !== void 0) {
        schema[obj.field] = value;
      }
    }
    this.schema = schema;
    this.txtSchema.value = JSON.stringify(schema, null, 4);
    this.uiSchemaPanel.schema = schema;
  }
  convertFieldNameToLabel(name) {
    let label = "";
    for (let i = 0; i < name.length; i++) {
      let char = name[i];
      if (i == 0) {
        label += char.toUpperCase();
        continue;
      }
      if (char == char.toUpperCase())
        label += ` ${char}`;
      else
        label += char;
    }
    return label;
  }
  generateFieldName(requiredElm) {
    while (true) {
      const fieldName = `item-${IdUtils.generateUUID(4)}`;
      const oldField = requiredElm.querySelector(`[field-required='${fieldName.toLowerCase()}']`);
      if (!oldField) {
        return fieldName;
      }
    }
  }
  createDataSchema(parent, dataType, parentFields, parentType, field, listRequired, subIdx) {
    const pnlSchema = new Panel();
    const isChildren = !!field;
    let fields = [...parentFields || []];
    let schemaDesigner = [];
    let isExpanded = true;
    let type = dataType;
    let requiredFields = [];
    let subItemIdx = 0;
    parent.append(pnlSchema);
    const pnlForm = new Panel(void 0, {
      padding: { left: 10, right: 10 }
    });
    if (parentType === "array") {
      fields.push("items");
      pnlSchema.setAttribute("role", "sub-items");
    }
    if (isChildren) {
      fields.push(this.uuid);
      fields.push(field || "");
      schemaDesigner = this.addSchemaByType(fields, dataType);
      this.updateControls(controls, [...fields, "itemIdx"], subIdx);
      pnlForm.setAttribute("role", "form-item");
      const updateParentFields = (newParentFields, parentIdx) => {
        fields.splice(parentIdx - 1, 1, newParentFields);
      };
      pnlForm.updateFields = (newParentField, parentIdx) => updateParentFields(newParentField, parentIdx);
      pnlForm.append(schemaDesigner);
    }
    const hasAction = dataType === "object" || dataType === "array";
    const btnAddItem = new Button(void 0, {
      caption: "Add Item",
      padding: { top: 6, bottom: 6, left: 16, right: 16 }
    });
    btnAddItem.prepend(new Icon(void 0, {
      name: "plus",
      width: "1em",
      height: "1em",
      fill: Theme42.colors.primary.contrastText
    }));
    const hStackActions = new HStack(void 0, {
      verticalAlignment: "center",
      wrap: "wrap",
      gap: 10,
      margin: { top: 10 }
    });
    const hStackAdd = new HStack(hStackActions, {
      verticalAlignment: "center",
      gap: 10,
      visible: hasAction
    });
    btnAddItem.onClick = async () => {
      const fieldName = this.generateFieldName(parent.querySelector("[role='fields-required']"));
      this.createDataSchema(pnlForm, "object", fields, type, fieldName, requiredFields, subItemIdx++);
      requiredFields.push(fieldName);
      if (!vStackRequired.hasChildNodes()) {
        const lb = new Label(vStackRequired, {
          caption: "Required",
          margin: { top: isChildren ? 10 : 0 }
        });
        lb.classList.add("form-label");
      }
      const chkBox = new Checkbox(void 0, {
        caption: fieldName,
        checked: true
      });
      chkBox.onChanged = () => {
        const currentFieldName = pnlGroupRequired.getAttribute("field-required");
        if (chkBox.checked) {
          if (!requiredFields.some((v) => v.toLowerCase() === currentFieldName.toLowerCase())) {
            requiredFields.push(currentFieldName);
          }
        } else {
          const idx = requiredFields.findIndex((v) => v.toLowerCase() === currentFieldName.toLowerCase());
          if (idx !== -1) {
            requiredFields.splice(idx, 1);
          }
        }
        this.updateJsonData();
      };
      const pnlGroupRequired = new Panel();
      pnlGroupRequired.classList.add("form-group");
      const pnlControl = new Panel(pnlGroupRequired);
      pnlControl.classList.add("form-control");
      pnlControl.appendChild(chkBox);
      pnlGroupRequired.setAttribute("field-required", fieldName);
      vStackRequired.appendChild(pnlGroupRequired);
      await this.updateJsonData();
      this.uiSchemaPanel.updateActionsItems();
    };
    hStackAdd.appendChild(btnAddItem);
    hStackAdd.setAttribute("role", "add-new-item");
    btnAddItem.setAttribute("action", "add-item");
    const vStackRequired = new VStack(void 0, {
      gap: 10,
      verticalAlignment: "center"
    });
    vStackRequired.setAttribute("role", "fields-required");
    this.updateControls(controls, [...fields, "required"], requiredFields);
    let btnDelete = [];
    let inputDescription = [];
    let iconRemoveDescription = [];
    let iconRenameInvalid = [];
    let btnExpand = [];
    let iconExpand = [];
    const onExpand = (src) => {
      isExpanded = !isExpanded;
      schemaDesigner.visible = isExpanded;
      vStackRequired.visible = isExpanded;
      hStackActions.visible = isExpanded;
      if (src) {
        btnExpand.caption = isExpanded ? "Hide" : "Show";
        iconExpand.name = isExpanded ? "angle-up" : "angle-down";
      }
    };
    if (isChildren) {
      btnExpand = new Button(void 0, {
        caption: "Show",
        display: "flex",
        width: "100%",
        padding: { top: 6, bottom: 6, left: 12, right: 12 }
      });
      iconExpand = new Icon(void 0, {
        name: "angle-down",
        width: "1.125em",
        height: "1.125em",
        fill: Theme42.colors.primary.contrastText
      });
      btnExpand.prepend(iconExpand);
      btnExpand.onClick = onExpand;
      inputDescription = new Input(void 0, {
        inputType: "text"
      });
      iconRemoveDescription = new Icon(void 0, {
        name: "times-circle",
        visible: false,
        width: 12,
        height: 12,
        position: "absolute",
        top: 5,
        right: 5,
        fill: Theme42.colors.secondary.main,
        tooltip: {
          content: "Remove this property",
          trigger: "hover"
        }
      });
      iconRemoveDescription.onClick = () => {
        iconRemoveDescription.visible = false;
        inputDescription.value = "";
        this.updateJsonData();
      };
      this.updateControls(controls, [...fields, "description"], inputDescription);
      inputDescription.onChanged = () => {
        iconRemoveDescription.visible = !!inputDescription.value;
        this.updateJsonData();
      };
      iconRenameInvalid = new Icon(void 0, {
        name: "exclamation-circle",
        width: 12,
        height: 12,
        fill: Theme42.colors.secondary.main,
        tooltip: {
          content: "Invalid field",
          trigger: "hover"
        },
        visible: false
      });
      btnDelete = new Button(void 0, {
        caption: "Delete",
        background: { color: `${Theme42.colors.secondary.main} !important` },
        display: "flex",
        width: "100%",
        padding: { top: 6, bottom: 6, left: 12, right: 12 }
      });
      btnDelete.prepend(new Icon(void 0, {
        name: "trash",
        width: "1em",
        height: "1em",
        fill: Theme42.colors.primary.contrastText
      }));
      btnDelete.setAttribute("action", "delete");
      btnDelete.onClick = async () => {
        parent.removeChild(pnlSchema);
        this.updateControls(controls, fields);
        const elm = parent.querySelector("[role='fields-required']");
        if (elm) {
          const fieldName = fields[fields.length - 1] || "";
          if (listRequired && listRequired.length) {
            const idx = listRequired.findIndex((v) => v.toLowerCase() === fieldName.toLowerCase());
            if (idx !== -1) {
              listRequired.splice(idx, 1);
            }
          }
          const fieldRequired = elm.querySelector(`[field-required='${fieldName.toLowerCase()}']`);
          if (fieldRequired) {
            elm.removeChild(fieldRequired);
            if (elm.childNodes.length === 1) {
              elm.clearInnerHTML();
            }
          }
        }
        await this.updateJsonData();
        let deleteFields = [];
        for (const field2 of fields) {
          if (deleteFields.length > 1 && deleteFields[deleteFields.length - 1] !== this.uuid && field2 !== this.uuid) {
            continue;
          }
          deleteFields.push(field2);
        }
        this.uiSchemaPanel.deleteUISchema(deleteFields);
        this.uiSchemaPanel.updateActionsItems();
      };
      onExpand();
    }
    pnlForm.append(vStackRequired);
    pnlForm.append(hStackActions);
    const pnlSchemaItem = new Panel(pnlSchema, {
      border: { width: 1, style: "solid", color: "#DADDE1", radius: "1em" },
      padding: { top: 10, bottom: 10, left: 10, right: 10 },
      margin: { top: isChildren ? 20 : 0 }
    });
    pnlSchemaItem.classList.add("data-schema");
    const vStack = new VStack(pnlSchemaItem, { gap: 10 });
    pnlSchemaItem.appendChild(pnlForm);
    if (!isChildren) {
      const hStack = new HStack(vStack, {
        gap: 10,
        justifyContent: "start",
        alignItems: "center"
      });
      const hStackRoot = new HStack(hStack, {
        gap: 10,
        verticalAlignment: "center"
      });
      hStackRoot.classList.add("cs-wrapper--header");
      new Label(hStackRoot, {
        caption: "Root",
        font: { size: "1rem", bold: true }
      });
      new Label(hStackRoot, {
        caption: "object",
        font: { size: "1rem" },
        opacity: 0.65
      });
    } else {
      const hStack = new HStack(vStack, {
        gap: 10,
        verticalAlignment: "center"
      });
      const hStackChild = new HStack(hStack, {
        gap: 10,
        wrap: "wrap",
        width: "calc(100% - 120px)",
        padding: { left: 10, right: 10 }
      });
      const pnlPropertyGroup = new Panel(hStackChild, {
        width: "calc(33.33% - 7px)",
        minWidth: 100
      });
      pnlPropertyGroup.classList.add("form-group");
      const lbPropertyName = new Label(pnlPropertyGroup, {
        caption: "Property Name"
      });
      lbPropertyName.classList.add("form-label");
      const pnlPropertyControl = new Panel(pnlPropertyGroup);
      pnlPropertyControl.classList.add("form-control");
      const inputPropertyName = new Input(pnlPropertyControl, {
        inputType: "text",
        value: field
      });
      pnlPropertyControl.appendChild(iconRenameInvalid);
      inputPropertyName.onChanged = async () => {
        const currentFieldName = inputPropertyName.value;
        if (currentFieldName && /^[a-zA-Z0-9_-]*$/.test(currentFieldName)) {
          const requiredElm = parent.querySelector("[role='fields-required']");
          const oldField = requiredElm.querySelector(`[field-required='${currentFieldName.toLowerCase()}']`);
          if (oldField) {
            iconRenameInvalid.visible = true;
            iconRenameInvalid.tooltip.content = "Duplicate field";
          } else {
            iconRenameInvalid.visible = false;
            const lastIndex2 = fields.length - 1;
            const oldControl = this.getControlByPath(fields);
            const oldFieldName = fields[lastIndex2];
            const oldFields = [...fields];
            this.updateControls(controls, [...fields]);
            fields.splice(lastIndex2, 1);
            fields.push(currentFieldName);
            this.updateControls(controls, [...fields], oldControl);
            const childForms = pnlForm.querySelectorAll("[role='form-item']");
            for (const chidlForm of childForms) {
              chidlForm.updateFields(currentFieldName, fields.length);
            }
            const requiredElm2 = parent.querySelector("[role='fields-required']");
            if (requiredElm2) {
              if (listRequired && listRequired.length) {
                const idx = listRequired.findIndex((v) => v.toLowerCase() === oldFieldName.toLowerCase());
                if (idx !== -1) {
                  listRequired.splice(idx, 1, currentFieldName);
                }
              }
              const fieldRequired = requiredElm2.querySelector(`[field-required='${oldFieldName.toLowerCase()}']`);
              if (fieldRequired) {
                fieldRequired.setAttribute("field-required", currentFieldName.toLowerCase());
                fieldRequired.options["field-required"] = currentFieldName.toLowerCase();
                fieldRequired.firstChild.firstChild.caption = currentFieldName;
              }
            }
            await this.updateJsonData();
            this.uiSchemaPanel.updateUISchemaItemsByRename(oldFields, fields);
          }
        } else {
          iconRenameInvalid.visible = true;
          iconRenameInvalid.tooltip.content = "Invalid field";
        }
      };
      const pnlTypeGroup = new Panel(hStackChild, {
        width: "calc(33.33% - 7px)",
        minWidth: 100
      });
      pnlPropertyGroup.classList.add("form-group");
      const lbTypeName = new Label(pnlTypeGroup, {
        caption: "Type"
      });
      lbTypeName.classList.add("form-label");
      const pnlTypeControl = new Panel(pnlTypeGroup);
      pnlTypeControl.classList.add("form-control");
      const cbbType = new ComboBox(pnlTypeControl, {
        items: dataTypes,
        selectedItem: dataTypes.find((v) => v.value === "object"),
        icon: { name: "caret-down", width: "16px", height: "16px" }
      });
      cbbType.onChanged = async () => {
        const selectedItem = cbbType.selectedItem;
        const value = selectedItem.value;
        if (value === type)
          return;
        requiredFields = [];
        pnlForm.clearInnerHTML();
        schemaDesigner.clearInnerHTML();
        schemaDesigner = this.addSchemaByType(fields, value);
        schemaDesigner.visible = isExpanded;
        vStackRequired.clearInnerHTML();
        this.updateControls(controls, [...fields, "required"], requiredFields);
        this.updateControls(controls, [...fields, "description"], inputDescription);
        pnlForm.append(schemaDesigner);
        pnlForm.append(vStackRequired);
        pnlForm.append(hStackActions);
        if (value === "object" || value === "array") {
          btnAddItem.enabled = true;
          hStackAdd.visible = true;
        } else {
          btnAddItem.enabled = false;
          hStackAdd.visible = false;
        }
        type = value;
        await this.updateJsonData();
        this.uiSchemaPanel.deleteUISchema(fields, true);
        this.uiSchemaPanel.updateUISchemaByType(fields);
      };
      const pnlDescriptionGroup = new Panel(hStackChild, {
        width: "calc(33.33% - 7px)",
        minWidth: 100
      });
      pnlDescriptionGroup.classList.add("form-group");
      const lbDescriptionName = new Label(pnlDescriptionGroup, {
        caption: "Description"
      });
      lbDescriptionName.classList.add("form-label");
      const pnlDescriptionControl = new Panel(pnlDescriptionGroup);
      pnlDescriptionControl.classList.add("form-control");
      pnlDescriptionControl.appendChild(inputDescription);
      pnlDescriptionControl.appendChild(iconRemoveDescription);
      const hStackGroupBtn = new HStack(hStack, {
        gap: 10,
        width: 100,
        wrap: "wrap",
        verticalAlignment: "center"
      });
      hStackGroupBtn.appendChild(btnDelete);
      hStackGroupBtn.appendChild(btnExpand);
    }
  }
  renderEnum(parentFields, type, parentList) {
    let listEnum = [];
    if (parentList) {
      listEnum = parentList;
    } else {
      this.updateControls(controls, [...parentFields, "enum"], listEnum);
    }
    const hStackEnum = new HStack(void 0, {
      gap: 8,
      verticalAlignment: "center",
      wrap: "wrap"
    });
    hStackEnum.setAttribute("role", "fields-enum");
    const btnAdd = new Button(void 0, {
      caption: "Add",
      enabled: false,
      padding: { top: 6, bottom: 6, left: 16, right: 16 }
    });
    const inputEnum = new Input(void 0, {
      inputType: type
    });
    inputEnum.classList.add("cs-width--input");
    inputEnum.onChanged = () => {
      const val = inputEnum.value;
      if (type === "number") {
        btnAdd.enabled = val !== "" && !isNaN(Number(val)) && !listEnum.some((v) => v === Number(val));
      } else {
        btnAdd.enabled = val && !listEnum.some((v) => v.toString().toLowerCase() === val.toString().toLowerCase());
      }
    };
    btnAdd.onClick = async () => {
      const val = inputEnum.value;
      if ((type === "number" && !isNaN(val) || type === "text" && val) && !listEnum.some((v) => v.toString().toLowerCase() === val.toString().toLowerCase())) {
        listEnum.push(type === "number" ? Number(val) : val);
        inputEnum.value = "";
        btnAdd.enabled = false;
        const pnlEnum = new Panel(hStackEnum, {
          position: "relative",
          display: "flex",
          padding: { top: 8, bottom: 8, left: 16, right: 16 },
          border: { radius: 8 },
          background: { color: Theme42.action.selected }
        });
        const iconTimes = new Icon(pnlEnum, {
          name: "times",
          width: 14,
          height: 14,
          fill: Theme42.colors.secondary.main,
          position: "absolute",
          right: 2,
          top: 2
        });
        iconTimes.onClick = async () => {
          const idx = listEnum.findIndex((v) => v.toString().toLowerCase() === val.toString().toLowerCase());
          listEnum.splice(idx, 1);
          if (!parentList) {
            iconRemove.visible = !!listEnum.length;
          }
          hStackEnum.removeChild(pnlEnum);
          await this.updateJsonData();
          this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
        };
        const lbVal = new Label(pnlEnum, {
          caption: val,
          font: { size: "12px" },
          minWidth: 20,
          padding: { top: 0, bottom: 0, left: 0, right: 0 }
        });
        lbVal.classList.add("cs-enum--value");
        if (!parentList) {
          iconRemove.visible = true;
        }
        await this.updateJsonData();
        this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
      }
    };
    const pnlEnumGroup = new Panel(void 0, {
      width: "100%",
      margin: { top: 8 }
    });
    pnlEnumGroup.classList.add("form-group");
    let iconRemove = [];
    if (!parentList) {
      iconRemove = new Icon(void 0, {
        name: "times-circle",
        visible: false,
        width: 12,
        height: 12,
        position: "absolute",
        top: 5,
        right: 5,
        fill: Theme42.colors.secondary.main,
        tooltip: {
          content: "Remove this property",
          trigger: "hover"
        }
      });
      iconRemove.onClick = async () => {
        hStackEnum.clearInnerHTML();
        listEnum.splice(0, listEnum.length);
        iconRemove.visible = false;
        await this.updateJsonData();
        this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
      };
      pnlEnumGroup.classList.add("cs-box--enum");
      pnlEnumGroup.appendChild(iconRemove);
    }
    const lbEnum = new Label(pnlEnumGroup, {
      caption: "Enum"
    });
    lbEnum.classList.add("form-label");
    const pnlEnumControl = new Panel(pnlEnumGroup);
    pnlEnumControl.classList.add("form-control");
    pnlEnumControl.appendChild(hStackEnum);
    const hStackInputEnum = new Panel(pnlEnumControl, {
      gap: 8,
      margin: { top: 8 },
      wrap: "wrap",
      verticalAlignment: "center"
    });
    hStackInputEnum.appendChild(inputEnum);
    hStackInputEnum.appendChild(btnAdd);
    return pnlEnumGroup;
  }
  renderOneOf(parentFields, type, parentList) {
    let listOneOf = [];
    if (parentList) {
      listOneOf = parentList;
    } else {
      this.updateControls(controls, [...parentFields, "oneOf"], listOneOf);
    }
    const hStackOneOf = new HStack(void 0, {
      gap: 8,
      verticalAlignment: "center",
      wrap: "wrap"
    });
    hStackOneOf.setAttribute("role", "fields-one-of");
    const btnAdd = new Button(void 0, {
      caption: "Add",
      enabled: false,
      padding: { top: 6, bottom: 6, left: 16, right: 16 },
      maxHeight: 25
    });
    const inputOneOfTitle = new Input(void 0, {
      inputType: "text"
    });
    const inputOneOfValue = new Input(void 0, {
      inputType: type
    });
    inputOneOfTitle.onChanged = () => {
      const title = inputOneOfTitle.value || "";
      const val = inputOneOfValue.value;
      if (type === "number") {
        btnAdd.enabled = title && val !== "" && !isNaN(Number(val)) && !listOneOf.some((v) => v.const === Number(val) || v.title.toLowerCase() === title.toLowerCase());
      } else {
        btnAdd.enabled = title && val && !listOneOf.some((v) => v.const.toString().toLowerCase() === val.toString().toLowerCase() || v.title.toLowerCase() === title.toLowerCase());
      }
    };
    inputOneOfValue.onChanged = () => {
      const title = inputOneOfTitle.value;
      const val = inputOneOfValue.value;
      if (type === "number") {
        btnAdd.enabled = title && val !== "" && !isNaN(Number(val)) && !listOneOf.some((v) => v.const === Number(val) || v.title.toLowerCase() === title.toLowerCase());
      } else {
        btnAdd.enabled = title && val && !listOneOf.some((v) => v.const.toString().toLowerCase() === val.toString().toLowerCase() || v.title.toLowerCase() === title.toLowerCase());
      }
    };
    btnAdd.onClick = async () => {
      const title = inputOneOfTitle.value;
      const val = inputOneOfValue.value;
      if ((type === "number" && !isNaN(val) || type === "text" && val) && !listOneOf.some((v) => v.const.toString().toLowerCase() === val.toString().toLowerCase())) {
        listOneOf.push({ title, const: type === "number" ? Number(val) : val });
        inputOneOfTitle.value = "";
        inputOneOfValue.value = "";
        btnAdd.enabled = false;
        const pnlEnum = new Panel(hStackOneOf, {
          position: "relative",
          display: "flex",
          padding: { top: 8, bottom: 8, left: 16, right: 16 },
          border: { radius: 8 },
          background: { color: Theme42.action.selected }
        });
        const iconTimes = new Icon(pnlEnum, {
          name: "times",
          width: 14,
          height: 14,
          fill: Theme42.colors.secondary.main,
          position: "absolute",
          right: 2,
          top: 2
        });
        iconTimes.onClick = async () => {
          const idx = listOneOf.findIndex((v) => v.const.toString().toLowerCase() === val.toString().toLowerCase());
          listOneOf.splice(idx, 1);
          if (!parentList) {
            iconRemove.visible = !!listOneOf.length;
          }
          hStackOneOf.removeChild(pnlEnum);
          await this.updateJsonData();
          this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
        };
        const lbVal = new Label(pnlEnum, {
          caption: title,
          font: { size: "12px" },
          minWidth: 20,
          padding: { top: 0, bottom: 0, left: 0, right: 0 }
        });
        lbVal.classList.add("cs-enum--value");
        if (!parentList) {
          iconRemove.visible = true;
        }
        await this.updateJsonData();
        this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
      }
    };
    let iconRemove = [];
    if (!parentList) {
      iconRemove = new Icon(void 0, {
        name: "times-circle",
        visible: false,
        width: 12,
        height: 12,
        position: "absolute",
        top: 5,
        right: 5,
        fill: Theme42.colors.secondary.main,
        tooltip: {
          content: "Remove this property",
          trigger: "hover"
        }
      });
      iconRemove.onClick = async () => {
        hStackOneOf.clearInnerHTML();
        listOneOf.splice(0, listOneOf.length);
        iconRemove.visible = false;
        await this.updateJsonData();
        this.uiSchemaPanel.updateUISchemaByType([...parentFields], true);
      };
    }
    const pnlOneOfGroup = new Panel(void 0, {
      margin: { top: 8 }
    });
    pnlOneOfGroup.classList.add("`form-group");
    if (!parentList) {
      pnlOneOfGroup.classList.add("cs-box--enum");
    }
    pnlOneOfGroup.appendChild(iconRemove);
    const lbOneOf = new Label(pnlOneOfGroup, {
      caption: "One Of"
    });
    lbOneOf.classList.add("form-label");
    const pnlOneOfControl = new Panel(pnlOneOfGroup);
    pnlOneOfControl.classList.add("form-control");
    pnlOneOfControl.appendChild(hStackOneOf);
    const hStackOneOfInput = new HStack(pnlOneOfControl, {
      gap: 8,
      margin: { top: 8 },
      wrap: "wrap",
      verticalAlignment: "end"
    });
    const pnlOneOfInput = new Panel(hStackOneOfInput, {
      margin: { top: 8 }
    });
    pnlOneOfInput.classList.add("form-group", "cs-width--input");
    const lbTitle = new Label(pnlOneOfInput, {
      caption: "Title"
    });
    const pnlControlTitle = new Panel(pnlOneOfInput);
    pnlControlTitle.classList.add("form-control");
    pnlControlTitle.appendChild(inputOneOfTitle);
    const lbConst = new Label(pnlOneOfInput, {
      caption: "Const"
    });
    const pnlControlConst = new Panel(pnlOneOfInput);
    pnlControlConst.classList.add("form-control");
    pnlControlConst.appendChild(inputOneOfValue);
    hStackOneOfInput.appendChild(btnAdd);
    return pnlOneOfGroup;
  }
  renderPrefixItems(parentFields) {
    let listType = [];
    this.updateControls(controls, [...parentFields, "prefixItems"], listType);
    const vStackPrefixItems = new VStack(void 0, {
      gap: 8,
      verticalAlignment: "center",
      wrap: "wrap",
      minWidth: 180
    });
    vStackPrefixItems.setAttribute("role", "prefix-items");
    const hStackAdd = new HStack(vStackPrefixItems, {
      verticalAlignment: "center",
      gap: 10
    });
    const options = [
      { label: "string", value: "string" },
      { label: "number", value: "number" },
      { label: "enum", value: "enum" }
    ];
    const cbbType = new ComboBox(hStackAdd, {
      items: options,
      selectedItem: options[0],
      icon: { name: "caret-down", width: "16px", height: "16px" },
      minWidth: 180
    });
    cbbType.style.width = "calc(100% - 70px)";
    const btnAdd = new Button(hStackAdd, {
      caption: "Add",
      padding: { top: 6, bottom: 6, left: 16, right: 16 }
    });
    btnAdd.onClick = () => {
      const val = cbbType.selectedItem.value;
      const idx = listType.length;
      let pnlEnum;
      const pnlType = new Panel(void 0, {
        position: "relative",
        display: "flex",
        padding: { top: 8, bottom: 8, left: 16, right: 16 },
        border: { radius: 8 }
      });
      pnlType.classList.add("cs-box--shadow");
      const iconTimes = new Icon(pnlType, {
        name: "times",
        width: 14,
        height: 14,
        fill: Theme42.colors.secondary.main,
        position: "absolute",
        right: 4,
        top: 4
      });
      iconTimes.onClick = () => {
        const _idx = listType.findIndex((v) => v.idx === idx);
        listType.splice(_idx, 1);
        vStackPrefixItems.removeChild(pnlType);
        this.updateJsonData();
      };
      if (val !== "enum") {
        listType.push({ type: val, idx });
        const lbVal = new Label(pnlType, {
          caption: val,
          font: { size: "12px" },
          minWidth: 20,
          padding: { top: 0, bottom: 0, left: 0, right: 0 }
        });
        lbVal.classList.add("cs-enum--value");
      } else {
        listType.push({ enum: [], idx });
        pnlEnum = this.renderEnum([], "text", listType[idx].enum);
      }
      if (pnlEnum) {
        pnlType.appendChild(pnlEnum);
      }
      vStackPrefixItems.appendChild(pnlType);
      this.updateJsonData();
    };
    const vStackPrefix = new VStack(void 0, {
      gap: 8,
      verticalAlignment: "center"
    });
    vStackPrefix.classList.add("cs-prefix--items");
    const pnlFormGroup = new Panel(vStackPrefix);
    pnlFormGroup.classList.add("form-group");
    const lbPrefix = new Label(pnlFormGroup, {
      caption: "Prefix Items"
    });
    lbPrefix.classList.add("form-label");
    const pnlPrefixControl = new Panel(pnlFormGroup);
    pnlPrefixControl.classList.add("form-control");
    const hStackPrefixInput = new HStack(pnlPrefixControl, {
      gap: 8,
      wrap: "wrap",
      verticalAlignment: "center"
    });
    hStackPrefixInput.appendChild(cbbType);
    hStackPrefixInput.appendChild(btnAdd);
    pnlPrefixControl.appendChild(vStackPrefixItems);
    return vStackPrefix;
  }
  updateControls(obj, keyPath, control) {
    let lastKeyIndex = keyPath.length - 1;
    for (let i = 0; i < lastKeyIndex; ++i) {
      const key2 = keyPath[i];
      if (!(key2 in obj)) {
        obj[key2] = {};
      }
      obj = obj[keyPath[i]];
    }
    if (control !== void 0) {
      obj[keyPath[lastKeyIndex]] = control;
    } else {
      delete obj[keyPath[lastKeyIndex]];
    }
  }
  getControlByPath(keyPath) {
    let obj = Object(controls);
    for (const key2 of keyPath) {
      if (!(key2 in obj)) {
        obj[key2] = {};
      }
      obj = obj[key2];
    }
    return obj;
  }
  renderSchema(parentFields, schema, propType) {
    let _controls = {};
    this.updateControls(controls, parentFields, _controls);
    _controls["type"] = propType;
    const vStack = new VStack(void 0, { gap: 10 });
    if (parentFields.length) {
      new Label(vStack, {
        caption: "Advanced options",
        font: { size: "16px", color: Theme42.colors.primary.main }
      });
    }
    const gridLayout = new GridLayout(vStack, {
      templateColumns: ["1fr", "1fr"],
      gap: { column: 10, row: 10 }
    });
    for (const item of schema) {
      const { field, type, options, defaultValue } = item;
      const notCheckbox = type !== "boolean" || type === "boolean" && options;
      const fieldName = this.convertFieldNameToLabel(field);
      const pnlFormGroup = new Panel(gridLayout, {
        margin: { top: notCheckbox ? void 0 : "auto" }
      });
      if (notCheckbox) {
        const lbFieldName = new Label(pnlFormGroup, { caption: fieldName });
        lbFieldName.classList.add("form-label");
      }
      const pnlFormControl = new Panel(pnlFormGroup, { margin: { top: notCheckbox ? void 0 : 10 } });
      let controlElm;
      if (options) {
        controlElm = new ComboBox(pnlFormControl, {
          items: options,
          selectedItem: defaultValue,
          icon: { name: "caret-down", width: "16px", height: "16px" }
        });
      } else if (type === "boolean") {
        controlElm = new Checkbox(pnlFormControl, {
          caption: fieldName,
          checked: !!defaultValue
        });
      } else {
        controlElm = new Input(pnlFormControl, {
          inputType: type === "number" ? "number" : "text",
          value: defaultValue || ""
        });
      }
      _controls[field] = controlElm;
      controlElm.options["ignore-field"] = true;
      const iconRemove = new Icon(pnlFormControl, {
        name: "times-circle",
        visible: false,
        width: 12,
        height: 12,
        position: notCheckbox ? "absolute" : "relative",
        fill: Theme42.colors.secondary.main,
        tooltip: {
          content: "Remove this property",
          trigger: "hover"
        }
      });
      if (notCheckbox) {
        iconRemove.top = 10;
        iconRemove.right = 0;
      } else {
        iconRemove.margin = { left: 4 };
        iconRemove.style.verticalAlign = "-2px";
      }
      iconRemove.onClick = () => {
        if (controlElm.tagName === "I-CHECKBOX") {
          controlElm.checked = false;
        } else if (controlElm.tagName === "I-COMBO-BOX") {
          controlElm.value = options && options[0];
        } else if (controlElm.tagName === "I-INPUT") {
          controlElm.value = "";
        }
        controlElm.options["ignore-field"] = true;
        iconRemove.visible = false;
        this.updateJsonData();
      };
      controlElm.onChanged = () => {
        iconRemove.visible = true;
        controlElm.options["ignore-field"] = false;
        if (controlElm.tagName === "I-INPUT" && controlElm.value === "") {
          iconRemove.visible = false;
        }
        this.updateJsonData();
      };
    }
    return vStack;
  }
  addSchemaByType(parentFields, dataType) {
    switch (dataType) {
      case "object":
        return this.renderObjectSchema(parentFields, dataType);
      case "array":
        return this.renderArraySchema(parentFields, dataType);
      case "string":
        return this.renderStringSchema(parentFields, dataType);
      case "number":
      case "integer":
        return this.renderNumberSchema(parentFields, dataType);
      case "boolean":
        return this.renderBooleanSchema(parentFields, dataType);
      default:
        return [];
    }
  }
  renderObjectSchema(parentFields, dataType) {
    const pnlObjectSchema = new Panel(void 0, {
      margin: { top: parentFields.length ? 20 : 0 }
    });
    pnlObjectSchema.appendChild(this.renderSchema(parentFields, objectSchema, dataType));
    return pnlObjectSchema;
  }
  renderStringSchema(parentFields, dataType) {
    const pnlStringSchema = new Panel(void 0, {
      margin: { top: 20 }
    });
    pnlStringSchema.appendChild(this.renderSchema(parentFields, stringSchema, dataType));
    const gridLayout = new GridLayout(pnlStringSchema, {
      templateColumns: ["1fr", "1fr"],
      verticalAlignment: "start",
      gap: { column: 10, row: 10 }
    });
    gridLayout.appendChild(this.renderOneOf(parentFields, "text"));
    gridLayout.appendChild(this.renderEnum(parentFields, "text"));
    return pnlStringSchema;
  }
  renderNumberSchema(parentFields, dataType) {
    const pnlNumberSchema = new Panel(void 0, {
      margin: { top: 20 }
    });
    pnlNumberSchema.appendChild(this.renderSchema(parentFields, numberSchema, dataType));
    const gridLayout = new GridLayout(pnlNumberSchema, {
      templateColumns: ["1fr", "1fr"],
      verticalAlignment: "start",
      gap: { column: 10, row: 10 }
    });
    gridLayout.appendChild(this.renderOneOf(parentFields, "number"));
    gridLayout.appendChild(this.renderEnum(parentFields, "number"));
    return pnlNumberSchema;
  }
  renderBooleanSchema(parentFields, dataType) {
    const pnlBooleanSchema = new Panel(void 0, {
      margin: { top: 20 }
    });
    pnlBooleanSchema.appendChild(this.renderSchema(parentFields, booleanSchema, dataType));
    return pnlBooleanSchema;
  }
  renderArraySchema(parentFields, dataType) {
    const pnlPrefixItems = new Panel(void 0, {
      width: "calc(50% - 5px)"
    });
    let itemsType = "object";
    const options = [
      { label: "object", value: "object" },
      { label: "string", value: "string" },
      { label: "number", value: "number" },
      { label: "false", value: false }
    ];
    const cbbItemsType = new ComboBox(void 0, {
      items: options,
      selectedItem: options[0],
      icon: { name: "caret-down", width: "16px", height: "16px" }
    });
    const setEnableActions = (parentElm, enabled) => {
      if (!parentElm)
        return;
      const hStackAdd = parentElm.querySelector(`[role='add-new-item']`);
      if (hStackAdd) {
        const btnAddItem = hStackAdd.querySelector(`[action='add-field']`);
        hStackAdd.visible = enabled;
        if (btnAddItem) {
          btnAddItem.enabled = enabled;
        }
      }
    };
    cbbItemsType.onChanged = async () => {
      const selectedItem = cbbItemsType.selectedItem;
      const value = selectedItem.value;
      if (itemsType !== value) {
        const parentElm = cbbItemsType.closest(".data-schema");
        const subItemsElm = parentElm.querySelectorAll(":scope > i-panel > [role='sub-items']");
        for (const subElm of subItemsElm) {
          const btnDelete = subElm.querySelector("[action='delete']");
          if (btnDelete) {
            btnDelete.click();
          }
        }
        if (value === "object") {
          pnlPrefixItems.clearInnerHTML();
          setEnableActions(parentElm, true);
          this.updateControls(controls, [...parentFields, "prefixItems"]);
          pnlPrefixItems.visible = false;
          this.updateControls(controls, [...parentFields, "items"], { "type": value });
        } else {
          setEnableActions(parentElm, false);
          pnlPrefixItems.visible = true;
          if (value.toString() === "false") {
            this.updateControls(controls, [...parentFields, "items"], false);
          } else {
            this.updateControls(controls, [...parentFields, "items"], { "type": value });
            if (itemsType === "object") {
              pnlPrefixItems.clearInnerHTML();
              pnlPrefixItems.appendChild(this.renderPrefixItems(parentFields));
            }
          }
        }
        itemsType = value;
        await this.updateJsonData();
        this.uiSchemaPanel.deleteUISchema(parentFields, true);
      }
    };
    const formArr = this.renderSchema(parentFields, arraySchema, dataType);
    this.updateControls(controls, [...parentFields, "items", "type"], cbbItemsType);
    const pnlArrSchema = new Panel(void 0, {
      margin: { top: 20 }
    });
    pnlArrSchema.appendChild(formArr);
    const hStackArr = new HStack(pnlArrSchema, {
      gap: 10,
      margin: { top: 10 },
      width: "100%"
    });
    const pnlFormGroup = new Panel(hStackArr, {
      width: "calc(50% - 5px)",
      minWidth: 180
    });
    pnlFormGroup.classList.add("form-group");
    const lbItems = new Label(pnlFormGroup, {
      caption: "Items"
    });
    lbItems.classList.add("form-label");
    const pnlItems = new Panel(pnlFormGroup);
    pnlItems.classList.add("form-control");
    pnlItems.appendChild(cbbItemsType);
    hStackArr.appendChild(pnlPrefixItems);
    return pnlArrSchema;
  }
  async initUI() {
    const panel = await Panel.create({
      width: "100%",
      height: "100%",
      padding: { top: 12, bottom: 12, left: 16, right: 16 }
    }, this);
    const tabs = await Tabs.create({
      mode: "horizontal"
    }, panel);
    const pnlData = await Panel.create({ height: "100%" });
    this.pnlUISchema = await Panel.create({ height: "100%" });
    tabs.add({ caption: "Data Schema", children: pnlData });
    tabs.add({ caption: "UI Schema (Optional)", children: this.pnlUISchema });
    tabs.activeTabIndex = 0;
    const gridLayout = await GridLayout.create({
      position: "relative",
      width: "100%",
      height: "100%",
      templateColumns: ["5.5fr", "4.5fr"],
      gap: { column: 10, row: 10 }
    }, pnlData);
    this.pnlSchemaBuilder = await Panel.create({
      height: "100%",
      overflow: "auto"
    }, gridLayout);
    this.pnlSchemaBuilder.classList.add("cs-webkit--scrollbar");
    const pnlJsonData = await Panel.create({ height: "100%" }, gridLayout);
    this.txtSchema = await Input.create({
      inputType: "textarea",
      rows: 10,
      readOnly: true,
      width: "100%"
    }, pnlJsonData);
    this.txtSchema.classList.add("cs-json--text");
    this.uiSchemaPanel = new SchemaDesignerUI(this.pnlUISchema);
    this.createDataSchema(this.pnlSchemaBuilder, "object");
    this.updateJsonData();
  }
};
SchemaDesigner = __decorateClass([
  customElements2("i-schema-designer")
], SchemaDesigner);

// packages/navigator/src/style/navigator.css.ts
var Theme43 = theme_exports.ThemeVars;
cssRule("i-nav", {
  border: `1px solid ${Theme43.divider}`,
  $nest: {
    "> i-vstack": {
      alignItems: "center",
      height: "100%",
      $nest: {
        ".search-container": {
          width: "100%",
          padding: 10,
          borderBottom: `1px solid ${Theme43.divider}`,
          alignItems: "center",
          gap: 5,
          $nest: {
            ".clear": {
              cursor: "pointer"
            },
            "i-input": {
              $nest: {
                "input": {
                  background: "transparent",
                  border: "0",
                  borderBottom: `1px solid ${Theme43.divider}`
                }
              }
            }
          }
        },
        ".nav-wrapper": {
          width: "100%",
          overflow: "auto",
          paddingBottom: 50
        }
      }
    },
    "i-nav-item": {
      cursor: "pointer",
      background: Theme43.background.main,
      borderLeft: "3px solid transparent",
      borderBottom: `1px solid ${Theme43.divider}`,
      $nest: {
        "> i-grid-layout": {
          height: 50,
          padding: 10,
          gap: 5,
          alignItems: "center"
        },
        "i-icon": {
          height: Theme43.typography.fontSize,
          width: Theme43.typography.fontSize,
          fill: Theme43.colors.primary.main
        },
        "&.active": {
          color: Theme43.colors.primary.contrastText,
          background: Theme43.colors.primary.main,
          borderLeft: `3px solid ${Theme43.colors.primary.main}`
        }
      }
    }
  }
});

// packages/navigator/src/navigator.ts
var Nav = class extends Control {
  constructor(parent, options) {
    super(parent, options, {});
    this._options = {};
    this._searching = false;
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  init() {
    super.init();
    const navItems = this.getAttribute("navItems", true);
    if (navItems) {
      this._navItems = navItems;
      this._flatNavItems = this.flattenNavItem(navItems);
    }
    if (!this._wrapper)
      this._wrapper = new VStack();
    const navOptions = this.getAttribute("options", true);
    const onItemClick = this.getAttribute("onItemClick", true);
    if (onItemClick)
      this._onItemClick = onItemClick;
    this._options = navOptions;
    this.appendChild(this._wrapper);
    this.render();
  }
  set navItems(navItems) {
    this._navItems = navItems;
    this.renderNav(navItems);
  }
  get navItems() {
    return this._navItems;
  }
  setRootActive() {
    this._activeNavItem = void 0;
    this._parentNavItem = void 0;
    this.renderNav(this._navItems);
  }
  setSelectedItemById(id) {
    const navItem = this._flatNavItems.find((item) => item.id === id);
    if (navItem) {
      if (navItem.navItems && navItem.navItems.length > 0) {
        this._parentNavItem = navItem;
        this.renderNav(navItem.navItems);
      } else {
        const parentNavItem = this.findParentNavItem(this._navItems, id);
        if (parentNavItem)
          this._parentNavItem = parentNavItem;
        const siblings = this.findSiblingsById(this._navItems, id);
        if (siblings) {
          this.renderNav(siblings);
        }
      }
      this.setNavItemActive(id);
    }
  }
  getSelectedItemById(id) {
    return this._flatNavItems.find((item) => item.id === id);
  }
  getActiveRoute() {
    let routeNavItems = [];
    if (this._activeNavItem) {
      routeNavItems.push(this._activeNavItem);
      let parentNavItem = this.findParentNavItem(this._navItems, this._activeNavItem.id);
      if (parentNavItem)
        routeNavItems = [parentNavItem, ...routeNavItems];
      while (parentNavItem) {
        parentNavItem = this.findParentNavItem(this._navItems, parentNavItem.id);
        if (parentNavItem)
          routeNavItems = [parentNavItem, ...routeNavItems];
      }
    }
    return routeNavItems;
  }
  clear() {
    this._navWrapper.clearInnerHTML();
  }
  render() {
    const pnlSearch = new GridLayout(this._wrapper, {
      templateColumns: ["12px", "1fr", "12px"]
    });
    pnlSearch.classList.add("search-container");
    new Icon(pnlSearch, {
      name: "search",
      height: "12px",
      width: "12px"
    });
    this.txtSearch = new Input(pnlSearch, {
      width: "100%",
      height: 30,
      placeholder: this._options.searchPlaceholder
    });
    const btnClear = new Icon(pnlSearch, {
      name: "times",
      width: "12px",
      height: "12px"
    });
    btnClear.classList.add("clear");
    btnClear.onClick = () => {
      this.txtSearch.value = "";
      this.handleSearchOnChange(this.txtSearch);
    };
    this.txtSearch.onChanged = this.handleSearchOnChange.bind(this);
    this._navWrapper = new VStack(this._wrapper);
    this._navWrapper.classList.add("nav-wrapper");
    this.renderNav(this._navItems);
  }
  renderNav(navItems, searchMode) {
    this.clear();
    if (navItems) {
      if (this._parentNavItem && !searchMode) {
        const backNavItem = new NavItem(this._navWrapper, {
          back: true,
          ...this._parentNavItem
        });
        backNavItem.onClick = () => {
          if (this._parentNavItem) {
            const siblings = this.findSiblingsById(this._navItems, this._parentNavItem.id);
            this._parentNavItem = this.findParentNavItem(this._navItems, this._parentNavItem.id);
            if (siblings)
              this.renderNav(siblings);
          }
        };
      }
      let parentPaths = [];
      for (const navItem of navItems) {
        if (searchMode && (!navItem.navItems || navItem.navItems && navItem.navItems.length === 0)) {
          const parentPath = this.findParentPathByNavItem(navItem);
          if (!parentPaths.includes(parentPath) && parentPath) {
            parentPaths.push(parentPath);
            const parentNavSiblings = this.findSiblingsById(this._navItems, navItem.id);
            const parentPathNavItem = new NavItem(this._navWrapper, {
              caption: parentPath,
              navItems: parentNavSiblings
            });
            parentPathNavItem.onClick = () => {
              this._parentNavItem = this.findParentNavItem(this._navItems, navItem.id);
              if (this._parentNavItem && this._parentNavItem.navItems) {
                this.renderNav(this._parentNavItem.navItems);
              }
            };
          }
        }
        const elmNavItem = new NavItem(this._navWrapper, {
          ...navItem
        });
        elmNavItem.onClick = () => {
          if (navItem.navItems && navItem.navItems.length > 0)
            this._parentNavItem = navItem;
          else
            this._parentNavItem = this.findParentNavItem(this._navItems, navItem.id);
          if (navItem.navItems && navItem.navItems.length > 0) {
            this.renderNav(navItem.navItems);
          } else {
            if (this._searching) {
              const siblings = this.findSiblingsById(this._navItems, navItem.id);
              if (siblings)
                this.renderNav(siblings);
            }
            this.setNavItemActive(elmNavItem.id);
            if (this._onItemClick) {
              this._onItemClick(navItem);
            }
          }
        };
      }
    }
  }
  setNavItemActive(id) {
    const filterNavItem = this._flatNavItems.find((item) => item.id === id);
    if (filterNavItem) {
      if (filterNavItem.navItems && filterNavItem.navItems.length > 0)
        return;
      this._activeNavItem = filterNavItem;
      const activeItem = this.querySelector("i-nav-item.active");
      if (activeItem)
        activeItem.classList.remove("active");
      if (id) {
        const navItem = this.querySelector(`i-nav-item[nav-id="${id}"]`);
        if (navItem)
          navItem.classList.add("active");
      }
    }
  }
  handleSearchOnChange(control) {
    const value = control.value;
    if (value.trim() === "")
      this.renderNav(this._navItems);
    else {
      this._searching = true;
      const filteredNavItems = this._flatNavItems.filter((v) => v.caption.trim().toLowerCase().indexOf(value.trim().toLowerCase()) >= 0);
      this.renderNav(filteredNavItems, true);
    }
  }
  flattenNavItem(navItems) {
    if (!navItems || navItems.length == 0)
      return [];
    const flattenNavItems = [];
    for (const navItem of navItems) {
      let additionalNavItems = [];
      if (navItem.navItems) {
        additionalNavItems = this.flattenNavItem(navItem.navItems);
      }
      flattenNavItems.push(navItem, ...additionalNavItems);
    }
    return flattenNavItems;
  }
  findSiblingsById(navItems, navItemId) {
    for (const navItem of navItems) {
      if (navItem.id === navItemId)
        return navItems;
      else if (navItem.navItems && navItem.navItems.length > 0) {
        const siblings = this.findSiblingsById(navItem.navItems, navItemId);
        if (siblings !== void 0)
          return siblings;
      }
    }
  }
  findParentNavItem(navItems, navItemId) {
    for (const navItem of navItems) {
      if (navItem.navItems && navItem.navItems.length > 0) {
        if (navItem.navItems.find((item) => item.id === navItemId))
          return navItem;
        else {
          const parentNavItem = this.findParentNavItem(navItem.navItems, navItemId);
          if (parentNavItem)
            return parentNavItem;
        }
      }
    }
  }
  findParentPathByNavItem(navItem) {
    if (!navItem)
      return "";
    let parentNavItem = this.findParentNavItem(this._navItems, navItem.id);
    if (!parentNavItem)
      return "";
    let path = parentNavItem.caption;
    while (parentNavItem) {
      parentNavItem = this.findParentNavItem(this._navItems, parentNavItem.id);
      if (parentNavItem)
        path = `${parentNavItem.caption} / ${path}`;
    }
    return path;
  }
};
Nav = __decorateClass([
  customElements2("i-nav")
], Nav);
var NavItem = class extends Control {
  constructor(parent, options) {
    super(parent, options, {});
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  init() {
    super.init();
    this._caption = this.getAttribute("caption", true);
    this._navItems = this.getAttribute("navItems", true);
    this._back = this.getAttribute("back", true);
    const id = this.getAttribute("id", true);
    if (id)
      this.setAttribute("nav-id", id);
    this.render();
    this.appendChild(this._wrapper);
  }
  render() {
    const templateColumns = [];
    if (this._back)
      templateColumns.push("18px");
    templateColumns.push("1fr");
    if (this._navItems && this._navItems.length > 0)
      templateColumns.push("18px");
    this._wrapper = new GridLayout(void 0, {
      templateColumns
    });
    if (this._back) {
      new Icon(this._wrapper, {
        name: "chevron-left"
      });
    }
    new Label(this._wrapper, {
      caption: this._caption
    });
    if (!this._back && this._navItems && this._navItems.length > 0) {
      new Icon(this._wrapper, {
        name: "chevron-right"
      });
    }
  }
};
NavItem = __decorateClass([
  customElements2("i-nav-item")
], NavItem);

// packages/breadcrumb/src/style/breadcrumb.css.ts
var Theme44 = theme_exports.ThemeVars;
cssRule("i-breadcrumb", {
  $nest: {
    "i-label": {
      padding: 5,
      margin: "0 5px",
      color: Theme44.colors.primary.main
    },
    "i-icon": {
      margin: "0 5px",
      height: Theme44.typography.fontSize,
      width: Theme44.typography.fontSize,
      fill: Theme44.colors.primary.main
    }
  }
});

// packages/breadcrumb/src/breadcrumb.ts
var Breadcrumb = class extends Control {
  constructor(parent, options) {
    super(parent, options, {});
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  init() {
    super.init();
    this._breadcrumbItems = this.getAttribute("breadcrumbItems", true);
    this._onItemClick = this.getAttribute("onItemClick", true);
    this.render();
  }
  set breadcrumbItems(breadcrumbItems) {
    this._breadcrumbItems = breadcrumbItems;
    this.render();
  }
  get breadcrumbItems() {
    return this._breadcrumbItems;
  }
  clear() {
    this._wrapper.clearInnerHTML();
  }
  render() {
    if (!this._wrapper) {
      this._wrapper = new HStack(void 0, {
        justifyContent: "start",
        alignItems: "center"
      });
    }
    this.clear();
    if (this._breadcrumbItems) {
      for (let i = 0; i < this._breadcrumbItems.length; i++) {
        const breadcrumbItem = this._breadcrumbItems[i];
        const lbBreadcrumb = new Label(this._wrapper, {
          caption: breadcrumbItem.caption
        });
        if (this._onItemClick !== void 0)
          this.classList.add("pointer");
        lbBreadcrumb.onClick = () => {
          if (this._onItemClick)
            this._onItemClick(breadcrumbItem);
        };
        if (i + 1 < this._breadcrumbItems.length) {
          new Icon(this._wrapper, {
            name: "chevron-right",
            width: 18,
            height: 18
          });
        }
      }
    }
    this.appendChild(this._wrapper);
  }
};
Breadcrumb = __decorateClass([
  customElements2("i-breadcrumb")
], Breadcrumb);

// packages/form/src/styles/index.css.ts
var Theme45 = theme_exports.ThemeVars;
var formStyle = style({
  $nest: {
    "i-vstack > .form-group": {
      width: "100%"
    }
  }
});
var formGroupStyle = style({
  display: "flex",
  flexDirection: "column",
  gap: 5,
  justifyContent: "center"
});
var groupStyle = style({
  border: `1px solid ${Theme45.divider}`,
  borderRadius: 5,
  width: "100%",
  marginBottom: 5
});
var groupHeaderStyle = style({
  padding: 10,
  display: "flex",
  alignItems: "center",
  justifyContent: "space-between",
  cursor: "pointer"
});
var groupBodyStyle = style({
  padding: 10
});
var collapseBtnStyle = style({
  cursor: "pointer",
  height: Theme45.typography.fontSize,
  width: Theme45.typography.fontSize
});
var inputStyle = style({
  width: "100% !important",
  $nest: {
    "& > input, & > textarea": {
      width: "100% !important",
      maxWidth: "100%",
      padding: "0.5rem 1rem",
      color: Theme45.input.fontColor,
      backgroundColor: Theme45.input.background,
      borderColor: Theme45.input.background,
      borderRadius: "0.625rem",
      outline: "none"
    },
    "i-color .input-span": {
      borderRadius: "0.625rem",
      $nest: {
        "> span": {
          borderRadius: "0.375rem"
        }
      }
    }
  }
});
var datePickerStyle = style({
  display: "inline-flex",
  width: "100% !important",
  borderRadius: "0.625rem",
  $nest: {
    "> input": {
      width: "calc(100% - 24px) !important",
      maxWidth: "calc(100% - 24px)",
      padding: "0.5rem 1rem",
      color: Theme45.input.fontColor,
      backgroundColor: Theme45.input.background,
      borderColor: Theme45.input.background,
      outline: "none"
    },
    "> input:focus ~ .datepicker-toggle": {
      borderColor: Theme45.colors.info.main
    },
    ".datepicker-toggle": {
      backgroundColor: Theme45.input.background,
      width: "42px"
    }
  }
});
var comboBoxStyle = style({
  width: "100% !important",
  $nest: {
    ".selection": {
      width: "100% !important",
      maxWidth: "100%",
      padding: "0.5rem 1rem",
      color: Theme45.input.fontColor,
      backgroundColor: Theme45.input.background,
      borderColor: Theme45.input.background,
      borderRadius: "0.625rem!important"
    },
    ".selection input": {
      color: "inherit",
      backgroundColor: "inherit",
      padding: 0
    },
    "> .icon-btn": {
      justifyContent: "center",
      borderColor: Theme45.input.background,
      borderRadius: "0.625rem",
      width: "42px"
    }
  }
});
var buttonStyle = style({
  padding: 5
});
var iconButtonStyle = style({
  cursor: "pointer",
  height: Theme45.typography.fontSize,
  width: Theme45.typography.fontSize
});
var checkboxStyle = style({
  $nest: {
    ".checkmark": {
      width: "22px",
      height: "22px",
      borderRadius: "6px"
    },
    ".checkmark:after": {
      width: "4px",
      height: "8px",
      top: "4px"
    }
  }
});
var listHeaderStyle = style({
  padding: "10px 0px",
  borderBottom: `1px solid ${Theme45.divider}`,
  marginBottom: 10,
  minHeight: "60px",
  alignItems: "center",
  fontWeight: 600
});
var listBtnAddStyle = style({
  color: Theme45.colors.primary.contrastText,
  backgroundColor: Theme45.colors.primary.main,
  padding: "0.5rem 1rem",
  borderRadius: 0,
  cursor: "pointer"
});
var listColumnHeaderStyle = style({
  padding: "10px 0",
  textAlign: "center"
});
var listItemStyle = style({
  $nest: {
    "i-panel": {
      $nest: {
        "i-input": {
          width: "100% !important"
        },
        "input": {
          width: "100% !important"
        },
        "i-color": {
          $nest: {
            ".i-color": {
              width: "100% !important"
            },
            ".input-span": {
              width: "100% !important"
            }
          }
        },
        "i-checkbox": {
          height: "auto !important",
          $nest: {
            ".i-checkbox": {
              width: "100%",
              justifyContent: "center"
            },
            ".i-checkbox_label": {
              display: "none"
            }
          }
        }
      }
    }
  }
});
var listVerticalLayoutStyle = style({
  $nest: {
    "& > i-grid-layout:not(:last-child)": {
      paddingBottom: 10,
      borderBottom: "1px solid var(--divider)"
    },
    "& > i-grid-layout > i-panel": {
      flexDirection: "row",
      flexWrap: "wrap",
      $nest: {
        "> i-hstack:first-child": {
          width: "25% !important"
        },
        "> :nth-child(2)": {
          width: "calc(75% - 5px) !important"
        },
        "i-checkbox": {
          width: "100%",
          $nest: {
            ".i-checkbox": {
              display: "flex",
              flexDirection: "row-reverse",
              justifyContent: "flex-end",
              gap: 5
            },
            ".i-checkbox_label": {
              display: "flex",
              paddingLeft: 0,
              width: "25%"
            }
          }
        }
      }
    }
  }
});
var listItemBtnDelete = style({
  cursor: "pointer",
  placeSelf: "center",
  height: Theme45.typography.fontSize,
  width: Theme45.typography.fontSize
});
var tabsStyle = style({
  marginBottom: 41,
  $nest: {
    ".tabs-nav-wrap": {
      $nest: {
        ".tabs-nav": {
          borderColor: "transparent",
          height: "54px"
        },
        "i-tab": {
          border: 0,
          fontFamily: Theme45.typography.fontFamily,
          fontSize: Theme45.typography.fontSize,
          fontWeight: 600,
          borderBottom: "1px solid transparent",
          background: "transparent",
          color: Theme45.text.secondary,
          margin: "0 0.75rem",
          padding: "0.5rem 0",
          transition: "color .2s ease",
          $nest: {
            "&:first-of-type": {
              marginLeft: 0
            },
            "&:not(.disabled):hover": {
              color: Theme45.text.primary
            },
            "&:not(.disabled).active": {
              background: "transparent",
              color: Theme45.colors.info.main,
              borderBottom: `1px solid ${Theme45.colors.info.main}`
            },
            ".tab-item": {
              padding: 0
            }
          }
        }
      }
    },
    ".tabs-content": {
      overflow: "visible"
    }
  }
});
var cardStyle = style({
  border: `1px solid ${Theme45.divider}`
});
var cardHeader = style({
  padding: 20,
  borderBottom: `1px solid ${Theme45.divider}`,
  cursor: "pointer"
});
var cardBody = style({
  padding: 20
});
var uploadStyle = style({
  height: "auto",
  width: "100%",
  margin: 0,
  fontFamily: Theme45.typography.fontFamily,
  $nest: {
    "> .i-upload-wrapper": {
      marginBottom: 0,
      borderRadius: 5
    }
  }
});
var tokenInputStyle = style({
  $nest: {
    "#gridTokenInput": {
      border: "1px solid var(--divider) !important",
      borderRadius: "5px !important",
      padding: "0.31rem !important",
      background: "transparent",
      $nest: {
        "&:hover": {
          borderColor: `${Theme45.colors.primary.main} !important`
        }
      }
    },
    "#btnToken": {
      display: "flex",
      justifyContent: "space-between",
      $nest: {
        "i-icon": {
          width: "20px !important",
          height: "20px !important"
        }
      }
    },
    "i-vstack.custom-border": {
      marginBlock: "0 !important"
    }
  }
});

// packages/form/src/form.ts
var theme = theme_exports.ThemeVars;
var IPFS_Gateway = "https://ipfs.scom.dev/ipfs/";
var DEFAULT_OPTIONS = {
  columnsPerRow: 1,
  confirmButtonOptions: {
    caption: "Confirm",
    backgroundColor: theme.colors.primary.main,
    fontColor: theme.colors.primary.contrastText,
    hide: false
  },
  clearButtonOptions: {
    caption: "Clear",
    backgroundColor: theme.colors.primary.main,
    fontColor: theme.colors.primary.contrastText,
    hide: true
  },
  dateTimeFormat: {
    date: "YYYY-MM-DD",
    time: "HH:mm:ss",
    dateTime: "YYYY-MM-DD HH:mm:ss"
  },
  columnWidth: "100%"
};
var Form = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._formRules = [];
    this._formControls = {};
    this.replacePhrase = (str) => {
      return str.replace(/([^\/]+)\/items\/properties/g, function(match, p1) {
        if (p1 === "properties") {
          return match;
        }
        return `${p1}/properties`;
      });
    };
    this.validateOnValueChanged = async (currentControl, parent, scope, caption) => {
      var _a, _b;
      const data = (_a = this.validationData) != null ? _a : await this.getFormData();
      const validationResult = (_b = this.validationResult) != null ? _b : this.validate(data, this.jsonSchema, { changing: false });
      let showErrMsg = false;
      let errMsg = "";
      const isNonObject = parent.closest('[non-object="true"]');
      let _scope = scope;
      const parentListItem = parent.closest('[role="list-item"]');
      if (parentListItem && !isNonObject) {
        let parentFields = [];
        const getParentIdxs = async (_parent) => {
          if (!_parent)
            return;
          const parentElm = _parent.closest('[role="array"]');
          const arrayField = parentElm == null ? void 0 : parentElm.getAttribute("array-field");
          if (arrayField) {
            const parentList = parentElm.querySelectorAll(':scope > i-vstack > [role="list-item"]');
            for (let i = 0; i < parentList.length; i++) {
              if (parentList[i] === _parent) {
                parentFields.push({ key: arrayField, idx: i });
                await getParentIdxs(parentElm.closest('[role="list-item"]'));
                break;
              }
            }
          }
        };
        await getParentIdxs(parentListItem);
        if (scope.includes("/items/properties")) {
          _scope = this.replacePhrase(scope);
        }
        const scopeWithoutIdx = _scope.replace("#", "");
        const getListFields = (property) => {
          const regex = /\w+\[\d+\]/g;
          const matches = property.match(regex);
          return matches || [];
        };
        let nestedScopeKeys = _scope.replace(/\/properties/g, "").split("/");
        parentFields.forEach((field) => {
          const idx = nestedScopeKeys.findIndex((v) => v === field.key);
          if (idx > -1) {
            nestedScopeKeys[idx + 1] = `${nestedScopeKeys[idx + 1]}_${field.idx + 1}`;
          }
        });
        let nestedScope = nestedScopeKeys.join("/properties/");
        if (parentFields[0]) {
          _scope = `${_scope}_${parentFields[0].idx + 1}`;
        }
        nestedScope = nestedScope.replace("#", "");
        _scope = _scope.replace("#", "");
        const parentControl = currentControl.parentElement;
        const lbError = (parentControl == null ? void 0 : parentControl.querySelector('[role="error"]')) || parent.querySelector('[role="error"]') || parent;
        const err = validationResult.errors.find((f) => {
          const listFields = getListFields(f.property).reverse();
          if (f.scope.endsWith(_scope) || f.scope.endsWith(nestedScope) || f.scope.endsWith(scopeWithoutIdx)) {
            for (let idx = 0; idx < listFields.length; idx++) {
              const fld = listFields[idx];
              const parentFld = parentFields[idx];
              if (fld !== `${parentFld.key}[${parentFld.idx}]`)
                return false;
            }
            return true;
          }
          return false;
        });
        if (!lbError)
          return;
        if (err) {
          lbError.setAttribute("is-visible", "");
          lbError.caption = `${caption || ""} ${err.message}`;
          lbError.visible = true;
        } else {
          lbError.removeAttribute("is-visible");
          lbError.caption = "";
          lbError.visible = false;
        }
        return;
      }
      let itemScope = scope;
      let itemControl = {};
      if (isNonObject) {
        const parentItem = currentControl.closest("[non-object]");
        const allItems = parentItem.querySelectorAll('[role="field"]');
        for (let idx = 0; idx <= allItems.length; idx++) {
          if (allItems[idx] === currentControl) {
            itemScope = `${scope.replace(/\/items$/, "")}_${idx + 1}`;
            break;
          }
        }
        const parentControl = currentControl.parentElement;
        const lbError = (parentControl == null ? void 0 : parentControl.querySelector('[role="error"]')) || parent.querySelector('[role="error"]');
        itemControl = { error: lbError };
      }
      if ((validationResult == null ? void 0 : validationResult.valid) == false) {
        const err = validationResult.errors.find((f) => f.scope === (isNonObject ? itemScope : scope));
        if (err) {
          showErrMsg = true;
          errMsg = err.message;
        }
      }
      const control = isNonObject ? itemControl : this._formControls[_scope];
      if (control) {
        const { error, description } = control;
        if (showErrMsg) {
          if (description) {
            description.visible = false;
          }
          if (error) {
            error.setAttribute("is-visible", "");
            error.caption = `${isNonObject ? "Item" : caption || ""} ${errMsg}`;
            error.visible = true;
          }
        } else {
          if (description && description.caption) {
            description.visible = true;
          }
          if (error) {
            error.removeAttribute("is-visible");
            error.caption = "";
            error.visible = false;
          }
        }
      }
    };
  }
  init() {
    super.init();
    this.classList.add(formStyle);
    this._jsonSchema = this.getAttribute("jsonSchema", true);
    this._uiSchema = this.getAttribute("uiSchema", true);
    this._formOptions = this.getAttribute("options", true);
    if (!this._formOptions)
      this._formOptions = DEFAULT_OPTIONS;
    this.renderForm();
  }
  set formOptions(options) {
    this._formOptions = options;
  }
  get formOptions() {
    return this._formOptions;
  }
  set jsonSchema(jsonSchema) {
    this._jsonSchema = jsonSchema;
  }
  get jsonSchema() {
    return this._jsonSchema;
  }
  set uiSchema(uiSchema) {
    this._uiSchema = uiSchema;
  }
  get uiSchema() {
    return this._uiSchema;
  }
  clearFormData() {
    for (const scope in this._formControls) {
      const control = this._formControls[scope];
      const { input, error } = control;
      if (input) {
        if (error) {
          error.removeAttribute("is-visible");
          error.caption = "";
          error.visible = false;
        }
        switch (input.tagName) {
          case "I-INPUT":
            input.value = "";
            break;
          case "I-CHECKBOX":
            input.checked = false;
            break;
          case "I-DATEPICKER":
            input.value = void 0;
            break;
          case "I-COMBO-BOX":
            input.clear();
            break;
          case "I-VSTACK":
            input.clearInnerHTML();
            break;
          case "I-UPLOAD":
            input.clear();
            break;
        }
      }
    }
  }
  setFormData(data) {
    for (const key2 in data) {
      const value = data[key2];
      const scope = `#/properties/${key2}`;
      this.setData(scope, value, void 0, data);
    }
    this.validateAllRule();
  }
  setCustomData(scope, value, control, customData) {
    var _a;
    let newScope = scope;
    if (newScope.includes("/items/properties")) {
      newScope = this.replacePhrase(scope);
    }
    if (this._formOptions.customControls && !!((_a = this._formOptions.customControls[newScope]) == null ? void 0 : _a.setData)) {
      const _control = control || this._formControls[newScope].input;
      if (_control) {
        if (_control.tagName === "I-SCOM-TOKEN-INPUT" && !value && customData) {
          this._formOptions.customControls[newScope].setData(_control, customData.symbol, customData);
        } else {
          this._formOptions.customControls[newScope].setData(_control, value, customData);
        }
      }
    }
  }
  setData(scope, value, parentElm, customData) {
    var _a, _b, _c, _d;
    let _control;
    this.setCustomData(scope, value, void 0, customData);
    if (typeof value === "object") {
      if (value instanceof Array) {
        if (parentElm) {
          const currentFld = scope.split("/").pop();
          _control = (_a = parentElm.querySelector(`[array-field="${currentFld}"]`)) == null ? void 0 : _a.lastChild;
        }
        const grid = _control || ((_b = this._formControls[scope]) == null ? void 0 : _b.input);
        if (grid) {
          grid.clearInnerHTML();
          for (const data of value) {
            const schema = (_c = this.getDataSchemaByScope(scope)[1]) == null ? void 0 : _c.items;
            this.renderCard({ parent: grid, scope, schema, options: {} });
          }
          const listItems = grid == null ? void 0 : grid.querySelectorAll(':scope > [role="list-item"]');
          if (listItems && listItems.length > 0) {
            for (let i = 0; i < listItems.length; i++) {
              const listItem = listItems[i];
              const rowData = value[i];
              const fields = listItem.querySelectorAll('[role="field"]');
              if (grid.getAttribute("non-object") === true) {
                const field = fields[0];
                if (field) {
                  if (field.tagName === "I-INPUT") {
                    field.value = rowData;
                  } else if (field.tagName === "I-CHECKBOX") {
                    field.checked = rowData;
                  } else if (field.tagName === "I-COMBO-BOX") {
                    field.value = rowData;
                    const selectedItem = field.items.find((v) => v.value === rowData);
                    if (selectedItem)
                      field.selectedItem = selectedItem;
                  } else if (field.tagName === "I-RADIO-GROUP") {
                    field.selectedValue = rowData;
                  } else if (field.tagName === "I-DATEPICKER") {
                    let datepicker = field;
                    datepicker.value = moment(rowData, datepicker.dateTimeFormat || datepicker.defaultDateTimeFormat);
                  } else {
                    this.setCustomData(scope, rowData, field, rowData);
                  }
                }
              } else {
                for (let j = 0; j < fields.length; j++) {
                  const field = fields[j];
                  const fieldName = field.getAttribute("field") || "";
                  const columnData = rowData[fieldName];
                  if (field.tagName === "I-INPUT") {
                    field.value = columnData;
                  } else if (field.tagName === "I-CHECKBOX") {
                    field.checked = columnData;
                  } else if (field.tagName === "I-COMBO-BOX") {
                    field.value = columnData;
                    const selectedItem = field.items.find((v) => v.value === columnData);
                    if (selectedItem)
                      field.selectedItem = selectedItem;
                  } else if (field.tagName === "I-RADIO-GROUP") {
                    field.selectedValue = columnData;
                  } else if (field.tagName === "I-DATEPICKER") {
                    let datepicker = field;
                    datepicker.value = moment(columnData, datepicker.dateTimeFormat || datepicker.defaultDateTimeFormat);
                  } else if (field.tagName === "I-UPLOAD") {
                    this.setDataUpload(columnData, field);
                  } else {
                    const customScope = `${scope}/properties/${fieldName}`;
                    this.setCustomData(customScope, columnData, field, rowData);
                  }
                }
                const subArr = listItem.querySelectorAll('[role="array"]');
                for (const subItem of subArr) {
                  if (subItem.closest('[role="list-item"]') === listItem) {
                    const field = subItem.getAttribute("array-field") || "";
                    this.setData(`${scope}/items/properties/${field}`, rowData[field], listItem, rowData);
                  }
                }
                const subObj = listItem.querySelectorAll('[role="object"]');
                for (const subItem of subObj) {
                  if (subItem.closest('[role="list-item"]') === listItem) {
                    const field = subItem.getAttribute("object-field") || "";
                    this.setData(`${scope}/items/properties/${field}`, rowData[field], listItem, rowData);
                  }
                }
              }
            }
          }
        }
      } else {
        if (parentElm) {
          const currentFld = scope.split("/").pop();
          _control = parentElm.querySelector(`[object-field="${currentFld}"]`);
        }
        for (const key2 in value) {
          const data = value[key2];
          const currentScope = `${scope}/properties/${key2}`;
          this.setData(currentScope, data, _control || parentElm, data);
        }
      }
    } else {
      if (parentElm) {
        _control = parentElm.querySelector(`[scope="${scope}"]`);
        if (!_control) {
          const customScope = scope.includes("/items/properties") ? this.replacePhrase(scope) : scope;
          _control = parentElm.querySelector(`[custom-control="${customScope}"]`);
        }
      }
      const input = _control || ((_d = this._formControls[scope]) == null ? void 0 : _d.input);
      if (!input && value === void 0) {
        const currentFld = scope.split("/").pop();
        const objElm = parentElm == null ? void 0 : parentElm.querySelector(`[object-field="${currentFld}"]`);
        if (objElm) {
          const _inputs = objElm.querySelectorAll(':scope > i-panel > i-vstack > [role="field"]');
          for (const _input of _inputs) {
            this.setData(`${scope}/properties/${_input.getAttribute("field")}`, void 0, objElm);
          }
        }
        return;
      }
      if (input) {
        if (input.getAttribute("custom-control")) {
          this.setCustomData(input.getAttribute("custom-control"), value, input, customData);
        } else {
          switch (input.tagName) {
            case "I-INPUT":
              input.value = value;
              break;
            case "I-CHECKBOX":
              input.checked = value;
              break;
            case "I-COMBO-BOX":
              input.value = value;
              input.selectedItem = input.items.find((v) => v.value === value) || input.items[0];
              break;
            case "I-DATEPICKER":
              let datepicker = input;
              datepicker.value = moment(value, datepicker.dateTimeFormat || datepicker.defaultDateTimeFormat);
              break;
            case "I-UPLOAD":
              this.setDataUpload(value, input);
              break;
          }
        }
      }
    }
  }
  async getFormData(isErrorShown) {
    if (!this._jsonSchema)
      return void 0;
    const data = await this.getDataBySchema(this._jsonSchema, "#", isErrorShown);
    return data;
  }
  async getDataBySchema(schema, scope = "#", isErrorShown, parentElm, listItem, parentScope) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    if (!schema)
      return void 0;
    const customParentScope = parentScope ? `${parentScope}${scope.replace("#", "")}` : scope;
    let _control;
    let control;
    if (listItem) {
      const fieldName = scope.split("/").pop();
      control = listItem.querySelector(`[scope="${scope}"]`);
      if (!control) {
        const flds = listItem.querySelectorAll(`[field="${fieldName}"]`);
        const currentScope = scope.replace("#", "");
        for (const fld of flds) {
          const _fldScope = fld.getAttribute("scope");
          if (_fldScope && _fldScope.endsWith(currentScope)) {
            control = fld;
            break;
          }
        }
      }
      if (!control && this._formOptions.customControls) {
        if (this._formOptions.customControls[customParentScope]) {
          control = listItem.querySelector(`[custom-control="${customParentScope}"]`);
        } else if (this._formOptions.customControls[scope] && ((_a = listItem.parentElement) == null ? void 0 : _a.hasAttribute("non-object"))) {
          control = listItem.querySelector(`[custom-control="${scope}"]`);
        }
      }
    } else {
      control = _control || ((_b = this._formControls[scope]) == null ? void 0 : _b.input);
    }
    const checkValidation = () => {
      if (isErrorShown && control) {
        const actControl = control;
        if (actControl.querySelector("i-color") && typeof actControl.onClosed === "function") {
          actControl.onClosed();
        } else if (typeof actControl.onChanged === "function") {
          actControl.onChanged();
        }
      }
    };
    if (this._formOptions.customControls && typeof ((_c = this._formOptions.customControls[customParentScope]) == null ? void 0 : _c.getData) === "function") {
      checkValidation();
      return this._formOptions.customControls[customParentScope].getData(control);
    }
    if (schema.type === "string") {
      if (control) {
        checkValidation();
        switch (control.tagName) {
          case "I-INPUT":
            return control.value;
          case "I-COMBO-BOX":
            return (_d = control.value) == null ? void 0 : _d.value;
          case "I-DATEPICKER":
            let datepicker = control;
            return (_e = datepicker.value) == null ? void 0 : _e.format(datepicker.dateTimeFormat || datepicker.defaultDateTimeFormat);
          case "I-UPLOAD":
            const uploader = control;
            const file = uploader.fileList[0];
            if (file) {
              if (schema.format === "data-url") {
                const dataUrl = await uploader.toBase64(file);
                return dataUrl;
              } else if (schema.format === "data-cid") {
                let cid = (_f = file.cid) == null ? void 0 : _f.cid;
                if (!cid)
                  return void 0;
                try {
                  try {
                    let result = await fetch(`https://ipfs.scom.dev/ipfs/${cid}`);
                  } catch (e) {
                    await uploader.upload();
                  }
                } catch (e) {
                }
                return cid;
              } else
                return void 0;
            } else
              return void 0;
          default:
            return void 0;
        }
      } else
        return void 0;
    } else if (schema.type === "integer") {
      if (control) {
        checkValidation();
        switch (control.tagName) {
          case "I-INPUT":
            const val = control.value;
            return this.isNumber(val) ? parseInt(val) : void 0;
          case "I-COMBO-BOX":
            return parseFloat((_g = control.value) == null ? void 0 : _g.value);
          default:
            return void 0;
        }
      } else
        return void 0;
    } else if (schema.type === "number") {
      if (control) {
        checkValidation();
        switch (control.tagName) {
          case "I-INPUT":
            const val = control.value;
            return this.isNumber(val) ? parseFloat(val) : void 0;
          case "I-COMBO-BOX":
            return parseFloat((_h = control.value) == null ? void 0 : _h.value);
          default:
            return void 0;
        }
      } else
        return void 0;
    } else if (schema.type === "boolean") {
      if (control) {
        checkValidation();
        switch (control.tagName) {
          case "I-CHECKBOX":
            return control.checked;
          default:
            return void 0;
        }
      }
    } else if (schema.type === "object") {
      const properties = schema.properties;
      if (!properties)
        return void 0;
      const obj = {};
      for (const propertyName in properties) {
        const currentSchema = properties[propertyName];
        const currentScope = `${scope}/properties/${propertyName}`;
        obj[propertyName] = await this.getDataBySchema(currentSchema, currentScope, isErrorShown, parentElm, listItem, parentScope);
      }
      return obj;
    } else if (schema.type === "array") {
      if (parentElm) {
        _control = (_i = parentElm.querySelector('[role="list-item"]')) == null ? void 0 : _i.parentElement;
      } else if (listItem) {
        _control = (_j = listItem.querySelector('[role="list-item"]')) == null ? void 0 : _j.parentElement;
      }
      const grid = _control || ((_k = this._formControls[scope]) == null ? void 0 : _k.input);
      const listItems = grid == null ? void 0 : grid.querySelectorAll(':scope > [role="list-item"]');
      if (!(schema.items instanceof Array) && typeof schema.items === "object") {
        const currentSchema = schema.items;
        if (listItems && listItems.length > 0) {
          const list = [];
          const newScope = currentSchema.type === "string" ? scope + "/items" : "#";
          for (let i = 0; i < listItems.length; i++) {
            const listItem2 = listItems[i];
            const data = await this.getDataBySchema(currentSchema, newScope, isErrorShown, parentElm, listItem2, customParentScope);
            list.push(data);
          }
          return list;
        }
      }
    }
  }
  isNumber(value) {
    if (value === null || value === void 0 || value === "" || isNaN(Number(value))) {
      return false;
    }
    return true;
  }
  findTabByElm(elm) {
    const wrapper = elm.closest(".content-pane");
    if (wrapper && this.contains(wrapper)) {
      const tabsContent = wrapper.closest(".tabs-content");
      if (tabsContent) {
        let wrapperIdx = -1;
        for (let i = 0; i < tabsContent.childElementCount; i++) {
          if (wrapper === tabsContent.childNodes[i]) {
            wrapperIdx = i;
            break;
          }
        }
        if (wrapperIdx > -1) {
          const tabs = tabsContent.closest("i-tabs");
          if (tabs) {
            tabs.activeTabIndex = wrapperIdx;
            this.findTabByElm(tabs);
          }
        }
      }
    }
  }
  renderForm() {
    var _a, _b, _c;
    this.clearInnerHTML();
    this._formRules = [];
    this._formControls = {};
    let controls2;
    if (this._uiSchema) {
      this.renderFormByUISchema(this, this._uiSchema);
      this.setupRules();
    } else {
      this.renderFormByJSONSchema(this, this._jsonSchema);
    }
    const pnlButton = new HStack(void 0, {
      justifyContent: "end",
      alignItems: "center",
      gap: 5,
      padding: {
        top: 10,
        bottom: 10
      }
    });
    if (!this._formOptions.confirmButtonOptions)
      this._formOptions.confirmButtonOptions = DEFAULT_OPTIONS.confirmButtonOptions;
    if (!this._formOptions.clearButtonOptions)
      this._formOptions.clearButtonOptions = DEFAULT_OPTIONS.clearButtonOptions;
    if (!((_a = this._formOptions.clearButtonOptions) == null ? void 0 : _a.hide)) {
      const btnClear = new Button(pnlButton, {
        caption: this._formOptions.clearButtonOptions.caption || DEFAULT_OPTIONS.clearButtonOptions.caption,
        font: {
          color: this._formOptions.clearButtonOptions.fontColor || DEFAULT_OPTIONS.clearButtonOptions.fontColor
        },
        background: {
          color: this._formOptions.clearButtonOptions.backgroundColor || DEFAULT_OPTIONS.clearButtonOptions.backgroundColor
        },
        padding: { top: "0.65rem", bottom: "0.65rem", left: "1rem", right: "1rem" },
        border: { radius: "0px" }
      });
      btnClear.classList.add(buttonStyle);
      if ((_b = this._formOptions.clearButtonOptions) == null ? void 0 : _b.onClick)
        btnClear.onClick = this._formOptions.clearButtonOptions.onClick;
      else
        btnClear.onClick = () => {
          this.clearFormData();
        };
      pnlButton.appendChild(btnClear);
    }
    if (!((_c = this._formOptions.confirmButtonOptions) == null ? void 0 : _c.hide)) {
      const btnConfirm = new Button(pnlButton, {
        caption: this._formOptions.confirmButtonOptions.caption || DEFAULT_OPTIONS.confirmButtonOptions.caption,
        font: {
          color: this._formOptions.confirmButtonOptions.fontColor || DEFAULT_OPTIONS.confirmButtonOptions.fontColor
        },
        background: {
          color: this._formOptions.confirmButtonOptions.backgroundColor || DEFAULT_OPTIONS.confirmButtonOptions.backgroundColor
        },
        padding: { top: "0.65rem", bottom: "0.65rem", left: "1rem", right: "1rem" },
        border: { radius: "0px" }
      });
      btnConfirm.classList.add(buttonStyle);
      btnConfirm.onClick = async (target, event) => {
        var _a2, _b2;
        this.validationData = await this.getFormData();
        this.validationResult = this.validate(this.validationData, this._jsonSchema, { changing: false });
        await this.getFormData(true);
        if (this.validationResult && !this.validationResult.valid && this.uiSchema) {
          const firstErrorElement = this.querySelector('i-label[role="error"][is-visible]');
          if (firstErrorElement) {
            this.findTabByElm(firstErrorElement);
          }
        } else if (((_a2 = this.validationResult) == null ? void 0 : _a2.valid) && ((_b2 = this._formOptions.confirmButtonOptions) == null ? void 0 : _b2.onClick)) {
          this._formOptions.confirmButtonOptions.onClick(target, event);
        }
        this.validationData = null;
        this.validationResult = null;
      };
      pnlButton.appendChild(btnConfirm);
    }
    this.appendChild(pnlButton);
  }
  renderFormByJSONSchema(parent, schema, scope = "#", hideLabel = false, subLevel = false, options = {}) {
    var _a, _b;
    if (!parent || !schema)
      return void 0;
    const { idx, schemaOptions, elementLabelProp, parentProp } = options;
    let labelProp = options.labelProp;
    const currentField = scope.substr(scope.lastIndexOf("/") + 1);
    if (elementLabelProp && elementLabelProp != currentField)
      labelProp = void 0;
    const labelName = schema.title || (scope != "#/" ? this.convertFieldNameToLabel(currentField) : "");
    const columnWidth = this._formOptions.columnWidth ? this._formOptions.columnWidth : "100px";
    const idxScope = idx !== void 0 ? `${scope}_${idx}` : scope;
    const defaultValue = schema.default;
    let isRequired = false;
    let arrRequired = [];
    if (schema.required instanceof Array)
      arrRequired = schema.required;
    else
      isRequired = !!schema.required;
    const controlOptions = {
      caption: labelName,
      description: schema.description,
      tooltip: schema.tooltip,
      placeholder: schema.placeholder,
      columnWidth,
      readOnly: schema.readOnly,
      required: isRequired,
      hideLabel
    };
    if (this._formOptions.customControls) {
      let customControlScope = parentProp ? `${parentProp}${scope.replace("#", "")}` : scope;
      if (customControlScope.includes("/items/properties")) {
        customControlScope = this.replacePhrase(customControlScope);
      }
      if (this._formOptions.customControls[customControlScope]) {
        const customRenderer = this._formOptions.customControls[customControlScope];
        const wrapper = new Panel(parent, {
          width: controlOptions.columnWidth
        });
        wrapper.classList.add(formGroupStyle);
        const control = customRenderer.render(parent);
        control.setAttribute("custom-control", customControlScope);
        control.setAttribute("field", scope.substr(scope.lastIndexOf("/") + 1));
        control.setAttribute("role", "field");
        if (control.tagName === "I-SCOM-TOKEN-INPUT") {
          control.classList.add(tokenInputStyle);
        }
        control.onChanged = () => {
          this.validateOnValueChanged(control, parent, customControlScope, labelName);
          if (this._formOptions.onChange) {
            this._formOptions.onChange(control, customRenderer.getData(control));
          }
        };
        let label;
        if (!hideLabel) {
          label = this.renderLabel({ parent: wrapper, options: controlOptions, type: "caption" });
        }
        const vstack = new VStack(wrapper, { gap: 4 });
        vstack.appendChild(control);
        const error = this.renderLabel({ parent: vstack, options: controlOptions, type: "error" });
        this._formControls[customControlScope] = {
          input: control,
          label,
          error
        };
        return;
      }
    }
    if (schema.enum && schema.enum.length > 0 || schema.oneOf && schema.oneOf.length > 0) {
      let items = [];
      if (schema.oneOf && schema.oneOf.length > 0) {
        items = schema.oneOf.map((item) => {
          let data = {
            label: item.title || "",
            value: item.const
          };
          if (item.description)
            data.description = item.description;
          if (item.icon)
            data.icon = item.icon;
          return data;
        });
      } else if (schema.enum && schema.enum.length > 0) {
        items = schema.enum.map((item) => ({
          label: item,
          value: item
        }));
      }
      if ((schemaOptions == null ? void 0 : schemaOptions.format) === "radio") {
        items = items.map((v) => ({
          caption: v.label,
          value: v.value
        }));
        return this.renderRadioGroup({ parent, scope, items, options: controlOptions, labelProp, defaultValue });
      }
      return this.renderComboBox({ parent, scope, items, options: controlOptions, labelProp, defaultValue });
    } else if (schema.type === "string") {
      if (["date", "time", "date-time"].includes(schema.format || "")) {
        let datePickerType = schema.format;
        if (schema.format === "date-time")
          datePickerType = "dateTime";
        return this.renderDatePicker({ parent, scope, type: datePickerType || "", options: controlOptions, defaultValue });
      } else if (schema.format === "data-url") {
        return this.renderUploader({ parent, scope, options: controlOptions, defaultValue });
      } else if (schema.format === "data-cid") {
        return this.renderUploader({ parent, scope, options: controlOptions, defaultValue });
      } else if (schema.format === "color") {
        return this.renderColorPicker({ parent, scope, options: controlOptions, labelProp, defaultValue });
      } else if ((schemaOptions == null ? void 0 : schemaOptions.multi) === true) {
        return this.renderTextArea({ parent, scope, options: controlOptions, labelProp, defaultValue });
      } else {
        return this.renderInput({ parent, scope, options: controlOptions, labelProp, defaultValue });
      }
    } else if (["integer", "number"].includes(((_a = schema.type) == null ? void 0 : _a.toString()) || "")) {
      return this.renderNumberInput({ parent, scope, options: controlOptions, labelProp, defaultValue });
    } else if (schema.type === "boolean") {
      return this.renderCheckBox({ parent, scope, options: controlOptions, labelProp, defaultValue });
    } else if (schema.type === "object") {
      const properties = schema.properties;
      if (!properties)
        return void 0;
      let wrapperObj;
      let wrapper;
      let container;
      if (scope !== "#" && !subLevel) {
        wrapperObj = this.renderGroup({ parent, options: controlOptions });
        wrapper = wrapperObj.wrapper;
        container = wrapperObj.body;
      } else {
        wrapper = new Panel(parent);
        container = wrapper;
      }
      let form = new GridLayout(container, {
        gap: { column: 10, row: 10 },
        columnsPerRow: this._formOptions.columnsPerRow || DEFAULT_OPTIONS.columnsPerRow
      });
      form.setAttribute("role", "object");
      form.setAttribute("object-field", currentField);
      for (const propertyName in properties) {
        let currentSchema = properties[propertyName];
        if (!(currentSchema == null ? void 0 : currentSchema.required) && arrRequired.includes(propertyName)) {
          currentSchema.required = true;
        }
        this.renderFormByJSONSchema(form, currentSchema, `${idxScope}/properties/${propertyName}`, false, false, { idx, elementLabelProp, labelProp });
      }
      this._formControls[scope] = {
        wrapper
      };
      return wrapper;
    } else if (schema.type === "array") {
      if (!schema.items)
        return void 0;
      const isVertical = ((_b = schemaOptions == null ? void 0 : schemaOptions.detail) == null ? void 0 : _b.type) === "VerticalLayout";
      const { body, btnAdd, columnHeader } = this.renderList({ parent, scope, options: controlOptions, isVertical, defaultValue });
      if (typeof schema.items === "object" && !(schema.items instanceof Array)) {
        if (schema.items.type === "object") {
          const properties = schema.items.properties;
          let hasSublevel = Object.values(properties).find((value) => value.type === "object" || value.type === "array");
          if (!hasSublevel && !isVertical) {
            const templateColumns = [];
            for (let i = 0; i < Object.values(properties).length; i++)
              templateColumns.push("1fr");
            templateColumns.push("50px");
            const header = new GridLayout(columnHeader, {
              templateColumns,
              gap: {
                column: 5,
                row: 5
              }
            });
            header.classList.add(listColumnHeaderStyle);
            for (const fieldName in properties) {
              const property = properties[fieldName];
              const caption = property.title || this.convertFieldNameToLabel(fieldName);
              this.renderLabel({ parent: header, options: { caption, required: !!property.required } });
            }
          }
        } else {
          body.setAttribute("non-object", "true");
        }
      }
      if (btnAdd) {
        btnAdd.onClick = () => {
          if (schemaOptions && schemaOptions.detail) {
            this.renderCard({ parent: body, scope, schema: schema.items, options: controlOptions, uiSchema: schemaOptions.detail, elementLabelProp: schemaOptions.elementLabelProp });
          } else if (schema.items instanceof Array) {
          } else if (typeof schema.items === "object") {
            if (schema.items.type === "object") {
              const properties = schema.items.properties;
              if (!properties || properties && Object.values(properties).length > 0) {
                this.renderCard({ parent: body, scope, schema: schema.items, options: controlOptions });
              }
            } else {
              this.renderCard({ parent: body, scope, schema: schema.items, options: controlOptions });
            }
          }
        };
      }
    } else if (schema.type === "null") {
      return void 0;
    } else if (schema.type === "any") {
      return void 0;
    } else
      return void 0;
  }
  renderFormByUISchema(parent, uiSchema, carryData, jsonSchema, elementLabelProp, labelProp, parentProp) {
    if (!parent || !uiSchema)
      return null;
    const { elements, type, scope, label, options, rule } = uiSchema;
    if (type === "VerticalLayout") {
      const elm = new VStack(parent, {
        justifyContent: "center",
        alignItems: "center"
      });
      if (elements)
        elements.map((v) => {
          this.renderFormByUISchema(elm, v, carryData, jsonSchema, elementLabelProp, labelProp, parentProp);
        });
      if (rule)
        this._formRules.push({ elm, rule });
      return elm;
    } else if (type === "HorizontalLayout") {
      const elm = new GridLayout(parent, {
        width: "100%",
        gap: { column: 16 },
        columnsPerRow: (elements == null ? void 0 : elements.length) || 1
      });
      if (elements)
        elements.map((v) => {
          this.renderFormByUISchema(elm, v, carryData, jsonSchema, elementLabelProp, labelProp, parentProp);
        });
      if (rule)
        this._formRules.push({ elm, rule });
      return elm;
    } else if (type === "Group") {
      const groupObj = this.renderGroup({
        parent,
        options: {
          required: false,
          caption: typeof label === "string" ? label : "",
          columnWidth: "100%",
          description: "",
          readOnly: false
        }
      });
      if (elements) {
        elements.map((v) => {
          if (groupObj.body)
            this.renderFormByUISchema(groupObj.body, v, carryData, jsonSchema, elementLabelProp, labelProp, parentProp);
        });
      }
      if (rule)
        this._formRules.push({ elm: groupObj.wrapper, rule });
      return groupObj.wrapper;
    } else if (type === "Categorization") {
      let elm = new Tabs(parent);
      elm.classList.add(tabsStyle);
      if (elements) {
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          this.renderFormByUISchema(elm, element, { tabs: elm, index: i }, jsonSchema, elementLabelProp, labelProp, parentProp);
        }
        elm.activeTabIndex = 0;
      }
      if (rule)
        this._formRules.push({ elm, rule });
      return elm;
    } else if (type === "Category") {
      let caption;
      if (label !== false) {
        caption = label;
      }
      if (carryData && carryData.tabs && carryData.index != void 0) {
        const children = new Panel(void 0, {
          padding: {
            left: 10,
            right: 10,
            top: 10,
            bottom: 10
          }
        });
        if (elements) {
          for (const element of elements) {
            let ui = this.renderFormByUISchema(children, element, carryData, jsonSchema, elementLabelProp, labelProp, parentProp);
            if (ui)
              children.append(ui);
          }
        }
        let tabCaption = typeof caption == "boolean" ? "" : caption;
        const tab = carryData.tabs.add({ caption: tabCaption, children });
        if (rule)
          this._formRules.push({ elm: tab, rule });
      }
    } else if (type === "Control" && scope) {
      const [key2, dataSchema] = this.getDataSchemaByScope(scope, jsonSchema);
      const stub = new Panel(parent, {
        padding: {
          left: 5,
          right: 5,
          top: 5,
          bottom: 5
        }
      });
      stub.classList.add("form-group");
      let caption, labelElm, descriptionElm;
      let formControlElm = new Panel();
      formControlElm.classList.add("form-control");
      let hideLabel = false;
      if (label !== false) {
        caption = label;
        if (!caption)
          caption = this.convertFieldNameToLabel(key2);
      }
      this.renderFormByJSONSchema(formControlElm, dataSchema, scope, false, false, { schemaOptions: options, elementLabelProp, labelProp, parentProp });
      if (formControlElm)
        stub.append(formControlElm);
      if (descriptionElm)
        stub.append(descriptionElm);
      if (rule)
        this._formRules.push({ elm: stub, rule, control: this._formControls[scope] });
      return stub;
    } else
      return null;
  }
  setupRules() {
    var _a;
    if (!this._formRules || this._formRules && this._formRules.length === 0)
      return;
    for (const ruleObj of this._formRules) {
      const { elm, rule, control: inputControl } = ruleObj;
      if (!elm)
        continue;
      if (!rule)
        continue;
      if (rule && (!rule.condition || !rule.effect))
        continue;
      if (rule && rule.condition && (!rule.condition.scope || !rule.condition.schema))
        continue;
      if ((_a = rule.condition) == null ? void 0 : _a.scope) {
        const control = this._formControls[rule.condition.scope].input;
        if (!control)
          continue;
        this.setupControlRule(elm, rule.effect, control, rule.condition.schema, inputControl);
      }
    }
    this.validateAllRule();
  }
  setupControlRule(elm, effect, control, schema, inputControl) {
    if (!elm || !effect || !control || !schema)
      return;
    if (control.tagName === "I-INPUT") {
      let cachedOnChanged;
      if (control.onChanged)
        cachedOnChanged = control.onChanged;
      control.onChanged = () => {
        if (cachedOnChanged)
          cachedOnChanged();
        const value = control.value;
        this.validateRule(elm, effect, value, schema, inputControl);
      };
    } else if (control.tagName === "I-COMBO-BOX") {
      let cachedOnChanged;
      if (control.onChanged)
        cachedOnChanged = control.onChanged;
      control.onChanged = () => {
        var _a;
        if (cachedOnChanged)
          cachedOnChanged();
        const value = (_a = control.value) == null ? void 0 : _a.value;
        this.validateRule(elm, effect, value, schema, inputControl);
      };
    } else if (control.tagName === "I-DATEPICKER") {
      let cachedOnChanged;
      if (control.onChanged)
        cachedOnChanged = control.onChanged;
      control.onChanged = () => {
        if (cachedOnChanged)
          cachedOnChanged();
        const value = control.value;
        this.validateRule(elm, effect, value, schema, inputControl);
      };
    } else if (control.tagName === "I-CHECKBOX") {
      let cachedOnChanged;
      if (control.onChanged)
        cachedOnChanged = control.onChanged;
      control.onChanged = () => {
        if (cachedOnChanged)
          cachedOnChanged();
        const value = control.checked;
        this.validateRule(elm, effect, value, schema, inputControl);
      };
    } else if (control.tagName === "I-RADIO-GROUP") {
      let cachedOnChanged;
      if (control.onChanged)
        cachedOnChanged = control.onChanged;
      control.onChanged = () => {
        if (cachedOnChanged)
          cachedOnChanged();
        const value = control.selectedValue;
        this.validateRule(elm, effect, value, schema, inputControl);
      };
    }
  }
  validateRule(elm, effect, value, schema, inputControl) {
    let isValid = false;
    if (schema.const) {
      if (value === schema.const)
        isValid = true;
    } else if (schema.enum) {
      const stringEnum = schema.enum.map((v) => v.toString());
      if (stringEnum.includes(value))
        isValid = true;
    } else if (schema.not) {
      if (value !== schema.not.const.toString())
        isValid = true;
      else if (schema.not.enum) {
        const stringEnum = schema.not.enum.map((v) => v.toString());
        if (stringEnum.includes(value))
          isValid = true;
      }
    }
    if (effect === "HIDE")
      elm.visible = !isValid;
    else if (effect === "SHOW")
      elm.visible = isValid;
    else if (effect === "ENABLE") {
      if (inputControl && inputControl.input) {
        if (inputControl.input.tagName === "I-COMBO-BOX") {
          inputControl.input.readOnly = !isValid;
        } else
          inputControl.input.enabled = isValid;
      } else
        elm.enabled = isValid;
    } else if (effect === "DISABLE") {
      if (inputControl && inputControl.input) {
        if (inputControl.input.tagName === "I-COMBO-BOX") {
          inputControl.input.readOnly = isValid;
        } else
          inputControl.input.enabled = !isValid;
      } else
        elm.enabled = !isValid;
    }
  }
  validateAllRule() {
    var _a, _b;
    if (!this._formRules || this._formRules && this._formRules.length === 0)
      return;
    for (const ruleObj of this._formRules) {
      const { elm, rule, control: inputControl } = ruleObj;
      if (!elm)
        continue;
      if (!rule)
        continue;
      if (rule && (!rule.condition || !rule.effect))
        continue;
      if (rule && rule.condition && (!rule.condition.scope || !rule.condition.schema))
        continue;
      if ((_a = rule.condition) == null ? void 0 : _a.scope) {
        const control = this._formControls[rule.condition.scope].input;
        if (!control)
          continue;
        let value;
        if (control.tagName === "I-INPUT") {
          value = control.value;
        } else if (control.tagName === "I-COMBO-BOX") {
          value = (_b = control.value) == null ? void 0 : _b.value;
        } else if (control.tagName === "I-DATEPICKER") {
          value = control.value;
        } else if (control.tagName === "I-CHECKBOX") {
          value = control.checked;
        } else if (control.tagName === "I-RADIO-GROUP") {
          value = control.selectedValue;
        }
        this.validateRule(elm, rule.effect, value, rule.condition.schema, inputControl);
      }
    }
  }
  getDataSchemaByScope(scope, jsonSchema) {
    const segments = scope.split("/");
    let obj = {};
    let preObj = {};
    let parentObj = {};
    for (const segment of segments) {
      parentObj = preObj;
      preObj = obj;
      if (segment === "#")
        obj = jsonSchema || this._jsonSchema;
      else
        obj = obj[segment];
    }
    const key2 = segments[segments.length - 1];
    if (obj == void 0)
      console.log("No corresponding scope:", scope);
    else if (!obj.required && typeof parentObj.required === "object" && parentObj.required.includes(key2)) {
      obj = {
        ...obj,
        required: true
      };
    }
    return [segments[segments.length - 1], obj];
  }
  renderGroup(groupOption) {
    const { parent, options } = groupOption;
    const wrapper = new Panel(parent);
    wrapper.classList.add(groupStyle);
    const header = new Panel(wrapper);
    header.classList.add(groupHeaderStyle);
    const hstack = new HStack(header, { gap: 2 });
    new Label(hstack, { caption: options.caption });
    if (options.required) {
      new Label(hstack, {
        caption: "*",
        font: { color: "#ff0000" }
      });
    }
    const icon = new Icon(header, {
      name: "chevron-up"
    });
    const body = new Panel(wrapper);
    body.classList.add(groupBodyStyle);
    icon.onClick = header.onClick = () => {
      body.visible = !body.visible;
      icon.name = `chevron-${body.visible ? "up" : "down"}`;
    };
    icon.classList.add(collapseBtnStyle);
    return { wrapper, body };
  }
  renderLabel(labelOption) {
    const { parent, options } = labelOption;
    let { type } = labelOption;
    if (!type)
      type = "caption";
    let label;
    if (type === "caption") {
      const hstack = new HStack(parent, {
        alignItems: "center",
        gap: 2,
        width: "100%"
      });
      label = new Label(hstack, {
        caption: options == null ? void 0 : options.caption
      });
      if (options.required) {
        new Label(hstack, {
          caption: "*",
          font: { color: "#ff0000" }
        });
      }
      if (options.tooltip) {
        new Icon(hstack, {
          width: "1rem",
          height: "1rem",
          name: "info-circle",
          margin: { left: 2 },
          tooltip: { content: options.tooltip, placement: "bottom" }
        });
      }
    } else if (type === "description") {
      label = new Label(parent, {
        caption: options.description,
        margin: { top: 2 },
        visible: !!options.description
      });
    } else {
      label = new Label(parent, {
        visible: false,
        font: { color: "#ff0000" },
        margin: { top: 2 }
      });
      label.setAttribute("role", "error");
    }
    return label;
  }
  renderInput(inputOption) {
    const { parent, scope, options, labelProp, defaultValue } = inputOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    const wrapper = new Panel(parent, {
      width: options.columnWidth
    });
    wrapper.classList.add(formGroupStyle);
    let label;
    if (!options.hideLabel) {
      label = this.renderLabel({ parent: wrapper, options, type: "caption" });
    }
    const vstack = new VStack(wrapper, { gap: 4 });
    const input = new Input(vstack, {
      inputType: "text",
      height: "42px",
      width: "100%"
    });
    input.onChanged = () => {
      if (labelProp)
        labelProp.caption = input.value;
      this.validateOnValueChanged(input, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(input, input.value);
      }
    };
    input.setAttribute("role", "field");
    input.setAttribute("scope", scope);
    input.setAttribute("field", field);
    input.setAttribute("dataType", "string");
    if (options.readOnly !== void 0) {
      input.setAttribute("readOnly", options.readOnly.toString());
    }
    if (options.placeholder !== void 0) {
      input.setAttribute("placeholder", options.placeholder);
    }
    input.classList.add(inputStyle);
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      label,
      input,
      description,
      error
    };
    if (defaultValue) {
      input.setAttribute("value", defaultValue.toString());
    }
    return wrapper;
  }
  renderNumberInput(numberInputOption) {
    const { parent, scope, options, labelProp, defaultValue } = numberInputOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    const wrapper = new Panel(parent, { width: options.columnWidth });
    wrapper.classList.add(formGroupStyle);
    let label;
    if (!options.hideLabel) {
      label = this.renderLabel({ parent: wrapper, options, type: "caption" });
    }
    const vstack = new VStack(wrapper, { gap: 4 });
    const input = new Input(vstack, {
      inputType: "number",
      height: "42px",
      width: "100%"
    });
    input.onChanged = () => {
      if (labelProp)
        labelProp.caption = input.value;
      this.validateOnValueChanged(input, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(input, input.value);
      }
    };
    input.setAttribute("role", "field");
    input.setAttribute("scope", scope);
    input.setAttribute("field", field);
    input.setAttribute("dataType", "number");
    if (options.readOnly !== void 0) {
      input.setAttribute("readOnly", options.readOnly.toString());
    }
    if (options.placeholder !== void 0) {
      input.setAttribute("placeholder", options.placeholder);
    }
    input.classList.add(inputStyle);
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      label,
      input,
      description,
      error
    };
    if (defaultValue) {
      const numDefaultValue = parseFloat(defaultValue);
      if (!isNaN(numDefaultValue))
        input.setAttribute("value", numDefaultValue.toString());
    }
    return wrapper;
  }
  renderTextArea(textAreaOption) {
    const { parent, scope, options, labelProp, defaultValue } = textAreaOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    const wrapper = new Panel(parent);
    wrapper.classList.add(formGroupStyle);
    let label;
    if (!options.hideLabel) {
      label = this.renderLabel({ parent: wrapper, options, type: "caption" });
    }
    const vstack = new VStack(wrapper);
    const input = new Input(vstack, {
      inputType: "textarea",
      height: "unset",
      rows: 5
    });
    input.onChanged = () => {
      if (labelProp)
        labelProp.caption = input.value;
      this.validateOnValueChanged(input, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(input, input.value);
      }
    };
    input.setAttribute("role", "field");
    input.setAttribute("scope", scope);
    input.setAttribute("field", field);
    input.setAttribute("dataType", "string");
    if (options.readOnly !== void 0) {
      input.setAttribute("readOnly", options.readOnly.toString());
    }
    if (options.placeholder !== void 0) {
      input.setAttribute("placeholder", options.placeholder);
    }
    input.classList.add(inputStyle);
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      label,
      input,
      description,
      error
    };
    if (defaultValue)
      input.setAttribute("value", defaultValue.toString());
    return wrapper;
  }
  renderColorPicker(colorPickerOption) {
    const { parent, scope, options, labelProp, defaultValue } = colorPickerOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    const wrapper = new Panel(parent);
    wrapper.classList.add(formGroupStyle);
    let label;
    if (!options.hideLabel) {
      label = this.renderLabel({ parent: wrapper, options, type: "caption" });
    }
    const vstack = new VStack(wrapper, { gap: 4 });
    const input = new Input(vstack, {
      inputType: "color",
      height: "42px",
      width: "100%"
    });
    input.onClosed = () => {
      if (labelProp)
        labelProp.caption = input.value;
      this.validateOnValueChanged(input, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(input, input.value);
      }
    };
    input.setAttribute("role", "field");
    input.setAttribute("scope", scope);
    input.setAttribute("field", field);
    input.setAttribute("dataType", "string");
    if (options.readOnly !== void 0) {
      input.setAttribute("readOnly", options.readOnly.toString());
    }
    input.classList.add(inputStyle);
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      label,
      input,
      description,
      error
    };
    if (defaultValue) {
      input.setAttribute("value", defaultValue.toString());
    }
    return wrapper;
  }
  renderUploader(uploaderOption) {
    const { parent, scope, options, defaultValue } = uploaderOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    const wrapper = new Panel(parent);
    wrapper.classList.add(formGroupStyle);
    let label;
    if (!options.hideLabel) {
      label = this.renderLabel({ parent: wrapper, options, type: "caption" });
    }
    const vstack = new VStack(wrapper, { gap: 4 });
    const uploader = new Upload(vstack, {
      draggable: true
    });
    uploader.classList.add(uploadStyle);
    uploader.setAttribute("role", "field");
    uploader.setAttribute("scope", scope);
    uploader.setAttribute("field", field);
    uploader.setAttribute("dataType", "string");
    uploader.onChanged = () => {
      this.validateOnValueChanged(uploader, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(uploader);
      }
    };
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      label,
      input: uploader,
      description,
      error
    };
    return wrapper;
  }
  renderDatePicker(datePickerOption) {
    var _a, _b, _c;
    const { parent, scope, type, options, defaultValue } = datePickerOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    if (type != "date" && type != "time" && type != "dateTime")
      return this.renderInput({ parent, scope, options, defaultValue });
    const wrapper = new Panel(parent);
    wrapper.classList.add(formGroupStyle);
    let label;
    if (!options.hideLabel) {
      label = this.renderLabel({ parent: wrapper, options, type: "caption" });
    }
    const vstack = new VStack(wrapper, { gap: 4 });
    let dateTimeFormat = "";
    if (type === "date")
      dateTimeFormat = ((_a = this._formOptions.dateTimeFormat) == null ? void 0 : _a.date) || DEFAULT_OPTIONS.dateTimeFormat.date;
    else if (type === "dateTime")
      dateTimeFormat = ((_b = this._formOptions.dateTimeFormat) == null ? void 0 : _b.dateTime) || DEFAULT_OPTIONS.dateTimeFormat.dateTime;
    else if (type === "time")
      dateTimeFormat = ((_c = this._formOptions.dateTimeFormat) == null ? void 0 : _c.time) || DEFAULT_OPTIONS.dateTimeFormat.time;
    let defaultDate;
    if (defaultValue) {
      defaultDate = moment(defaultValue, dateTimeFormat);
    }
    const input = new Datepicker(vstack, {
      type,
      height: "42px",
      dateTimeFormat,
      value: defaultDate || null
    });
    input.onChanged = () => {
      this.validateOnValueChanged(input, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(input, input.value);
      }
    };
    input.setAttribute("role", "field");
    input.setAttribute("scope", scope);
    input.setAttribute("field", field);
    input.setAttribute("dataType", "string");
    input.classList.add(datePickerStyle);
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      label,
      input,
      description,
      error
    };
    return wrapper;
  }
  renderComboBox(comboBoxOption) {
    const { parent, scope, items, options, labelProp, defaultValue } = comboBoxOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    const wrapper = new Panel(parent);
    wrapper.classList.add(formGroupStyle);
    let label;
    if (!options.hideLabel) {
      label = this.renderLabel({ parent: wrapper, options, type: "caption" });
    }
    const vstack = new VStack(wrapper, { gap: 4 });
    let matchItem;
    if (defaultValue) {
      matchItem = items.find((item) => item.value.toString() === defaultValue.toString());
    }
    const input = new ComboBox(vstack, {
      items,
      height: "42px",
      icon: {
        name: "caret-down"
      },
      selectedItem: matchItem || null
    });
    input.onChanged = () => {
      var _a;
      if (labelProp) {
      }
      this.validateOnValueChanged(input, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(input, (_a = input.value) == null ? void 0 : _a.value);
      }
    };
    input.setAttribute("role", "field");
    input.setAttribute("scope", scope);
    input.setAttribute("field", field);
    input.setAttribute("dataType", "string");
    if (options.readOnly !== void 0) {
      input.setAttribute("readOnly", options.readOnly.toString());
    }
    input.classList.add(comboBoxStyle);
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      label,
      input,
      description,
      error
    };
    return wrapper;
  }
  renderRadioGroup(radioGroupOption) {
    const { parent, scope, items, options, labelProp, defaultValue } = radioGroupOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    const wrapper = new Panel(parent);
    wrapper.classList.add(formGroupStyle);
    let label;
    if (!options.hideLabel) {
      label = this.renderLabel({ parent: wrapper, options, type: "caption" });
    }
    const vstack = new VStack(wrapper, { gap: 4 });
    const input = new RadioGroup(vstack, {
      radioItems: items
    });
    input.onChanged = () => {
      if (labelProp) {
      }
      this.validateOnValueChanged(input, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(input, input.selectedValue);
      }
    };
    input.setAttribute("role", "field");
    input.setAttribute("scope", scope);
    input.setAttribute("field", field);
    input.setAttribute("dataType", "string");
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      label,
      input,
      description,
      error
    };
    if (defaultValue) {
      input.setAttribute("selectedValue", defaultValue.toString());
    }
    return wrapper;
  }
  renderCheckBox(checkBoxOption) {
    const { parent, scope, options, labelProp, defaultValue } = checkBoxOption;
    const field = scope.substr(scope.lastIndexOf("/") + 1);
    const wrapper = new Panel(parent);
    wrapper.classList.add(formGroupStyle);
    const vstack = new VStack(wrapper, { gap: 4, width: "100%" });
    const input = new Checkbox(vstack, {
      caption: options.caption
    });
    input.onChanged = () => {
      if (labelProp)
        labelProp.caption = input.checked.toString();
      this.validateOnValueChanged(input, parent, scope, options == null ? void 0 : options.caption);
      if (this._formOptions.onChange) {
        this._formOptions.onChange(input, input.checked);
      }
    };
    input.setAttribute("role", "field");
    input.setAttribute("scope", scope);
    input.setAttribute("field", field);
    input.setAttribute("dataType", "boolean");
    if (options.readOnly !== void 0) {
      input.setAttribute("readOnly", options.readOnly.toString());
    }
    input.classList.add(checkboxStyle);
    const description = this.renderLabel({ parent: vstack, options, type: "description" });
    const error = this.renderLabel({ parent: vstack, options, type: "error" });
    this._formControls[scope] = {
      wrapper,
      input,
      description,
      error
    };
    if (defaultValue && typeof defaultValue === "boolean") {
      input.setAttribute("checked", defaultValue.toString());
    }
    return wrapper;
  }
  renderList(listOption) {
    const { parent, scope, options, isVertical } = listOption;
    const wrapper = new Panel(parent);
    const field = scope.split("/").pop() || "";
    wrapper.setAttribute("array-field", field);
    wrapper.setAttribute("role", "array");
    const header = new GridLayout(wrapper, { templateColumns: ["1fr", "80px"] });
    header.classList.add(listHeaderStyle);
    const hstack = new HStack(header, { gap: 2 });
    new Label(hstack, { caption: options.caption });
    if (options.required) {
      new Label(hstack, {
        caption: "*",
        font: { color: "#ff0000" }
      });
    }
    const btnAdd = new Button(header, { caption: "Add" });
    btnAdd.setAttribute("action", "add");
    btnAdd.prepend(new Icon(void 0, {
      name: "plus",
      width: "1em",
      height: "1em",
      fill: theme.colors.primary.contrastText
    }));
    btnAdd.classList.add(listBtnAddStyle);
    const columnHeader = new VStack(wrapper);
    const body = new VStack(wrapper, {
      gap: 10
    });
    if (isVertical) {
      body.setAttribute("layout", "Vertical");
      body.classList.add(listVerticalLayoutStyle);
    }
    this._formControls[scope] = {
      wrapper,
      input: body
    };
    return {
      wrapper,
      columnHeader,
      body,
      btnAdd
    };
  }
  renderCard(cardOption) {
    const { parent, scope, schema, options, uiSchema, elementLabelProp, btnAdd } = cardOption;
    if (!schema.type)
      return;
    const isVertical = parent.getAttribute("layout") === "Vertical";
    const setEnableBtnAdd = () => {
      var _a;
      if (schema.maxItems) {
        let _btnAdd = btnAdd || ((_a = parent.parentElement) == null ? void 0 : _a.querySelector('[action="add"]'));
        if (_btnAdd) {
          _btnAdd.enabled = parent.childElementCount < schema.maxItems;
        }
      }
    };
    if (schema.type === "object") {
      const properties = schema.properties;
      let hasSubLevel = !!Object.values(properties).find((value) => value.type === "object" || value.type === "array");
      if (!hasSubLevel) {
        const templates = [];
        for (let i = 0; i < Object.values(properties).length; i++) {
          templates.push("1fr");
        }
        if (!isVertical) {
          templates.push("50px");
        }
        const row = new GridLayout(parent, {
          templateColumns: isVertical ? void 0 : templates,
          gap: {
            column: 5,
            row: isVertical ? 8 : 5
          },
          verticalAlignment: isVertical ? void 0 : "start",
          alignItems: isVertical ? void 0 : "center",
          justifyContent: isVertical ? void 0 : "center"
        });
        row.classList.add(listItemStyle);
        row.setAttribute("role", "list-item");
        if (isVertical) {
          const btnDelete = new Icon(row, {
            name: "times",
            margin: { left: "auto" }
          });
          btnDelete.classList.add(listItemBtnDelete);
          btnDelete.onClick = () => {
            row.remove();
            setEnableBtnAdd();
            if (this._formOptions.onChange) {
              this._formOptions.onChange(parent);
            }
          };
          for (const fieldName in properties) {
            const property = properties[fieldName];
            this.renderFormByJSONSchema(row, property, `#/properties/${fieldName}`, false, false, { parentProp: scope });
          }
        } else {
          for (const fieldName in properties) {
            const property = properties[fieldName];
            this.renderFormByJSONSchema(row, property, `#/properties/${fieldName}`, !hasSubLevel, false, { parentProp: scope });
          }
          const btnDelete = new Icon(row, {
            name: "trash"
          });
          btnDelete.classList.add(listItemBtnDelete);
          btnDelete.onClick = () => {
            row.remove();
            if (this._formOptions.onChange) {
              this._formOptions.onChange(parent);
            }
            setEnableBtnAdd();
          };
        }
      } else {
        const card = new Panel(parent);
        card.classList.add(cardStyle);
        card.setAttribute("role", "list-item");
        const headerStack = new GridLayout(card, { gap: { column: 5, row: 5 }, templateColumns: ["1fr", "30px", "30px"] });
        headerStack.classList.add(cardHeader);
        const bodyStack = new VStack(card);
        bodyStack.classList.add(cardBody);
        const pnlElmLabel = new Panel(headerStack);
        const labelProp = new Label(pnlElmLabel);
        const btnDelete = new Icon(headerStack, { name: "trash" });
        const btnCollapse = new Icon(headerStack, { name: "chevron-down" });
        btnCollapse.onClick = headerStack.onClick = () => {
          bodyStack.visible = !bodyStack.visible;
          btnCollapse.name = `chevron-${bodyStack.visible ? "up" : "down"}`;
        };
        btnDelete.classList.add(listItemBtnDelete);
        btnDelete.onClick = () => {
          card.remove();
          if (this._formOptions.onChange) {
            this._formOptions.onChange(parent);
          }
          setEnableBtnAdd();
        };
        btnCollapse.classList.add(listItemBtnDelete);
        if (uiSchema && uiSchema.elements) {
          this.renderFormByUISchema(bodyStack, uiSchema, null, schema, elementLabelProp, labelProp);
        } else {
          this.renderFormByJSONSchema(bodyStack, schema, `${scope}/items`, true, hasSubLevel, { elementLabelProp, parentProp: scope });
        }
      }
    } else {
      const templateColumns = ["1fr", "50px"];
      const row = new GridLayout(parent, {
        templateColumns,
        gap: {
          column: 5,
          row: 5
        },
        verticalAlignment: "center",
        alignItems: "center",
        justifyContent: "center"
      });
      row.classList.add(listItemStyle);
      row.setAttribute("role", "list-item");
      this.renderFormByJSONSchema(row, schema, `${scope}/items`, true);
      const btnDelete = new Icon(row, {
        name: "trash"
      });
      btnDelete.classList.add(listItemBtnDelete);
      btnDelete.onClick = () => {
        row.remove();
        if (this._formOptions.onChange) {
          this._formOptions.onChange(parent);
        }
        setEnableBtnAdd();
      };
    }
    setEnableBtnAdd();
  }
  checkPropertyChange(value, schema, property) {
    return this.validate(value, schema, { changing: property || "property" });
  }
  mustBeValid(result) {
    if (!result.valid) {
      throw new TypeError(result.errors.map(function(error) {
        return "for property " + error.property + ": " + error.message;
      }).join(", \n"));
    }
  }
  validate(instance, schema, options) {
    if (!options)
      options = {};
    var _changing = options.changing;
    function getType(schema2) {
      return schema2.type;
    }
    var errors = [];
    function checkProp(value, schema2, path, scope, i, isNonObjArrayItem) {
      var _a;
      if (isNonObjArrayItem && typeof i === "number") {
        if (typeof value === "object") {
          value = value[Object.keys(value)[0]];
          if (isNaN(value) && (schema2.type === "number" || schema2.type === "integer"))
            value = "";
        }
        scope = scope + "_" + (i + 1).toString();
      } else {
        const parsedPath = path.split(".");
        let parsedScope = scope.split("/");
        let parentProp = "";
        if (parsedScope.length > 1) {
          parsedScope = parsedScope.splice(0, parsedScope.length - 2);
          parentProp = parsedScope[parsedScope.length - 1].split("_")[0];
        }
        let idxOfArray = -1;
        parsedPath.forEach((value2) => {
          if (value2.includes(parentProp)) {
            let matches = value2.match(/\[(.*?)\]/);
            if (matches)
              idxOfArray = parseInt(matches[1]) + 1;
          }
        });
        if (idxOfArray > 0 && getType(schema2) != "object") {
          scope = scope + "_" + idxOfArray;
        }
      }
      var l;
      path += path ? typeof i == "number" ? "[" + i + "]" : typeof i == "undefined" ? "" : "." + i : i;
      function addError(message, scope2, overwritePath) {
        errors.push({ property: overwritePath || path, scope: scope2, message });
      }
      if ((typeof schema2 != "object" || schema2 instanceof Array) && (path || typeof schema2 != "function") && !(schema2 && getType(schema2))) {
        if (typeof schema2 == "function") {
          if (!(value instanceof schema2)) {
            addError("is not an instance of the class/constructor " + schema2.name, scope);
          }
        } else if (schema2) {
          addError("Invalid schema/property definition " + schema2, scope);
        }
        return null;
      }
      if (_changing && schema2.readOnly) {
        addError("is a readonly field, it can not be changed", scope);
      }
      if (schema2.extends) {
        checkProp(value, schema2.extends, path, scope, i);
      }
      function checkType(type, value2, scope2) {
        if (type) {
          if (type == "string" && value2 instanceof moment)
            return [];
          if (type != "any" && (type == "null" ? value2 !== null : typeof value2 != type) && !(value2 instanceof Array && type == "array") && typeof type == "string" && !(type == "integer" && value2 % 1 === 0)) {
            return [{
              property: path,
              scope: scope2,
              message: value2 + " - " + typeof value2 + " value found, but a " + type + " is required"
            }];
          }
          if (type instanceof Array) {
            let unionErrors = [];
            for (var j2 = 0; j2 < type.length; j2++) {
              if (!(unionErrors = checkType(type[j2], value2, scope2)).length) {
                break;
              }
            }
            if (unionErrors.length) {
              return unionErrors;
            }
          } else if (typeof type == "object") {
            var priorErrors = errors;
            errors = [];
            checkProp(value2, type, path, scope2);
            var theseErrors = errors;
            errors = priorErrors;
            return theseErrors;
          }
        }
        return [];
      }
      const isEmptyValue = value === void 0 || value === "" || value instanceof Array && (!value.length || value.findIndex((v) => v === void 0 || v === "") !== -1) && ((_a = schema2.items) == null ? void 0 : _a.type) === "object";
      if (isEmptyValue) {
        if (schema2.required && typeof schema2.required === "boolean") {
          addError("is missing and it is required", scope);
        }
      } else {
        if (getType(schema2) === "object" && schema2.required instanceof Array) {
          for (let requiredField of schema2.required) {
            if (value[requiredField] === void 0 || value[requiredField] === "" || value[requiredField] instanceof Array && !value[requiredField].length) {
              addError(`is missing and it is required`, scope + "/properties/" + requiredField, requiredField);
            }
          }
        }
        errors = errors.concat(checkType(getType(schema2), value, scope));
        if (schema2.disallow && !checkType(schema2.disallow, value, scope).length) {
          addError(" disallowed value was matched", scope);
        }
        if (value !== null) {
          if (value instanceof Array) {
            if (schema2.items) {
              var itemsIsArray = schema2.items instanceof Array;
              var propDef = schema2.items;
              for (i = 0, l = value.length; i < l; i += 1) {
                if (itemsIsArray)
                  propDef = schema2.items[i];
                if (options.coerce)
                  value[i] = options.coerce(value[i], propDef);
                if (schema2.items.type == "object") {
                  var errors2 = checkProp(value[i], propDef, path, scope, i);
                  if (errors2)
                    errors.concat(errors2);
                }
              }
            }
            if (schema2.minItems && value.length < schema2.minItems) {
              addError("There must be a minimum of " + schema2.minItems + " in the array", scope);
            }
            if (schema2.maxItems && value.length > schema2.maxItems) {
              addError("There must be a maximum of " + schema2.maxItems + " in the array", scope);
            }
          } else if (schema2.properties || schema2.additionalProperties) {
            errors.concat(checkObj(value, schema2.properties, path, schema2.additionalProperties, scope));
          }
          if (schema2.items && schema2.items.type != "object") {
            const itemSchema = { required: schema2.required, ...schema2.items };
            for (let i2 = 0; i2 < value.length; i2++) {
              checkProp(value[i2], itemSchema, path, scope, i2, true);
            }
          }
          if (schema2.pattern && typeof value == "string" && !value.match(schema2.pattern)) {
            addError("does not match the regex pattern " + schema2.pattern, scope);
          }
          if (schema2.maxLength && typeof value == "string" && value.length > schema2.maxLength) {
            addError("may only be " + schema2.maxLength + " characters long", scope);
          }
          if (schema2.minLength && typeof value == "string" && value.length < schema2.minLength) {
            addError("must be at least " + schema2.minLength + " characters long", scope);
          }
          if (typeof schema2.minimum !== "undefined" && typeof value == typeof schema2.minimum && schema2.minimum > value) {
            addError("must have a minimum value of " + schema2.minimum, scope);
          }
          if (typeof schema2.maximum !== "undefined" && typeof value == typeof schema2.maximum && schema2.maximum < value) {
            addError("must have a maximum value of " + schema2.maximum, scope);
          }
          if (schema2["enum"]) {
            var enumer = schema2["enum"];
            l = enumer.length;
            var found;
            for (var j = 0; j < l; j++) {
              if (enumer[j] === value) {
                found = 1;
                break;
              }
            }
            if (!found) {
              addError("does not have a value in the enumeration " + enumer.join(", "), scope);
            }
          }
          if (typeof schema2.maxDecimal == "number" && value.toString().match(new RegExp("\\.[0-9]{" + (schema2.maxDecimal + 1) + ",}"))) {
            addError("may only have " + schema2.maxDecimal + " digits of decimal places", scope);
          }
          if (value !== "") {
            if (schema2.format === "wallet-address") {
              const regex = new RegExp("^((0x[a-fA-F0-9]{40})|([13][a-km-zA-HJ-NP-Z1-9]{25,34})|(X[1-9A-HJ-NP-Za-km-z]{33})|(4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}))$");
              if (!regex.test(value))
                addError("is not a valid wallet address", scope);
            } else if (schema2.format === "cid") {
              const regex = new RegExp("^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$");
              if (!regex.test(value))
                addError("is not a valid cid", scope);
            } else if (schema2.format === "cid-v0") {
              const regex = new RegExp("^(Qm[1-9A-HJ-NP-Za-km-z]{44,})$");
              if (!regex.test(value))
                addError("is not a valid version 0 cid", scope);
            } else if (schema2.format === "cid-v1") {
              const regex = new RegExp("^(b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$");
              if (!regex.test(value))
                addError("is not a valid version 1 cid", scope);
            } else if (schema2.format === "uuid") {
              const regex = new RegExp("^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$");
              if (!regex.test(value))
                addError("is not a valid uuid", scope);
            }
          }
        }
      }
      return null;
    }
    function checkObj(instance2, objTypeDef, path, additionalProp, scope) {
      if (typeof objTypeDef == "object") {
        if (typeof instance2 != "object" || instance2 instanceof Array) {
          errors.push({ property: path, scope, message: "an object is required" });
        }
        for (var i in objTypeDef) {
          if (objTypeDef.hasOwnProperty(i) && i != "__proto__" && i != "constructor") {
            var value = instance2.hasOwnProperty(i) ? instance2[i] : void 0;
            if (value === void 0 && options.existingOnly)
              continue;
            var propDef = objTypeDef[i];
            if (value === void 0 && propDef["default"]) {
              value = instance2[i] = propDef["default"];
            }
            if (options.coerce && i in instance2) {
              value = instance2[i] = options.coerce(value, propDef);
            }
            checkProp(value, propDef, path, scope + "/properties/" + i, i);
          }
        }
      }
      for (i in instance2) {
        if (instance2.hasOwnProperty(i) && !(i.charAt(0) == "_" && i.charAt(1) == "_") && objTypeDef && !objTypeDef[i] && additionalProp === false) {
          if (options.filter) {
            delete instance2[i];
            continue;
          } else {
            errors.push({
              property: path,
              message: "The property " + i + " is not defined in the schema and the schema does not allow additional properties",
              scope
            });
          }
        }
        var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
        if (requires && !(requires in instance2)) {
          errors.push({
            property: path,
            scope,
            message: "the presence of the property " + i + " requires that " + requires + " also be present"
          });
        }
        value = instance2[i];
        if (additionalProp && (!(objTypeDef && typeof objTypeDef == "object") || !(i in objTypeDef))) {
          if (options.coerce) {
            value = instance2[i] = options.coerce(value, additionalProp);
          }
          checkProp(value, additionalProp, path, scope + "/properties/" + i, i);
        }
        if (!_changing && value && value.$schema) {
          const errors2 = checkProp(value, value.$schema, path, scope + "/properties/" + i, i);
          if (errors2)
            errors = errors.concat(errors2);
        }
      }
      return errors;
    }
    const root = "#";
    if (schema) {
      checkProp(instance, schema, "", root, _changing || "");
    }
    if (!_changing && instance && instance.$schema) {
      checkProp(instance, instance.$schema, "", root, "");
    }
    return { valid: !errors.length, errors };
  }
  convertFieldNameToLabel(name) {
    let label = "";
    for (let i = 0; i < name.length; i++) {
      let char = name[i];
      if (i == 0) {
        label += char.toUpperCase();
        continue;
      }
      if (char == char.toUpperCase())
        label += ` ${char}`;
      else
        label += char;
    }
    return label;
  }
  setDataUpload(url, control) {
    if (!url || !control)
      return;
    const getImageTypeFromUrl = (url2) => {
      const extension = url2.match(/\.([^.]+)$/);
      switch (extension && extension[1].toLowerCase()) {
        case "jpg":
        case "jpeg":
          return "image/jpeg";
        case "gif":
          return "image/gif";
        case "svg":
          return "image/svg";
        default:
          return "image/png";
      }
    };
    const getExtensionFromType = (fileType) => {
      return fileType.split("/")[1];
    };
    try {
      let imgUrl = url;
      const regex = new RegExp("^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})$");
      if (regex.test(url)) {
        imgUrl = IPFS_Gateway + imgUrl;
      } else if (url.startsWith("ipfs://")) {
        imgUrl = imgUrl.replace("ipfs://", IPFS_Gateway);
      }
      fetch(imgUrl).then((response) => response.arrayBuffer()).then(async (arrayBuffer) => {
        const fileType = getImageTypeFromUrl(imgUrl);
        const blob = new Blob([arrayBuffer], { type: fileType });
        const fileName = `image-${Date.now()}.${getExtensionFromType(fileType)}`;
        const file = new File([blob], fileName, { type: fileType });
        file.cid = await hashFile(file);
        control.fileList = [file];
        control.preview(imgUrl);
      });
    } catch (e) {
      control.fileList = [];
    }
  }
};
Form = __decorateClass([
  customElements2("i-form", {
    props: {},
    events: {}
  })
], Form);

// packages/repeater/src/style/repeater.css.ts
var Theme46 = theme_exports.ThemeVars;
cssRule("i-repeater", {
  display: "block",
  width: "100%",
  $nest: {
    ".repeater-container": {
      display: "flex",
      flexDirection: "column"
    }
  }
});

// packages/repeater/src/repeater.ts
var DEFAULT_COUNT = 0;
var Repeater = class extends Container {
  constructor(parent, options) {
    super(parent, options);
  }
  get count() {
    var _a;
    return (_a = this._count) != null ? _a : DEFAULT_COUNT;
  }
  set count(value) {
    this._count = value != null ? value : DEFAULT_COUNT;
    this.cloneItems();
  }
  foreachNode(node, clonedNode) {
    var _a;
    if (!node)
      return;
    if (typeof (node == null ? void 0 : node._getCustomProperties) === "function") {
      const props = node._getCustomProperties().props || {};
      const keys = Object.keys(props);
      for (let key2 of keys) {
        const value = (_a = node._getDesignPropValue(key2)) != null ? _a : node.getAttribute(key2);
        if (!this.isEmpty(key2, value)) {
          if (clonedNode) {
            clonedNode[key2] = value;
          }
        }
      }
    }
    for (let i = 0; i < node.children.length; i++) {
      const child2 = node.children[i];
      const clonedChild = clonedNode == null ? void 0 : clonedNode.children[i];
      if (child2.hasChildNodes()) {
        this.foreachNode(child2, clonedChild);
      }
    }
  }
  isEmpty(key2, value) {
    var _a;
    return value === void 0 || value === null || typeof value === "object" && !Object.keys(value).length || (key2 === "link" || key2 === "image") && !(value == null ? void 0 : value.url) || (key2 === "icon" || key2 === "rightIcon") && (!(value == null ? void 0 : value.name) || !((_a = value == null ? void 0 : value.image) == null ? void 0 : _a.url)) || key2 === "caption";
  }
  cloneItems() {
    if (this._designMode)
      return;
    this.wrapper.innerHTML = "";
    if (!this.templateEl.content || !this.count)
      return;
    for (let i = 0; i < this.count; i++) {
      const clone = document.importNode(this.templateEl.content, true);
      this.wrapper.appendChild(clone);
      const newControl = this.wrapper.lastElementChild;
      this.foreachNode(this.templateEl.content.firstChild, newControl);
      if (typeof this.onRender === "function")
        this.onRender(this.wrapper, i);
    }
  }
  add(item) {
    if (!this.pnlPanel) {
      this.pnlPanel = new Panel(void 0, {});
    }
    this.pnlPanel.appendChild(item);
    if (this._designMode) {
      this.wrapper.innerHTML = "";
      this.wrapper.append(this.pnlPanel);
    } else {
      this.templateEl.innerHTML = "";
      this.templateEl.content.append(this.pnlPanel);
    }
    this.cloneItems();
    return item;
  }
  update() {
    this.cloneItems();
  }
  clear() {
    this.wrapper.innerHTML = "";
  }
  init() {
    if (!this.initialized) {
      let childNodes = [];
      for (let i = 0; i < this.childNodes.length; i++) {
        const el = this.childNodes[i];
        childNodes.push(el);
      }
      this.onRender = this.getAttribute("onRender", true) || this.onRender;
      const count = this.getAttribute("count", true, DEFAULT_COUNT);
      super.init();
      this.wrapper = this.createElement("div", this);
      this.wrapper.classList.add("repeater-container");
      this.templateEl = this.createElement("template", this);
      this.pnlPanel = new Panel(void 0, {});
      if (childNodes == null ? void 0 : childNodes.length) {
        for (let i = 0; i < childNodes.length; i++) {
          this.pnlPanel.appendChild(childNodes[i]);
        }
        if (this._designMode) {
          this.wrapper.append(this.pnlPanel);
        } else {
          this.templateEl.content.append(this.pnlPanel);
        }
      }
      this.count = count;
    }
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
};
Repeater = __decorateClass([
  customElements2("i-repeater", {
    icon: "clone",
    group: GroupType.BASIC,
    className: "Repeater",
    props: {
      count: {
        type: "number",
        default: DEFAULT_COUNT
      }
    },
    events: {
      onRender: [
        { name: "parent", type: "Control", isControl: true },
        { name: "index", type: "number" }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        count: {
          type: "number",
          default: DEFAULT_COUNT
        }
      }
    }
  })
], Repeater);

// packages/accordion/src/style/accordion.css.ts
cssRule("i-accordion", {
  display: "block",
  $nest: {}
});
var customStyles = style({
  $nest: {
    ".accordion-body": {
      transition: "height 0.4s ease-in",
      height: 0,
      overflow: "hidden"
    },
    "&.expanded > .accordion-body": {
      height: "auto"
    },
    ".accordion-header": {
      $nest: {
        "i-label": {
          fontSize: "inherit"
        }
      }
    }
  }
});
var expandablePanelStyle = style({
  $nest: {
    "i-panel": {
      border: "none"
    }
  }
});

// packages/accordion/src/accordion-item.ts
var AccordionItem = class extends Container {
  constructor(parent, options) {
    super(parent, options);
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  get name() {
    var _a;
    return (_a = this._name) != null ? _a : "";
  }
  set name(value) {
    this._name = value != null ? value : "";
    if (this.lbTitle) {
      this.lbTitle.caption = value;
    }
  }
  get defaultExpanded() {
    var _a;
    return (_a = this._defaultExpanded) != null ? _a : false;
  }
  set defaultExpanded(value) {
    this._defaultExpanded = value != null ? value : false;
    this._expanded = this._defaultExpanded;
    this.updatePanel();
  }
  get expanded() {
    var _a;
    return (_a = this._expanded) != null ? _a : false;
  }
  set expanded(value) {
    this._expanded = value != null ? value : false;
    this.updatePanel();
  }
  get showRemove() {
    var _a;
    return (_a = this._showRemove) != null ? _a : false;
  }
  set showRemove(value) {
    this._showRemove = value != null ? value : false;
    if (this.iconRemove) {
      this.iconRemove.visible = this._showRemove;
    }
  }
  get contentControl() {
    return this.pnlContent;
  }
  async renderUI() {
    this.pnlAccordionItem = new VStack(void 0, {
      padding: { top: "0.5rem", bottom: "0.5rem", left: "0.5rem", right: "0.5rem" },
      class: `${customStyles}`
    });
    const hStack = new HStack(this.pnlAccordionItem, {
      horizontalAlignment: "space-between",
      verticalAlignment: "center",
      padding: { top: "0.5rem", bottom: "0.5rem" },
      cursor: "pointer",
      class: "accordion-header"
    });
    hStack.onClick = this.onSelectClick.bind(this);
    this.lbTitle = new Label(hStack, {
      caption: this.name,
      class: "accordion-title",
      lineHeight: 1.3
    });
    const innerHStack = new HStack(hStack, {
      verticalAlignment: "center",
      gap: "0.5rem"
    });
    this.iconExpand = new Icon(innerHStack, {
      name: "angle-right",
      width: 20,
      height: 28,
      fill: theme_exports.ThemeVars.text.primary,
      class: "icon-expand"
    });
    this.iconRemove = new Icon(innerHStack, {
      name: "times",
      width: 20,
      height: 20,
      fill: theme_exports.ThemeVars.text.primary,
      visible: this.showRemove
    });
    this.iconRemove.onClick = this.onRemoveClick.bind(this);
    this.pnlContent = new Panel(this.pnlAccordionItem, {
      class: `accordion-body ${expandablePanelStyle}`
    });
    this.appendChild(this.pnlAccordionItem);
    this.expanded = !this._expanded && this._defaultExpanded;
  }
  updatePanel() {
    if (this._expanded) {
      this.iconExpand.name = "angle-down";
      this.pnlContent.visible = true;
      this.pnlAccordionItem.classList.add("expanded");
    } else {
      this.iconExpand.name = "angle-right";
      this.pnlContent.visible = false;
      this.pnlAccordionItem.classList.remove("expanded");
    }
  }
  onSelectClick(target, event) {
    event.stopPropagation();
    if (this.onSelected)
      this.onSelected(this);
  }
  onRemoveClick() {
    if (this.onRemoved)
      this.onRemoved(this);
  }
  add(item) {
    item.parent = this.pnlContent;
    this.pnlContent.appendChild(item);
    return item;
  }
  async init() {
    if (!this.initialized) {
      let childNodes = [];
      this.childNodes.forEach((node) => {
        childNodes.push(node);
      });
      this.onSelected = this.getAttribute("onSelected", true) || this.onSelected;
      this.onRemoved = this.getAttribute("onRemoved", true) || this.onRemoved;
      const name = this.getAttribute("name", true);
      const defaultExpanded = this.getAttribute("defaultExpanded", true);
      const showRemove = this.getAttribute("showRemove", true, false);
      super.init();
      this._name = name;
      this._defaultExpanded = defaultExpanded;
      this._showRemove = showRemove;
      await this.renderUI();
      if (!this.pnlContent.isConnected)
        await this.pnlContent.ready();
      if (childNodes == null ? void 0 : childNodes.length) {
        for (let i = 0; i < childNodes.length; i++) {
          const item = childNodes[i];
          this.add(item);
        }
      }
    }
  }
};
AccordionItem = __decorateClass([
  customElements2("i-accordion-item", {
    icon: "angle-down",
    group: GroupType.BASIC,
    className: "AccordionItem",
    props: {
      name: { type: "string", default: "" },
      defaultExpanded: { type: "boolean", default: false },
      showRemove: { type: "boolean", default: false }
    },
    events: {},
    dataSchema: {
      type: "object",
      properties: {
        name: {
          type: "string",
          title: "Name"
        },
        defaultExpanded: {
          type: "boolean",
          title: "Default Expanded",
          default: false
        },
        showRemove: {
          type: "boolean",
          title: "Show Remove",
          default: false
        }
      }
    }
  })
], AccordionItem);

// packages/accordion/src/accordion.ts
var Accordion = class extends Control {
  constructor(parent, options) {
    super(parent, options);
    this._items = [];
    this._isFlush = false;
    this.accordionItemMapper = new Map();
    this.onItemClick = this.onItemClick.bind(this);
    this.onRemoveClick = this.onRemoveClick.bind(this);
  }
  static async create(options, parent) {
    let self = new this(parent, options);
    await self.ready();
    return self;
  }
  get isFlush() {
    var _a;
    return (_a = this._isFlush) != null ? _a : false;
  }
  set isFlush(value) {
    this._isFlush = value != null ? value : false;
  }
  get items() {
    var _a;
    return (_a = this._items) != null ? _a : [];
  }
  set items(value) {
    this._items = value != null ? value : [];
    this.wrapper.clearInnerHTML();
    this.accordionItemMapper = new Map();
    for (let i = 0; i < this.items.length; i++) {
      const item = { ...this.items[i] };
      this.createAccordionItem(item);
    }
  }
  createAccordionItem(item) {
    var _a;
    const itemElm = new AccordionItem(this.wrapper, {
      ...item,
      class: "accordion-item",
      onSelected: this.onItemClick,
      onRemoved: this.onRemoveClick
    });
    itemElm.id = (_a = item.id) != null ? _a : itemElm.uuid;
    this.accordionItemMapper.set(itemElm.id, itemElm);
    return itemElm;
  }
  onItemClick(target) {
    if (this._designMode)
      return;
    const id = target.id;
    const currentActive = this.accordionItemMapper.get(id);
    if (this.isFlush) {
      Array.from(this.accordionItemMapper).forEach((item) => {
        if (item[0] !== id)
          item[1].expanded = false;
      });
    }
    if (currentActive)
      currentActive.expanded = !currentActive.expanded;
  }
  async onRemoveClick(target) {
    if (this._designMode)
      return;
    const id = target.id;
    this.removeItem(id);
    if (typeof this.onCustomItemRemoved === "function")
      await this.onCustomItemRemoved(target);
  }
  add(item) {
    const itemElm = this.createAccordionItem(item);
    this.items.push(item);
    return itemElm;
  }
  updateItemName(id, name) {
    const item = this.accordionItemMapper.get(id);
    if (item) {
      const titleEl = item.querySelector(".accordion-title");
      if (titleEl)
        titleEl.caption = name;
    }
  }
  removeItem(id) {
    const item = this.accordionItemMapper.get(id);
    if (item) {
      item.remove();
      this.accordionItemMapper.delete(id);
      this._items = this._items.filter((item2) => item2.id !== id);
    }
  }
  clear() {
    this.wrapper.clearInnerHTML();
    this.accordionItemMapper = new Map();
    this.items = [];
  }
  appendItem(item) {
    if (!item.id) {
      item.id = item.uuid;
    }
    this.accordionItemMapper.set(item.id, item);
    item.onSelected = this.onItemClick;
    item.onRemoved = this.onRemoveClick;
    this.wrapper.append(item);
  }
  async init() {
    if (!this.initialized) {
      let childNodes = [];
      this.childNodes.forEach((node) => {
        if (node instanceof AccordionItem) {
          childNodes.push(node);
        } else {
          node.remove();
        }
      });
      const items = this.getAttribute("items", true);
      const isFlush = this.getAttribute("isFlush", true, false);
      this.onCustomItemRemoved = this.getAttribute("onCustomItemRemoved", true) || this.onCustomItemRemoved;
      super.init();
      this.wrapper = new VStack();
      this.append(this.wrapper);
      this.isFlush = isFlush;
      if (childNodes == null ? void 0 : childNodes.length) {
        for (let i = 0; i < childNodes.length; i++) {
          const item = childNodes[i];
          this.appendItem(item);
        }
      }
      if (items)
        this.items = items;
    }
  }
};
Accordion = __decorateClass([
  customElements2("i-accordion", {
    icon: "angle-down",
    group: GroupType.BASIC,
    className: "Accordion",
    props: {
      items: { type: "array" },
      isFlush: { type: "boolean", default: false }
    },
    events: {
      onCustomItemRemoved: [
        { name: "item", type: "Control", isControl: true }
      ]
    },
    dataSchema: {
      type: "object",
      properties: {
        isFlush: {
          type: "boolean",
          title: "Flush",
          default: false
        }
      }
    }
  })
], Accordion);
/*!-----------------------------------------------------------
* Copyright (c) IJS Technologies. All rights reserved.
* Released under dual AGPLv3/commercial license
* https://ijs.network
*-----------------------------------------------------------*/
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! moment.js
//! momentjs.com
//! version : 2.29.4
  
});